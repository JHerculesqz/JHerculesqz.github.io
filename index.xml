<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>妙木山</title><link>https://jherculesqz.github.io/</link><description>Recent content on 妙木山</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 18 Jul 2023 18:00:59 +0800</lastBuildDate><atom:link href="https://jherculesqz.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>关于</title><link>https://jherculesqz.github.io/about/</link><pubDate>Thu, 05 Aug 2021 13:01:37 +0800</pubDate><guid>https://jherculesqz.github.io/about/</guid><description>&lt;h1 id="关于博客">关于博客&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>独立&lt;/strong>：一直在写技术博客，从微信公众号、头条号、SegmentFault、掘金、简书一路折腾过来，还是希望有一个自己独立的空间。&lt;/li>
&lt;li>&lt;strong>坚持&lt;/strong>：随着年龄增长，逐渐欲说还休，还是文字更有韵味，希望自己能坚持写下去。&lt;/li>
&lt;li>&lt;strong>浪漫&lt;/strong>：按照&lt;a href="https://archiveprogram.github.com">Archive Program&lt;/a>计划的愿景，我的博客会在&amp;rdquo; GitHub北极代码库&amp;quot;中保存千年。想想1000年以后，我的后代们能读到我这个中二祖先的文字，还是一件挺浪漫的事儿。&lt;/li>
&lt;li>&lt;strong>感谢&lt;/strong>：感谢GitHub Pages、Hugo、Jane提供的技术支持。&lt;/li>
&lt;li>&lt;strong>妙木山&lt;/strong>：妙木山是修炼仙术的地方，作为火影的死忠粉，&amp;ldquo;妙木山&amp;quot;无比适合这个博客的定位——修炼、探索。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/about/MiaoMu.png" alt="MiaoMu">&lt;/p>
&lt;h1 id="关于我">关于我&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>行业&lt;/strong>：软件行业16年，无法用语言表达对编程的喜爱——举个栗子吧：有段时间喜欢在酒吧里写代码，同去的小伙伴无聊地陌陌上约人，自我介绍就是&amp;quot;A+吧台，旁边有个写代码的沙雕&amp;rdquo;。&lt;/li>
&lt;li>&lt;strong>技术方向&lt;/strong>：近几年痴迷语言和编译器技术，还有点痴迷计算机图形学。
&lt;ul>
&lt;li>&lt;strong>编程语言&lt;/strong>：目前工作Java和JavaScript用的最多，但我最喜欢C#——PHP是最好的语言，行了吧！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>哲学&lt;/strong>：不知何时，开始期待理解生命的意义。东一本西一本的书拿来乱翻，也没找到答案。不过，也不是全无收获——能模模糊糊地体会诗词的意境、能回味出毛选的奇妙、能敬畏金刚经的高深……继续求索吧……&lt;/li>
&lt;li>&lt;strong>兴趣&lt;/strong>：年轻的时候，喜欢轮滑、滑板、快乐肥仔水。现在，喜欢滑雪、乒乓球、茶(特指正山小种)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/about/Me.png" alt="Me">&lt;/p></description></item><item><title>【ChatGPT】ChatGPT学习笔记2-不是什么?是什么?有何方向?</title><link>https://jherculesqz.github.io/post/ai%E6%8B%BE%E9%81%97/chatgptchatgpt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/</link><pubDate>Tue, 18 Jul 2023 18:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/ai%E6%8B%BE%E9%81%97/chatgptchatgpt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/</guid><description>&lt;p>最近有小伙伴提意见，希望我的专栏能用小短篇的形式，将大模型相关知识通俗阐述一下。&lt;/p>
&lt;p>特此请ChatGPT协助我一起将近几个月阅读的资料以笔记体记录下来，与大家分享。&lt;/p>
&lt;h1 id="1chatgpt不是什么">1.ChatGPT不是什么?&lt;/h1>
&lt;h2 id="11古早的聊天机器人">1.1.古早的聊天机器人&lt;/h2>
&lt;p>一些古早的聊天机器人、客服机器人，有采用如下方式进行实现：&lt;/p>
&lt;ul>
&lt;li>利用分词组件对用户输入的问题进行分词，获得问题中的关键词。&lt;/li>
&lt;li>将关键词，在数据库、在互联网的上中进行搜索。
&lt;ul>
&lt;li>其中，数据库中预置了很多问题和答案。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将得到的答案过滤清洗、随机返回其中1个答案。&lt;/li>
&lt;/ul>
&lt;h2 id="12现代的聊天机器人">1.2.现代的聊天机器人&lt;/h2>
&lt;p>&lt;strong>ChatGPT及其更早的NLP领域技术&lt;/strong>，早已&lt;strong>不是从数据库、互联网&lt;/strong>生成答案的。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230718234119962.png" alt="image-20230718234119962">&lt;/p>
&lt;p>ChatGPT官方也明确表达了&amp;quot;ChatGPT is not connected to the internet&amp;rdquo;。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719065005501.png" alt="image-20230719065005501">&lt;/p>
&lt;h1 id="2chatgpt是什么">2.ChatGPT是什么？&lt;/h1>
&lt;h2 id="21大模型的生成原理chatgpt版">2.1.大模型的生成原理(ChatGPT版)&lt;/h2>
&lt;ul>
&lt;li>请ChatGPT解释一下大模型的生成原理，如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719092626552.png" alt="image-20230719092626552">&lt;/p>
&lt;h2 id="22大模型的生成原理通俗版">2.2.大模型的生成原理(通俗版)&lt;/h2>
&lt;p>我们再来通俗理解一下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>STEP1&lt;/strong>：问一个问题&amp;quot;什么是ChatGPT？&amp;quot;，可以将ChatGPT看成1个函数F，这个函数会输出即将回答的答案中第一个字(词)的概率。比如：根据问题，答案第一个字是&amp;quot;c&amp;quot;的概率是最大，最终就认为答案的第1个字是&amp;quot;c&amp;rdquo;。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719093253167.png" alt="image-20230719093253167">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>STEP2&lt;/strong>：将STEP1的输出追加到问题上，问题就变成了&amp;quot;什么是ChatGPT?c&amp;rdquo;，继续输入给函数F，得到新的概率，最终认为答案的第2个字是&amp;quot;h&amp;rdquo;。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719094213880.png" alt="image-20230719094213880">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>STEP3、STEP4、STEP5&lt;/strong>：不断重复STEP1、STEP2的动作，就会得到完整的答案，如下图：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719094340618.png" alt="image-20230719094340618">&lt;/p>
&lt;h1 id="3未来的研究方向">3.未来的研究方向？&lt;/h1>
&lt;p>大模型未来的热点研究方向很多很多：提示词工程、神经网络编辑、机器遗忘、自适应计算和自适应模型、跨模态学习、模型压缩和加速、集成多任务和元学习、强化学习和自监督学习等等。&lt;/p>
&lt;p>笔者认为&amp;rdquo;&lt;strong>提示词工程、神经网络编辑、机器遗忘&lt;/strong>&amp;ldquo;最为有趣，因为它们和脑科学有点相近之处，都是在&amp;quot;激发神经网络&amp;rdquo;、&amp;ldquo;修改神经网络&amp;rdquo;、&amp;ldquo;抹除神经网络&amp;rdquo;。&lt;/p>
&lt;h2 id="31提示词工程">3.1.提示词工程&lt;/h2>
&lt;ul>
&lt;li>Prompt Engineering，吴恩达老师的课程让这个热点更热。提示词工程的本质可以认为：大模型好像一个&lt;strong>博学的老人家&lt;/strong>(世界知识几乎都知道)，只是&lt;strong>记性不太好&lt;/strong>。你需要用一些特殊的提示词唤醒他的记忆(俗称会念咒)，他就能很好地回答你的问题。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719085754568.png" alt="image-20230719085754568">&lt;/p>
&lt;h2 id="32神经网络编辑">3.2.神经网络编辑&lt;/h2>
&lt;p>Neural Editing，随着模型越来越大，训练好一个模型的成本极高，重新训练几乎不可能，因此需要有一种改进神经网络生成结果的技术，可以通过对模型的生成结果进行编辑，来获得更准确、更自然的结果。该技术通常涉及到在生成结果中插入或删除一些元素，或者重新排列生成结果的顺序，以获得更好的输出结果。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719090639814.png" alt="image-20230719090639814">&lt;/p>
&lt;h2 id="33机器遗忘">3.3.机器遗忘&lt;/h2>
&lt;p>Machine Unlearning，机器遗忘是一种让机器学会忘记以前的知识的技术。说白了，就是&amp;quot;你知道了不该知道的事情&amp;rdquo;。这项技术可以应用于安全隐私、AI伦理领域。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88_%E6%98%AF%E4%BB%80%E4%B9%88_%E6%9C%89%E4%BD%95%E6%96%B9%E5%90%91/image-20230719091436950.png" alt="image-20230719091436950">&lt;/p>
&lt;h2 id="34其它方向">3.4.其它方向&lt;/h2>
&lt;p>以下来自于ChatGPT的解释，供参考：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>自适应计算和自适应模型&lt;/strong>：在大模型上进行计算是一项巨大的挑战，因为它们需要大量的计算资源和内存。因此，未来的研究方向将包括自适应计算和自适应模型，旨在优化大模型的计算效率和资源利用率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>跨模态学习&lt;/strong>：指使用多种类型的数据来训练一个模型。例如，将文本、图像和语音数据结合起来训练一个模型，以获得更准确、更全面的结果。未来的研究方向将探索如何在大模型上实现跨模态学习，以进一步提高模型的准确性和泛化能力。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>模型压缩和加速&lt;/strong>：由于大模型需要大量的计算资源和内存，因此未来的研究方向将包括模型压缩和加速，以减少模型的大小和计算负载，从而使模型更加可扩展和可用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>集成多任务和元学习&lt;/strong>：指在一个模型中同时处理多个任务，例如，在自然语言处理中同时进行命名实体识别和情感分析。元学习是指在训练过程中学习如何学习的过程。未来的研究方向将集中在如何在大模型上实现多任务学习和元学习，以提高模型的泛化能力和效率。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>强化学习和自监督学习&lt;/strong>：强化学习是指使用奖励信号来训练一个模型，在自我监督学习中，模型从未标记的数据中学习。未来的研究方向将集中在如何在大型模型上实现强化学习和自我监督学习，以提高模型的效率和准确性。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明：本文部分内容由ChatGPT生成。&lt;/p>
&lt;/blockquote></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-8</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-8/</link><pubDate>Wed, 24 May 2023 01:09:00 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-8/</guid><description>&lt;p>本文重点解读JDK中的重要概念——线程组(&lt;code>ThreadGroup&lt;/code>)的源码。&lt;/p>
&lt;h1 id="1线程组的树状结构">1.线程组的树状结构&lt;/h1>
&lt;p>我们先看一下&lt;code>java.lang.ThreadGroup&lt;/code>的成员变量：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230523203618607.png" alt="image-20230523203618607">&lt;/p>
&lt;p>通过JDK源码可以看到，每个&lt;code>ThreadGroup&lt;/code>对象拥有一个父线程组&lt;code>parent&lt;/code>，同时每个&lt;code>ThreadGroup&lt;/code>对象也拥有自己的子线程组集合&lt;code>group[]&lt;/code>和子线程集合&lt;code>threads[]&lt;/code>。&lt;/p>
&lt;p>这样，JDK的&lt;code>ThreadGroup&lt;/code>本质上形成了一个线程组和线程的树状结构。如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230523203932254.png" alt="image-20230523203932254">&lt;/p>
&lt;h1 id="2决定线程组父子关系的时机构造函数">2.决定线程组父子关系的时机：构造函数&lt;/h1>
&lt;p>&lt;code>ThreadGroup&lt;/code>提供了4个构造函数(其中2个是&lt;code>public&lt;/code>类型以供程序猿调用)，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524090234413.png" alt="image-20230524090234413">&lt;/p>
&lt;p>这4个构造函数的调用链关系如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524094642711.png" alt="image-20230524094642711">&lt;/p>
&lt;p>我们接下来逐一分析它们的源码。&lt;/p>
&lt;h2 id="21threadgroup">2.1.ThreadGroup()&lt;/h2>
&lt;p>分析第1个无参构造函数，可知：&lt;/p>
&lt;ul>
&lt;li>它仅被JVM调用&lt;/li>
&lt;li>它创建名为&lt;code>system&lt;/code>的线程组&lt;/li>
&lt;li>它的父线程组为&lt;code>null&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524090656391.png" alt="image-20230524090656391">&lt;/p>
&lt;h2 id="22threadgroupstring-name">2.2.ThreadGroup(String name)&lt;/h2>
&lt;p>分析第2个构造函数，可知：&lt;/p>
&lt;ul>
&lt;li>它调用了第3个构造函数&lt;/li>
&lt;li>它获取了当前线程所在的线程组，作为自己的父线程组&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524091312700.png" alt="image-20230524091312700">&lt;/p>
&lt;h2 id="23threadgroupthreadgroup-parent-string-name">2.3.ThreadGroup(ThreadGroup parent, String name)&lt;/h2>
&lt;p>分析第3个构造函数，可知：&lt;/p>
&lt;ul>
&lt;li>它调用了第3个构造函数&lt;/li>
&lt;li>它调用了&lt;code>checkParentAccess&lt;/code>方法，检查了父线程组&lt;code>parent&lt;/code>的权限&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524091449229.png" alt="image-20230524091449229">&lt;/p>
&lt;h2 id="24threadgroupvoid-unused-threadgroup-parent-string-name">2.4.ThreadGroup(Void unused, ThreadGroup parent, String name)&lt;/h2>
&lt;p>分析第4个构造函数，可知：&lt;/p>
&lt;ul>
&lt;li>在这个构造函数中，调用&lt;code>add&lt;/code>方法，将传入的线程组对象设置为父线程组。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524091708771.png" alt="image-20230524091708771">&lt;/p>
&lt;h2 id="25addthreadgroup-g">2.5.add(ThreadGroup g)&lt;/h2>
&lt;p>此方法就是构建线程组父子关系的关键代码：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>813行：当前线程组对象的子线程组集合为空，则创建长度为4的子线程组集合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>815行：如果当前线程组对象的子线程组集合长度已经满了，则将子线程组集合扩容为2倍&lt;/p>
&lt;ul>
&lt;li>注：JDK源码中有很多扩容代码，在空间和时间上进行性能平衡，值得学习&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>817行：将传入的线程组g，加入到当前线程组对象的子线程组集合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>821行：将子线程组集合的游标增1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524094843439.png" alt="image-20230524094843439">&lt;/p>
&lt;h2 id="26测试">2.6.测试&lt;/h2>
&lt;p>我们可以写一段测试代码：&lt;/p>
&lt;ul>
&lt;li>我们借助&lt;code>getParent()&lt;/code>方法，获得指定线程组的父线程组&lt;/li>
&lt;li>我们借助&lt;code>list()&lt;/code>方法，打印当前进程中的线程组的树状结构&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524093324551.png" alt="image-20230524093324551">&lt;/p>
&lt;p>上述代码的控制台输出如下：&lt;/p>
&lt;ul>
&lt;li>上述代码就形成了1个线程组树：&lt;code>system线程组&lt;/code>&amp;gt;&lt;code>main线程组&lt;/code>&amp;gt;&lt;code>线程组1&lt;/code>&amp;gt;&lt;code>线程组2&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524093905263.png" alt="image-20230524093905263">&lt;/p>
&lt;h1 id="3决定线程父子关系的时机add">3.决定线程父子关系的时机：add&lt;/h1>
&lt;h2 id="31触发">3.1.触发&lt;/h2>
&lt;ul>
&lt;li>&lt;code>Thread.start()&lt;/code>方法会调用&lt;code>ThreadGroup.add(Thread t)&lt;/code>方法，目的是将该线程加入对应线程组的子线程组集合&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524100028755.png" alt="image-20230524100028755">&lt;/p>
&lt;h2 id="32threadgroupaddthread-t">3.2.ThreadGroup.add(Thread t)&lt;/h2>
&lt;p>此方法就是构建线程和线程组父子关系的关键代码：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>892行：当前线程组对象的子线程集合为空，则创建长度为4的子线程集合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>894行：如果当前线程组对象的子线程集合长度已经满了，则将子线程集合扩容为2倍&lt;/p>
&lt;/li>
&lt;li>
&lt;p>896行：将传入的线程t，加入到当前线程组对象的子线程集合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>900行：将子线程集合的游标增1&lt;/p>
&lt;/li>
&lt;li>
&lt;p>906行：将未启动的线程数减1&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524100637548.png" alt="image-20230524100637548">&lt;/p>
&lt;h2 id="33测试">3.3.测试&lt;/h2>
&lt;p>我们的测试代码如下：&lt;/p>
&lt;ul>
&lt;li>创建3个线程：线程1、线程2、线程3&lt;/li>
&lt;li>线程1：未指定线程组，&lt;code>Thread&lt;/code>的构造函数会找当前线程对象的父线程对象所属的线程组，指定线程1要加入到该线程组
&lt;ul>
&lt;li>注：此处不展开，读者可通过&lt;code>Thread&lt;/code>构造函数自行分析&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>线程2：指定线程2要加入到线程组1&lt;/li>
&lt;li>线程3：指定线程3要加入到线程组2&lt;/li>
&lt;li>start：线程1、线程2、线程3启动，触发了3个线程真正地加入到对应的线程组&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524101258085.png" alt="image-20230524101258085">&lt;/p>
&lt;p>上述代码的控制台输出如下：&lt;/p>
&lt;ul>
&lt;li>上述代码就形成了1个线程组和线程的树状结构：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524102208868.png" alt="image-20230524102208868">&lt;/p>
&lt;h1 id="4完整测试代码">4.完整测试代码&lt;/h1>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Main&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ThreadGroup&lt;/span> &lt;span class="n">threadGroup1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadGroup&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;线程组1&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">ThreadGroup&lt;/span> &lt;span class="n">threadGroup2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">ThreadGroup&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroup1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;线程组2&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Thread&lt;/span> &lt;span class="n">thread1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;...&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">},&lt;/span> &lt;span class="s">&amp;#34;线程1&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Thread&lt;/span> &lt;span class="n">thread2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroup1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;...&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">},&lt;/span> &lt;span class="s">&amp;#34;线程2&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">Thread&lt;/span> &lt;span class="n">thread3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroup2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;...&amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentThread&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">TimeUnit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">SECONDS&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">sleep&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">RuntimeException&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">},&lt;/span> &lt;span class="s">&amp;#34;线程3&amp;#34;&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">thread1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">thread2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">thread3&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="c1">// getParent/parentOf
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ThreadGroup&lt;/span> &lt;span class="n">threadGroupMain&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadGroup1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroupMain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getName&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroupMain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">parentOf&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroup1&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="c1">// activeCount/activeGroupCount
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroup1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">activeCount&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">threadGroup1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">activeGroupCount&lt;/span>&lt;span class="o">());&lt;/span>
&lt;span class="c1">// list
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">ThreadGroup&lt;/span> &lt;span class="n">threadGroupSystem&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">threadGroupMain&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getParent&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">threadGroupSystem&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">list&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="5参考">5.参考&lt;/h1>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">java/lang/ThreadGroup.java
java/lang/Thread.java
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-8/image-20230524104931008.png" alt="image-20230524104931008">&lt;/p></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-7</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-7/</link><pubDate>Sat, 22 Apr 2023 01:10:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-7/</guid><description>&lt;h1 id="1实验模拟java线程状态迁移过程">1.实验：模拟Java线程状态迁移过程&lt;/h1>
&lt;p>在《【运行时数据区】-并发编程-前置知识(4.并发编程基础)-6》中，我们分析了Java线程从JDK层面到JVM层面的状态迁移：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230414070017806.png" alt="image-20230414070017806">&lt;/p>
&lt;p>本文我们来尝试自己实现Java线程的状态迁移过程，进一步加深对这个状态迁移过程的理解。&lt;/p>
&lt;h1 id="2简化jvm调用链">2.简化：JVM调用链&lt;/h1>
&lt;ul>
&lt;li>如下是JVM调用链：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230414064052581.png" alt="image-20230414064052581">&lt;/p>
&lt;ul>
&lt;li>我们简化调用链如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422145647662.png" alt="image-20230422145647662">&lt;/p>
&lt;h1 id="3模拟1jvm注册jni接口">3.模拟1：JVM注册JNI接口&lt;/h1>
&lt;ul>
&lt;li>如红框处，我们通过&lt;code>System.load&lt;/code>方法，加载提供了JNI接口的动态库&lt;code>lib.so&lt;/code>文件。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422135359625.png" alt="image-20230422135359625">&lt;/p>
&lt;h1 id="4模拟2启动java线程">4.模拟2：启动Java线程&lt;/h1>
&lt;p>如下图：&lt;/p>
&lt;ul>
&lt;li>&lt;code>start()&lt;/code>方法模拟JDK的&lt;code>Thread.start()&lt;/code>方法，该方法调用了&lt;code>start0()&lt;/code>方法。&lt;/li>
&lt;li>&lt;code>start0()&lt;/code>方法模拟JDK的&lt;code>Thread.start0()&lt;/code>方法，该方法为JNI接口。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422135522197.png" alt="image-20230422135522197">&lt;/p>
&lt;ul>
&lt;li>通过&lt;code>javah&lt;/code>，我们生成了&lt;code>start0()&lt;/code>方法对应的C++头文件。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422135555599.png" alt="image-20230422135555599">&lt;/p>
&lt;h1 id="6模拟3创建native线程">6.模拟3：创建native线程&lt;/h1>
&lt;ul>
&lt;li>在&lt;code>start0()&lt;/code>方法的实现中，我们调用了&lt;code>pthread_create()&lt;/code>方法，创建native线程。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422135727912.png" alt="image-20230422135727912">&lt;/p>
&lt;h1 id="7模拟4等待">7.模拟4：等待&lt;/h1>
&lt;ul>
&lt;li>当CPU调度上一步我们创建的native线程，进入该线程的回调函数&lt;code>java_start()&lt;/code>。&lt;/li>
&lt;li>我们创建了标志位&lt;code>flag&lt;/code>，它用于模拟JVM中记录native线程一系列状态的标志位，初始值为0，表示native线程处于&lt;code>INITIALIZED&lt;/code>状态。&lt;/li>
&lt;li>while循环导致native线程一直处于等待状态。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422135917734.png" alt="image-20230422135917734">&lt;/p>
&lt;h1 id="8模拟5打破循环">8.模拟5：打破循环&lt;/h1>
&lt;ul>
&lt;li>回到&lt;code>start0&lt;/code>方法的实现，通过sleep了一段时间后修改&lt;code>flag&lt;/code>标志位，模拟JVM中经过一系列准备工作，将native线程设置为&lt;code>RUNNABLE状态&lt;/code>。&lt;/li>
&lt;li>此时，native线程在&lt;code>java_start()&lt;/code>中处于循环等待的状态被打破。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422135949723.png" alt="image-20230422135949723">&lt;/p>
&lt;h1 id="9模拟6回调jdk">9.模拟6：回调JDK&lt;/h1>
&lt;ul>
&lt;li>当native线程在&lt;code>java_start()&lt;/code>中处于循环等待的状态被打破后，通过JNI获得Java侧的Test对象，进一步回调Java侧Test对象的&lt;code>run()&lt;/code>方法。&lt;/li>
&lt;li>这一步，就模拟了JVM在native线程变为&lt;code>RUNNABLE&lt;/code>状态后回调JDK的&lt;code>Thread.run()&lt;/code>方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422140058781.png" alt="image-20230422140058781">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422140113451.png" alt="image-20230422140113451">&lt;/p>
&lt;h1 id="10运行效果">10.运行效果&lt;/h1>
&lt;ul>
&lt;li>运行我们的模拟程序，打印结果如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422140522662.png" alt="image-20230422140522662">&lt;/p>
&lt;ul>
&lt;li>本次实验，最终模拟了JDK中创建Java线程，JVM中对应也创建native线程，native线程的状态迁移后回调Java线程的回调函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-7/image-20230422153048716.png" alt="image-20230422153048716">&lt;/p></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-6</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-6/</link><pubDate>Sat, 15 Apr 2023 01:10:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-6/</guid><description>&lt;h1 id="1疑问java线程对应的native线程状态如何迁移">1.疑问：Java线程对应的native线程状态如何迁移？&lt;/h1>
&lt;p>在《【运行时数据区】-并发编程-前置知识(4.并发编程基础)-5》中，我们在JDK层面对Java线程的6种状态迁移进行了实验。&lt;/p>
&lt;p>本文再以Java线程从NEW状态迁移到RUNNABLE状态为引子，观测一下JVM为Java线程创建的native线程的状态如何迁移：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230413160245714.png" alt="">&lt;/p>
&lt;h1 id="2探索jvm调用链全景图">2.探索：JVM调用链全景图&lt;/h1>
&lt;p>为了避免迷失在JVM的源码中，我们先看一下笔者整理的JVM调用链全景：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>STEP1.JVM准备&lt;/strong>：JDK通过JNI，加载JVM侧的相关函数。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JDK：Thread.java的registerNatives()
(2)JVM：jdk/src/share/native/java/lang/Thread.c的registerNatives()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>STEP2.启动Java线程&lt;/strong>：JDK侧启动线程，JVM侧进行初始化。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JDK：Thread.java的start()
(2)JVM：src/share/vm/prims/jvm.cpp的JVM_StartThread()
(3)JVM：src/share/vm/runtime/thread.cpp的JavaThread()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>STEP3.记录JDK回调&lt;/strong>：JVM侧记录JDK侧的Java线程回调函数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JVM：src/share/vm/runtime/thread.hpp的set_entry_point()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>STEP4.创建native线程&lt;/strong>：JVM侧创建native线程，初始化后等待CPU执行这个native线程&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JVM：src/os/linux/vm/os_linux.cpp的create_thread()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>STEP5.等待&lt;/strong>：CPU执行native线程，JVM阻塞，等待native线程进入RUNNABLE状态&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JVM：src/os/linux/vm/os_linux.cpp的java_start()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>STEP6.打破循环&lt;/strong>：JVM在STEP4后，做了其它操作，最终设置native线程、Java线程为RUNNABLE状态，打破STEP5等待&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JVM：src/share/vm/prims/jvm.cpp的JVM_StartThread()
(2)JVM：src/share/vm/runtime/thread.cpp的start()
(3)JVM：src/share/vm/runtime/os.cpp的start_thread()
(4)JVM：src/os/linux/vm/os_linux.cpp的pd_start_thread()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>STEP7.回调JDK&lt;/strong>：JVM通过JNI回调JDK侧的Java线程回调&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">涉及代码：
(1)JVM：src/share/vm/runtime/thread.cpp的run()
(2)JVM：src/share/vm/runtime/thread.cpp的thread_main_inner()
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064052581.png" alt="">&lt;/p>
&lt;h1 id="3细节1jvm准备">3.细节1：JVM准备&lt;/h1>
&lt;p>第一步，看JVM如何将&lt;code>java.lang.Thread&lt;/code>中用到的native方法批量注册的：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414060903544.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在JDK中，&lt;code>java.lang.Thread&lt;/code>在静态代码块中调用了&lt;code>registerNatives&lt;/code>。此方法为native方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061036368.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在JVM中，java/lang/Thread.c定义了JNI方法&lt;code>Java_java_lang_Thread_registerNatives&lt;/code>。此方法使用了&lt;code>methods&lt;/code>变量，此变量定义了&lt;code>java.lang.Thread&lt;/code>类中所有的native方法对应的函数指针。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061109828.png" alt="">&lt;/p>
&lt;h1 id="4细节2启动java线程">4.细节2：启动Java线程&lt;/h1>
&lt;p>第二步，理解&lt;code>java.lang.Thread&lt;/code>调用&lt;code>start&lt;/code>方法时，JVM对应的处理：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061547200.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>java.lang.Thread&lt;/code>的&lt;code>start&lt;/code>方法核心是调用了native方法&lt;code>start0&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061148420.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在JVM中，native的&lt;code>start0&lt;/code>方法对应的实现为&lt;code>JVM_StartThread&lt;/code>函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061324005.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>JVM_StartThread&lt;/code>方法核心是创建了&lt;code>JavaThread&lt;/code>对象。此对象是JVM中表示Java线程对象的抽象。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061356033.png" alt="">&lt;/p>
&lt;h1 id="5细节3记录jdk回调">5.细节3：记录JDK回调&lt;/h1>
&lt;p>第三步，理解JVM如何记录Java线程的回调：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061824024.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在JVM中，thread.cpp中定义了&lt;code>JavaThread&lt;/code>的构造函数，第一个参数&lt;code>entry_point&lt;/code>就表示Java线程的回调函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061653606.png" alt="">&lt;/p>
&lt;ul>
&lt;li>thread.hpp提供了&lt;code>set_entry_point&lt;/code>函数，&lt;code>JavaThread&lt;/code>的构造函数调用此函数，将Java线程的回调记录到内存中，供后续流程调用。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061709047.png" alt="">&lt;/p>
&lt;h1 id="6细节4创建native线程">6.细节4：创建native线程&lt;/h1>
&lt;p>第四步，在JVM做好一切准备工作后，JVM如何在操作系统上创建native线程：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064223932.png" alt="">&lt;/p>
&lt;ul>
&lt;li>JVM的&lt;code>thread.cpp&lt;/code>在&lt;code>JavaThread&lt;/code>的构造函数中调用&lt;code>os_linux.cpp&lt;/code>的&lt;code>create_thread&lt;/code>函数。&lt;/li>
&lt;li>&lt;code>create_thread&lt;/code>函数创建了&lt;code>OSThread&lt;/code>对象，此对象记录了&lt;code>JavaThread&lt;/code>和即将创建的&lt;code>native线程&lt;/code>之间的一一对应关系。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061900504.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在建立了&lt;code>JavaThread&lt;/code>对象和&lt;code>native线程对象&lt;/code>后，JVM就调用&lt;code>pthread&lt;/code>库的&lt;code>pthread_create&lt;/code>方法，在操作系统上创建了真正的&lt;code>native线程&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061913975.png" alt="">&lt;/p>
&lt;ul>
&lt;li>到这里，JDK中的Java线程仍然处于&lt;code>NEW&lt;/code>状态，而JVM中的&lt;code>native线程&lt;/code>在一段时间内处于&lt;code>ALLOCATED&lt;/code>状态，JVM一直会等待&lt;code>native线程&lt;/code>突破这个状态。并且，当&lt;code>pthread&lt;/code>库在操作系统层创建&lt;code>native线程&lt;/code>出现问题时，&lt;code>native线程&lt;/code>处于&lt;code>ZOMBIE&lt;/code>状态。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414061932717.png" alt="">&lt;/p>
&lt;h1 id="7细节5等待">7.细节5：等待&lt;/h1>
&lt;p>第五步，在操作系统层面已经存在了和JDK的Java线程一一对应的&lt;code>native线程&lt;/code>，那么我们就要来理解在CPU下一个可能的时间周期中是如何执行的&lt;code>native线程&lt;/code>的回调。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064342579.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>os_linux.cpp&lt;/code>的&lt;code>java_start&lt;/code>函数是&lt;code>native线程&lt;/code>的回调函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064407101.png" alt="">&lt;/p>
&lt;ul>
&lt;li>这个函数的结束处，&lt;code>native线程&lt;/code>的状态一直处于&lt;code>INITIALIZED&lt;/code>状态，这个状态就对应Java线程的&lt;code>NEW&lt;/code>状态。此时，&lt;code>native线程&lt;/code>阻塞。&lt;/li>
&lt;li>当&lt;code>native线程&lt;/code>被打破了&lt;code>INITIALIZED&lt;/code>状态，&lt;code>native线程&lt;/code>不再原地止步，而是进一步执行&lt;code>thread.cpp&lt;/code>的&lt;code>run&lt;/code>方法。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064418955.png" alt="">&lt;/p>
&lt;h1 id="8细节6打破循环">8.细节6：打破循环&lt;/h1>
&lt;p>第六步，我们再来理解JVM如何打破上一步&lt;code>native线程&lt;/code>止步不前的状态。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414065410715.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在&lt;code>jvm.cpp&lt;/code>的JVM_StartThread方法在创建了&lt;code>JavaThread&lt;/code>对象后，调用了&lt;code>thread.cpp&lt;/code>的&lt;code>start&lt;/code>函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414065209484.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>thread.cpp&lt;/code>的&lt;code>start&lt;/code>方法将&lt;code>JavaThread&lt;/code>对象设置为&lt;code>RUNNABLE&lt;/code>状态，此时JDK对应的Java线程处于&lt;code>RUNNABLE&lt;/code>状态。&lt;/li>
&lt;li>&lt;code>thread.cpp&lt;/code>调用&lt;code>os.cpp&lt;/code>的&lt;code>start_thread&lt;/code>函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414065229125.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>os.cpp&lt;/code>的&lt;code>start_thread&lt;/code>函数将&lt;code>native线程&lt;/code>也设置为&lt;code>RUNNABLE&lt;/code>状态，此时Java线程和&lt;code>native线程&lt;/code>都处于&lt;code>RUNNABLE&lt;/code>状态。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414065247151.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>os.cpp&lt;/code>的&lt;code>start_thread&lt;/code>函数进一步调用&lt;code>os_linux.cpp&lt;/code>的&lt;code>pd_start_thread&lt;/code>函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414065304780.png" alt="">&lt;/p>
&lt;h1 id="9细节7回调jdk">9.细节7：回调JDK&lt;/h1>
&lt;p>第七步，在第六步打破了&lt;code>native线程&lt;/code>止步不前的状态后，&lt;code>native线程&lt;/code>调用&lt;code>thread.cpp&lt;/code>的&lt;code>thread_main_inner&lt;/code>函数。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064752160.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>native线程&lt;/code>调用&lt;code>thread.cpp&lt;/code>的&lt;code>thread_main_inner&lt;/code>函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064845782.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064858699.png" alt="">&lt;/p>
&lt;ul>
&lt;li>&lt;code>thread.cpp&lt;/code>的&lt;code>thread_main_inner&lt;/code>函数中，进一步调用了在第三步中保存的Java线程的回调&lt;code>entry_point&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064911172.png" alt="">&lt;/p>
&lt;ul>
&lt;li>在&lt;code>jvm.cpp&lt;/code>中，&lt;code>thread_entry&lt;/code>函数调用了&lt;code>JavaCalls::call_virtual&lt;/code>函数，这个函数会通过JNI反向调用JDK中的Java代码，此处就是回调了JDK中的Java线程回调函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414064925823.png" alt="">&lt;/p>
&lt;h1 id="10结论">10.结论&lt;/h1>
&lt;p>通过前述代码流程的分析，我们可以得到如下结论：&lt;/p>
&lt;ul>
&lt;li>JDK中，&lt;code>new java.lang.Thread()&lt;/code>会创建Java线程，此时Java线程处于&lt;code>NEW&lt;/code>状态。&lt;/li>
&lt;li>JDK中，调用Java线程的&lt;code>start&lt;/code>方法后，在JVM中创建&lt;code>native线程&lt;/code>&lt;/li>
&lt;li>JVM中，&lt;code>native线程&lt;/code>先后经历&lt;code>ALLOCATED&lt;/code>状态，也可能出现&lt;code>ZOMBIE&lt;/code>状态。&lt;/li>
&lt;li>JVM中，&lt;code>native线程&lt;/code>进化为&lt;code>INITIALIZED&lt;/code>状态，可以对标JDK中Java线程的&lt;code>NEW&lt;/code>状态。&lt;/li>
&lt;li>JVM中，&lt;code>native线程&lt;/code>被打破等待循环后，&lt;code>native线程&lt;/code>变迁为&lt;code>RUNNABLE&lt;/code>状态。&lt;/li>
&lt;li>JDK中，&lt;code>Java线程&lt;/code>也变迁为&lt;code>RUNNABLE&lt;/code>状态，&lt;code>Java线程&lt;/code>的回调函数也被JVM调用执行。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230414070017806.png" alt="">&lt;/p>
&lt;h1 id="11随想">11.随想&lt;/h1>
&lt;p>每次分析JVM源码，仿佛在一个生活在三维空间的生物(Java程序猿)，窥探到四维空间(JVM、操作系统、CPU&amp;hellip;&amp;hellip;)，这种感觉令人自在、平静、喜乐。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-6/image-20230415010840596.png" alt="">&lt;/p></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-5</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-5/</link><pubDate>Wed, 05 Apr 2023 09:07:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-5/</guid><description>&lt;h1 id="1疑惑java的线程究竟有几种状态">1.疑惑：Java的线程究竟有几种状态？&lt;/h1>
&lt;p>在Java的并发编程技术中，经常会看到Java线程的状态迁移图。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>有的这样画&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230330130053911.png" alt="image-20230330130053911">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>有的这样画&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230330130208531.png" alt="image-20230330130208531">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>有的这样画：&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230330130240613.png" alt="image-20230330130240613">&lt;/p>
&lt;p>笔者刚接触Java时，看到形形色色的文章和图例，比较大的困扰是&lt;strong>Java的线程究竟有几种状态&lt;/strong>？&lt;/p>
&lt;h1 id="2探索1官方文档">2.探索1：官方文档&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>在Java8，Thread的状态定义在&lt;code>java.lang.Thread.State&lt;/code>中。&lt;strong>Java线程的状态有6种&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NEW&lt;/strong>&lt;/li>
&lt;li>&lt;strong>RUNNABLE&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BLOCKED&lt;/strong>&lt;/li>
&lt;li>&lt;strong>WATING&lt;/strong>&lt;/li>
&lt;li>&lt;strong>TIMED_WAITING&lt;/strong>&lt;/li>
&lt;li>&lt;strong>TERMINATED&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>详见：https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.State.html&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230330130905543.png" alt="image-20230330130905543">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在Java20&lt;/strong>(Java最新版本)，Thread的状态定义在&lt;code>java.lang.Thread.State&lt;/code>中**。Java线程的状态依然是6种**。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>详见：https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/lang/Thread.State.html&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>结论：从官方文档中看，Java线程的状态为6种&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>NEW&lt;/strong>&lt;/li>
&lt;li>&lt;strong>RUNNABLE&lt;/strong>&lt;/li>
&lt;li>&lt;strong>BLOCKED&lt;/strong>&lt;/li>
&lt;li>&lt;strong>WATING&lt;/strong>&lt;/li>
&lt;li>&lt;strong>TIMED_WAITING&lt;/strong>&lt;/li>
&lt;li>&lt;strong>TERMINATED&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="3探索2jdk源码">3.探索2：JDK源码&lt;/h1>
&lt;ul>
&lt;li>在Java8中，Java线程状态位于&lt;code>java/lang/Thread.java&lt;/code>的&lt;code>State&lt;/code>枚举类：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="C:%5CUsers%5CJHercules2%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230331111439960.png" alt="image-20230331111439960">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NEW&lt;/strong>：当Java线程处于此状态时，创建线程那一刻，线程的状态。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405132055300.png" alt="image-20230405132055300">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>RUNNABLE&lt;/strong>：当Java线程处于此状态时，JVM&lt;strong>有可能&lt;/strong>去执行它(此处埋有伏笔)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405132344766.png" alt="image-20230405132344766">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>BLOCKED&lt;/strong>：此状态，与&lt;code>synchronized&lt;/code>、&lt;code>Object.wait&lt;/code>强相关(后文代码演示)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405133442702.png" alt="image-20230405133442702">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>WAITING&lt;/strong>：此状态与&lt;code>BLOCKED&lt;/code>一样，与&lt;code>Object.wait&lt;/code>、&lt;code>Thread.join&lt;/code>等相关(后文代码演示)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405133702393.png" alt="image-20230405133702393">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TIMED_WAITING&lt;/strong>：与&lt;code>WAITING&lt;/code>类似的一种状态，与&lt;code>Thread.sleep&lt;/code>、&lt;code>Object.wait&lt;/code>、&lt;code>Thread.join&lt;/code>等有关(后文代码演示)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405134328837.png" alt="image-20230405134328837">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>TERMINATED&lt;/strong>：终结态，没啥好说的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405134725161.png" alt="image-20230405134725161">&lt;/p>
&lt;h1 id="4思考为什么对java线程的状态描述不同">4.思考：为什么对Java线程的状态描述不同?&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>无论从官方文档，还是JDK源码，都很容易看到Java线程只有6种状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>那么，为什么各种资料中对Java线程的状态描述不同呢？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>我认为，可能是视角不同：&lt;/p>
&lt;ul>
&lt;li>笔者在之前的文章中，分析过JVM启动时会产生多少线程，即我们到底在操作系统层面看线程，还是在JVM层面看线程。&lt;/li>
&lt;li>站在JVM层面，Java给Java程序猿看到&lt;code>创建Java线程&lt;/code>、&lt;code>Java线程有6种状态&lt;/code>等等概念。&lt;/li>
&lt;li>站在OS层面，JVM为了实现Java程序猿看到的&lt;code>Java线程&lt;/code>，调用了&lt;code>pthread&lt;/code>这类库，创建了OS层面的线程，OS层面的线程有一系列状态，此状态与&lt;code>Java线程的6种状态&lt;/code>存在映射关系(本文不展开，下一篇笔者对照JVM源码详述)。&lt;/li>
&lt;li>因此，有的资料中试图同时表达JVM层面和OS层面的线程状态，就造成了描述不同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>结论：我们应该从JVM层面和OS层面分别理解&lt;code>Java线程状态&lt;/code>，以及透彻理解两个层面的&lt;code>线程&lt;/code>的对应关系&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405140832691.png" alt="image-20230405140832691">&lt;/p>
&lt;h1 id="5深入java线程的状态如何迁移">5.深入：Java线程的状态如何迁移?&lt;/h1>
&lt;p>JDK源码中，对Java线程的状态迁移有明确地描述。但为了深入理解，我们有必要写一些示例代码，强化理解。&lt;/p>
&lt;blockquote>
&lt;p>PS：实战中，很多问题就源于我们并不是真的理解这些状态迁移条件。&lt;/p>
&lt;/blockquote>
&lt;h2 id="51newrunnabletime_waiting三态迁移">5.1.NEW、RUNNABLE、TIME_WAITING三态迁移&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>结论&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>new Thread&lt;/code>时，Java线程进入&lt;code>NEW&lt;/code>状态&lt;/li>
&lt;li>调用&lt;code>start&lt;/code>方法时，Java线程进入&lt;code>RUNNABLE&lt;/code>状态&lt;/li>
&lt;li>Java线程运行&lt;code>run&lt;/code>方法体内一旦运行&lt;code>Thread.sleep&lt;/code>方法，Java线程进入&lt;code>TIME_WAITING&lt;/code>状态&lt;/li>
&lt;li>当&lt;code>Thread.sleep&lt;/code>时间到，Java线程回到&lt;code>RUNNABLE&lt;/code>状态&lt;/li>
&lt;li>其它说明：&lt;code>Object.wait&lt;/code>、&lt;code>Thread.join&lt;/code>等方法也可以触发&lt;code>RUNNABLE&lt;/code>态迁移到&lt;code>TIME_WAITING&lt;/code>态，读者可自行实验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405142942728.png" alt="image-20230405142942728">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>示例代码&lt;/strong>：
&lt;ul>
&lt;li>第21行在&lt;code>MyThread&lt;/code>构造函数中打印了线程状态、第9行在&lt;code>new MyThread&lt;/code>后也打印了线程状态，目的是从这两处打印证明&lt;code>new Thread&lt;/code>那一刻，Java线程处于&lt;code>NEW&lt;/code>状态。&lt;/li>
&lt;li>第26行打印线程状态，为了证明第11行调用&lt;code>start&lt;/code>方法后，Java线程进入&lt;code>RUNNABLE&lt;/code>状态。&lt;/li>
&lt;li>第27~第31行调用&lt;code>Thread.sleep&lt;/code>方法后，在第13~15行连续打印3次线程状态，为了证明调用&lt;code>Thread.sleep&lt;/code>方法后，Java线程进入&lt;code>TIME_WAITING&lt;/code>状态。&lt;/li>
&lt;li>第32行打印线程状态，为了证明&lt;code>Thread.sleep&lt;/code>方法时间到后，Java线程回到&lt;code>RUNNABLE&lt;/code>状态。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405144125704.png" alt="image-20230405144125704">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>示例代码运行结果&lt;/strong>：与预期一致。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405144303047.png" alt="image-20230405144303047">&lt;/p>
&lt;h2 id="52newrunnablewaitingblockedterminated五态迁移">5.2.NEW、RUNNABLE、WAITING、BLOCKED、TERMINATED五态迁移&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>结论&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>new Thread&lt;/code>时，Java线程进入&lt;code>NEW&lt;/code>状态&lt;/li>
&lt;li>调用&lt;code>start&lt;/code>方法时，Java线程进入&lt;code>RUNNABLE&lt;/code>状态&lt;/li>
&lt;li>Java线程运行&lt;code>run&lt;/code>方法体内一旦运行&lt;code>Object.wait&lt;/code>方法，Java线程进入&lt;code>WAITING&lt;/code>状态&lt;/li>
&lt;li>当另一个Java线程执行了&lt;code>Object.notify&lt;/code>方法，Java线程进入&lt;code>RUNNABLE&lt;/code>状态&lt;/li>
&lt;li>在Java线程从占有对象锁到失去对象锁到再次获得对象锁，即等待&lt;code>synchronized&lt;/code>到重入&lt;code>synchronized&lt;/code>块，Java线程还会经历&lt;code>BLOCKED&lt;/code>态到&lt;code>RUNNABLE&lt;/code>态的迁移(此处也有一处伏笔，需要解读JVM源码才能清晰，下篇文章详述)&lt;/li>
&lt;li>当Java线程执行完，Java线程进入&lt;code>TERMINATED&lt;/code>状态&lt;/li>
&lt;li>其它说明：&lt;code>Object.wait&lt;/code>、&lt;code>Thread.join&lt;/code>等方法五态迁移，读者可自行实验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405151245195.png" alt="image-20230405151245195">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>示例代码&lt;/strong>：
&lt;ul>
&lt;li>第15行为了证明&lt;code>Object.wait&lt;/code>后，Java线程进入&lt;code>WAITING&lt;/code>态&lt;/li>
&lt;li>第17行为了证明&lt;code>Object.notify&lt;/code>后，Java线程进入&lt;code>BLOCKED&lt;/code>态，再重入&lt;code>synchronized&lt;/code>后进入&lt;code>RUNNABLE&lt;/code>态&lt;/li>
&lt;li>第20行为了证明Java线程工作完成后，进入&lt;code>TERMINATED&lt;/code>态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405152223300.png" alt="image-20230405152223300">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>示例代码运行结果&lt;/strong>：与预期一致。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-5/image-20230405152517526.png" alt="image-20230405152517526">&lt;/p>
&lt;h1 id="6总结">6.总结&lt;/h1>
&lt;ul>
&lt;li>本文通过Java官方文档和JDK源码，解读了Java线程有6种状态&lt;/li>
&lt;li>本文又通过两段示例代码，验证了Java线程6种状态的迁移路径&lt;/li>
&lt;li>本文遗留了一个模糊的问题：Java线程在重入&lt;code>synchronized&lt;/code>时如何迁移到&lt;code>BLOCKED&lt;/code>态？此问题需要分析JVM源码得到进一步验证结论&lt;/li>
&lt;/ul></description></item><item><title>【音乐】陈升-牡丹亭外</title><link>https://jherculesqz.github.io/post/%E6%9D%82%E8%B4%A7%E9%93%BA/%E9%9F%B3%E4%B9%90%E9%99%88%E5%8D%87-%E7%89%A1%E4%B8%B9%E4%BA%AD%E5%A4%96/</link><pubDate>Mon, 27 Feb 2023 00:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/%E6%9D%82%E8%B4%A7%E9%93%BA/%E9%9F%B3%E4%B9%90%E9%99%88%E5%8D%87-%E7%89%A1%E4%B8%B9%E4%BA%AD%E5%A4%96/</guid><description>&lt;center>&lt;font size=20>牡丹亭外&lt;/font>&lt;/center>
&lt;p align="right">陈升&lt;/p>
&lt;center>為救李郎離家園，誰料皇榜中狀元&lt;/center>
&lt;center>中狀元，著紅袍，帽插宮花好啊，好新鮮&lt;/center>
&lt;center>李郎一夢已過往，風流人兒如今在何方&lt;/center>
&lt;center>從古到今呀說來慌，不過是情而已&lt;/center>
&lt;center>這人間苦什麼，怕不能遇見你&lt;/center>
&lt;center>是否你走過了我身邊，恍恍惑惑一瞬間&lt;/center>
&lt;center>黃粱一夢二十年，依舊是不懂愛也不懂情&lt;/center>
&lt;center>寫歌的人假正經，聽歌的人最無情&lt;/center>
&lt;center>牡丹亭外雨紛紛，誰是歸人說不準&lt;/center>
&lt;center>是歸人啊，你說分明，你把我心放哪兒&lt;/center>
&lt;center>黃粱一夢二十年啊，依舊是不懂愛也不懂情&lt;/center>
&lt;center>寫歌的人假正經，聽歌的人最無情&lt;/center>
&lt;center>牡丹亭外雨紛紛，誰是歸人說不準&lt;/center>
&lt;center>這人間苦什麼，怕不能遇見你&lt;/center>
&lt;center>是否你走過了我身邊，恍恍惑惑一瞬間&lt;/center>
&lt;center>黃粱一夢二十年，依舊是不懂愛也不懂情&lt;/center>
&lt;center>寫歌的人斷了魂，聽歌的人最無情&lt;/center>
&lt;center>為救李郎離家園，誰料皇榜中狀元&lt;/center>
&lt;center>中狀元，著紅袍，帽插宮花好啊，好新鮮&lt;/center>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90%E9%9F%B3%E4%B9%90%E3%80%91%E9%99%88%E5%8D%87-%E7%89%A1%E4%B8%B9%E4%BA%AD%E5%A4%96/image-20230227125824349.png" alt="image-20230227125824349">&lt;/p>
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/8msqXs6BuBI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>&lt;/iframe></description></item><item><title>【音乐】陈升-六月</title><link>https://jherculesqz.github.io/post/%E6%9D%82%E8%B4%A7%E9%93%BA/%E9%9F%B3%E4%B9%90%E9%99%88%E5%8D%87-%E5%85%AD%E6%9C%88/</link><pubDate>Sat, 25 Feb 2023 00:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/%E6%9D%82%E8%B4%A7%E9%93%BA/%E9%9F%B3%E4%B9%90%E9%99%88%E5%8D%87-%E5%85%AD%E6%9C%88/</guid><description>&lt;center>&lt;font size=20>六月&lt;/font>&lt;/center>
&lt;p align="right">陈升&lt;/p>
&lt;center>六月在夏天之前的心情，總是偶爾晴朗有點雨&lt;/center>
&lt;center>少女憂愁的情懷，自己跌倒就不許哭&lt;/center>
&lt;center>你猜猜六月單純的心中，藏著什麼樣的故事&lt;/center>
&lt;center>忘不了那個男孩，和他滿腮的鬍渣&lt;/center>
&lt;center>Ohoh，有些悲傷卻又不許哭&lt;/center>
&lt;center>Ohoh，有點孤單卻又不認輸&lt;/center>
&lt;center>雙魚座的女生，從來都不怪別人的錯&lt;/center>
&lt;center>六月在春天之後的心情，總是偶而悲傷有點苦&lt;/center>
&lt;center>往日的戀情，自己跌倒就不許哭&lt;/center>
&lt;center>她帶著甜甜的笑容，她說我是快樂的魚&lt;/center>
&lt;center>游在茫茫的人海，男孩你怎會明白&lt;/center>
&lt;center>Ohoh，有些悲傷卻又不許哭&lt;/center>
&lt;center>Ohoh，有點孤單卻又不認輸&lt;/center>
&lt;center>幻想型的女孩，從來都不怪別人的錯&lt;/center>
&lt;center>因為要記得你的模樣，六月在夏天又去了海邊&lt;/center>
&lt;center>只要你知道，愛上你有些難過&lt;/center>
&lt;center>是晴天，是雨天&lt;/center>
&lt;center>走不出愛情的人是呆子，不應該留著一樣的髮型&lt;/center>
&lt;center>只要你知道，離開後別來無恙&lt;/center>
&lt;center>捨不得，忘了他，誒&lt;/center>
&lt;center>Ohoh，想要躲在他的懷裡哭&lt;/center>
&lt;center>Ohoh，沒有他也真的不在乎&lt;/center>
&lt;center>幻想型的女孩，從來都不怪別人的錯&lt;/center>
&lt;center>因為要記得你的模樣，六月在夏天又去了海邊&lt;/center>
&lt;center>只要你知道，愛上你有些難過&lt;/center>
&lt;center>是晴天，是雨天&lt;/center>
&lt;center>走不出愛情的人是呆子，不應該留著一樣的髮型&lt;/center>
&lt;center>只要你知道，離開後別來無恙&lt;/center>
&lt;center>決定要，忘了他&lt;/center>
&lt;center>Ohoh，有些悲傷卻又不許哭&lt;/center>
&lt;center>Ohoh，有點孤單卻又不認輸&lt;/center>
&lt;center>Ohoh，想要躲在他的懷裡哭&lt;/center>
&lt;center>Ohoh，沒有他也真的不在乎&lt;/center>
&lt;center>Ohoh，有些悲傷卻又不許哭&lt;/center>
&lt;center>Ohoh，有點孤單卻又不認輸&lt;/center>
&lt;center>誒&lt;/center>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90%E9%9F%B3%E4%B9%90%E3%80%91%E9%99%88%E5%8D%87-%E5%85%AD%E6%9C%88/image-20230225143210137.png" alt="image-20230225143210137">&lt;/p>
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/X832EGf3i84" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>&lt;/iframe></description></item><item><title>【chatGPT】chatGPT学习笔记1-机器还需要多久才能像人一样思考？</title><link>https://jherculesqz.github.io/post/ai%E6%8B%BE%E9%81%97/chatgptchatgpt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/</link><pubDate>Fri, 24 Feb 2023 16:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/ai%E6%8B%BE%E9%81%97/chatgptchatgpt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/</guid><description>&lt;p>从深圳返程的路上，开始阅读chatGPT的论文，努力理解其中精妙的理论与公式。&lt;/p>
&lt;p>渴望真正理解chatGPT，所以写下我在学习过程中的思考，希望前辈高手指教。&lt;/p>
&lt;h1 id="1从宏观看">1.从宏观看&lt;/h1>
&lt;h2 id="11软件内驱力制约了目前的ai能力">1.1.软件内驱力，制约了目前的AI能力&lt;/h2>
&lt;h3 id="1非ai程序的特点">(1)非AI程序的特点&lt;/h3>
&lt;blockquote>
&lt;p>当&lt;strong>人类可以归纳&lt;/strong>出某种人类知识的&lt;strong>规则、规律&lt;/strong>时，程序员就可以把它做成软件。&lt;/p>
&lt;/blockquote>
&lt;p>比如：客户需要开发1个路由器产品，路由器遵循的TCP/IP协议就是人类对网络通信的归纳总结。在软件行业的黑话称之为**&amp;ldquo;需求&amp;rdquo;、&amp;ldquo;规格&amp;rdquo;**。&lt;/p>
&lt;p>将非AI的程序抽象成如下公式，&lt;strong>人类的工作重心就在函数f上&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>STEP1.归纳出函数f的&lt;strong>规则、规律&lt;/strong>&lt;/li>
&lt;li>STEP2.交给人类程序员用某种编程语言实现出来&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230221083651904.png" alt="image-20230221083651904">&lt;/p>
&lt;p>因此，产品研发过程中，某1个人类传递了错误的**&amp;ldquo;需求&amp;rdquo;、&amp;ldquo;规格&amp;rdquo;**，就会造成软件工程中经典的问题：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230220171408523.png" alt="image-20230220171408523">&lt;/p>
&lt;h3 id="2ai程序的特点">(2)AI程序的特点&lt;/h3>
&lt;blockquote>
&lt;p>当&lt;strong>人类无法归纳&lt;/strong>出某种人类知识的&lt;strong>规则、规律&lt;/strong>时，程序员实现某种数学工具的程序，该数学工具可以从已知的输入输出，自动归纳出规则、规律。&lt;/p>
&lt;/blockquote>
&lt;p>比如：我们需要实现计算机看一张照片，就知道这张照片里有一只狗。&lt;/p>
&lt;p>人类如何归纳出&amp;quot;照片里具备怎样的特征就表示有一只狗&amp;quot;的&lt;strong>规则、规律&lt;/strong>呢？&lt;/p>
&lt;p>暂且把看图识狗的问题放一边，我们换1个更简单的例子：已知历史上每天的白菜价格(假定白菜价格满足某种线性规律)，能否预测出明天的白菜价格？&lt;/p>
&lt;p>我们可以把问题抽象为如下数学问题：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI拾遗/【chatGPT】chatGPT学习笔记1-机器还需要多久才能像人一样思考/image-20230221092617276.png" alt="image-20230221092617276" style="zoom:50%;" />&lt;/p>
&lt;p>我们可以用最朴实的方法求解：&lt;/p>
&lt;ul>
&lt;li>STEP1.将p1、p2&amp;hellip;.pn在坐标系上描点&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230221093207025.png" alt="image-20230221093207025">&lt;/p>
&lt;ul>
&lt;li>STEP2.用蓝色线贯穿p1、p2&amp;hellip;.pn&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230221093633696.png" alt="image-20230221093633696">&lt;/p>
&lt;ul>
&lt;li>STEP3.这根蓝色线即可确定a、b，即确定了函数f是什么&lt;/li>
&lt;/ul>
&lt;p>这个函数f就是从历史上众多白菜价格中&lt;strong>归纳出来的规律、规则&lt;/strong>。&lt;/p>
&lt;p>将AI的程序抽象如下，&lt;strong>人类的工作重心在数学工具M上，而函数f由数学工具M自动/半自动产生&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230221094206072.png" alt="image-20230221094206072">&lt;/p>
&lt;h3 id="3观点">(3)观点&lt;/h3>
&lt;ul>
&lt;li>观点1：软件的内驱力是&lt;strong>具备归纳能力&lt;/strong>的&lt;strong>人脑&lt;/strong>或者&lt;strong>数学工具&lt;/strong>。
&lt;ul>
&lt;li>对比两种程序，非AI程序的归纳来源于人脑，AI程序的归纳来源于数学工具。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>观点2：如果期望&lt;strong>机器像人一样思考&lt;/strong>，则必须满足&lt;strong>数学工具的能力==人脑的能力&lt;/strong>。
&lt;ul>
&lt;li>非AI程序只能说是机器像人一样工作，而不是思考。&lt;/li>
&lt;li>AI程序中的数学工具的归纳能力和人脑持平，机器就真的像人一样思考了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>观点3：人脑作为创造了数学工具的&lt;strong>造物主&lt;/strong>，&lt;strong>有可能创造出等于甚至强于自身的数学工具&lt;/strong>吗？
&lt;ul>
&lt;li>这个问题和&amp;quot;万能的上帝能否造出自己举不动的石头？&amp;ldquo;是一样的，但未知的领域太大，未来或许可能。&lt;/li>
&lt;li>无论未来是否可能，目前看起来很难。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230221151409891.png" alt="image-20230221151409891">&lt;/p>
&lt;h2 id="12计算理论制约了ai解决问题的范围">1.2.计算理论，制约了AI解决问题的范围&lt;/h2>
&lt;h3 id="1观点">(1)观点&lt;/h3>
&lt;p>面对人类和AI，我的观点是：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>观点1：无论非AI程序，还是AI程序，最终&lt;strong>都是用来解决世间万物问题的&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>观点2：世间&lt;strong>有一类问题是不可解决的&lt;/strong>，这种问题&lt;strong>无论人类还是AI都无法解决&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>观点3：世间&lt;strong>还有一类问题是可解决的&lt;/strong>，其中一部分可以&amp;quot;彻底解决&amp;rdquo;，另一部分可以&amp;quot;委婉解决&amp;rdquo;，无论哪种，&lt;strong>AI终将比人类做的好&lt;/strong>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>观点4：人类具有通过灵性&lt;strong>突破不可解决的问题&lt;/strong>，和&lt;strong>将&amp;quot;委婉解决&amp;quot;的问题降维成&amp;quot;彻底解决&amp;rdquo;&lt;/strong>，目前&lt;strong>AI很难做到&lt;/strong>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="2不可判定问题">(2)不可判定问题&lt;/h3>
&lt;p>在计算理论中，不可解决的问题被称为&lt;strong>不可判定问题&lt;/strong>，人类解决不了的问题，AI也解决不了。&lt;/p>
&lt;ul>
&lt;li>比如：理发师宣称给全村所有不给自己刮胡子的人刮胡子就无法解决。&lt;/li>
&lt;li>类似的问题还有&amp;quot;停机问题&amp;rdquo;、&amp;ldquo;上帝造石问题&amp;quot;等等。&lt;/li>
&lt;li>但人类未知的领域太多了，可能在未知的领域，理发师可以做到他宣称的任务。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明：计算理论用数学工具对世间所有问题进行了分类，可简单认为不可解决的问题是不可判定的问题，可解决的问题是可判定问题。&lt;/p>
&lt;/blockquote>
&lt;h3 id="3判定问题">(3)判定问题&lt;/h3>
&lt;p>在计算理论中，对于可解决的问题被称为&lt;strong>可判定问题&lt;/strong>，这些可解决的问题有分两类：&lt;/p>
&lt;ul>
&lt;li>此类问题中的一部分可以&lt;strong>直奔主题、彻底解决&lt;/strong>，在计算理论中叫&lt;strong>P问题&lt;/strong>。
&lt;ul>
&lt;li>比如：计算一个圆的面积，知道了圆心和半径，就能彻底求解。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>此类问题中剩余部分只能&lt;strong>曲线救国，间接解决&lt;/strong>，在计算理论中叫&lt;strong>NP问题&lt;/strong>。
&lt;ul>
&lt;li>比如：要给一张照片中的狗描边需要很高的计算成本，但要回答一张照片有没有狗，计算成本就会变得很低。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>无论是P问题，还是NP问题，AI终将强于人类&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明：计算理论针对可解决的问题，用数学工具进行了量化，通过计算时间表现解决这个问题的困难程度。&lt;/p>
&lt;/blockquote>
&lt;h3 id="4灵感灵性灵魂">(4)灵感、灵性、灵魂&lt;/h3>
&lt;p>从解决问题的角度看，人类在如下两方面强于AI：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>将不可判定问题转变为可判定问题，人类强于AI&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>1935年，奥地利物理学家薛定谔提出了&lt;strong>薛定谔的猫&lt;/strong>，直至今日众多科学家还在感叹自己从未懂得量子力学。&lt;/p>
&lt;p>1851年，德国数学家黎曼分享了《论几何学作为基础的假设》，而在相隔近百年后爱因斯坦的《广义相对论的基础》中的空间几何采用了黎曼几何。&lt;/p>
&lt;p>这些例子，就是人脑有机会将&lt;strong>不可判定的问题&lt;/strong>转换为&lt;strong>可判定问题&lt;/strong>，将&lt;strong>未知&lt;/strong>变为&lt;strong>已知&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>将NP问题降维为P问题，人类强于AI&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>和王志兄探讨的时候，他讲到了《模拟游戏》，以当时的算力无论如何都很难破解德军密码，山穷水尽时几个科学家在酒吧中灵感乍现，利用一个常用词，巧妙地简化了破解密码的过程。从计算理论看，破解密码是个&lt;strong>NP问题&lt;/strong>，但因为其中反复出现的关键词，此问题降维成了&lt;strong>P问题&lt;/strong>，也就是可求解的问题了。&lt;/p>
&lt;p>再比如当今世界未解数学难题之一就是证明&lt;strong>NP问题是否等于P问题&lt;/strong>，一旦证明了，世间众多难解问题都可以变为可求解问题了。比如：癌症这个NP问题，就变成可治疗的P问题了。&lt;/p>
&lt;p>&lt;strong>人类文明的跳跃总是这样：在浩渺的历史场合中，微醺中、睡梦中，灵光一现。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>然而，人类的灵感、灵性、灵魂，似乎还没有数学公式可以表达。&lt;/strong>&lt;/p>
&lt;p>这个话题不能再深聊下去了，再聊就哲学(身心二元论)和神学了。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230221152255695.png" alt="image-20230221152255695">&lt;/p>
&lt;h2 id="13小结通用人工智能依然没有到来">1.3.小结：通用人工智能依然没有到来&lt;/h2>
&lt;p>通用人工智能，&lt;strong>Artificial general intelligence&lt;/strong>，简称&lt;strong>AGI&lt;/strong>。与之相反的就是弱人工智能(&lt;strong>Weak AI&lt;/strong>)，也叫做窄人工智能(&lt;strong>Narrow AI&lt;/strong>)。通用人工智能与弱人工智能最大的区别就是是否具备认知能力。弱人工智能有点像绿野仙踪里没有心的铁皮人，他的梦想就是有一颗真正的心。&lt;/p>
&lt;blockquote>
&lt;p>认知能力：详见https://en.wikipedia.org/wiki/Cognition&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230222160053172-16771388478091.png" alt="image-20230222160053172">&lt;/p>
&lt;p>从前述的软件内驱力(驱动力)、计算理论(解决问题能力)看，除非发生了一种&lt;strong>技术突变&lt;/strong>，否则机器要像人一样思考依然很困难。&lt;/p>
&lt;p>但，&lt;strong>AI技术在弱人工智能方向的确越来越强&lt;/strong>。我们接下来再从微观上做进一步分析。&lt;/p>
&lt;h1 id="2从微观看">2.从微观看&lt;/h1>
&lt;h2 id="21监督无监督只要狗粮撒的多人工智能勉强行">2.1.监督&amp;amp;无监督：只要狗粮撒的多，人工智能勉强行&lt;/h2>
&lt;h3 id="1一个例子是猫还是狗">(1)一个例子：是猫还是狗？&lt;/h3>
&lt;p>假设AI的数学工具为w₁x+w₂y(其中w₁初始值1，w₂初始化1)，&lt;/p>
&lt;p>并且，AI的数学工具输出表示：&lt;/p>
&lt;ul>
&lt;li>如果数学工具输出&amp;gt;=0，则表示照片中是1只狗。&lt;/li>
&lt;li>如果数学工具输出&amp;lt;0，则表示照片中是1只猫。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一波学习&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>输入第1张照片(是二哈，一种狗)，二哈的数学表示为(x=1, y=1)，则AI的数学工具输出2，进而推理出第1张照片是狗。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>输入第2张照片(是布偶，一种猫)，布偶的数学表示为(x=1, y=-2)，则AI的数学工具输出-1，进而推理出第2张照片是猫。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223162906437.png" alt="image-20230223162906437">&lt;/p>
&lt;p>&lt;strong>第二波学习&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>输入第3张照片(是泰迪，一种狗)，泰迪的数学表达是(x=-1, y=-1)，则AI的数学工具输出-2，进而推理出第3张照片是猫。&lt;/li>
&lt;li>此时就错了，泰迪怎么可能是一种猫。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223164621150.png" alt="image-20230223164621150">&lt;/p>
&lt;p>&lt;strong>第三波学习&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>此时，就要调整w₁和w₂，我掐指一算，调整为w₁=-1，w₂=1。&lt;/li>
&lt;li>输入第1张、第2张、第3张照片，AI的数学工具输出为0、-3、0，进而可知二哈是狗、布偶是猫、泰迪是狗。&lt;/li>
&lt;li>显然，w₁和w₂设计的合适，能够应对更多的照片，而不是每次输入一个新照片就要重新调整，这就是人工智能的黑话——&lt;strong>泛化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223165156039.png" alt="image-20230223165156039">&lt;/p>
&lt;p>于是，不断地喂进去新的图片，不断地调整w₁和w₂……&lt;/p>
&lt;p>于是，我师傅把上述过程叫做&lt;strong>喂狗&lt;/strong>，这些图片就是&lt;strong>狗粮&lt;/strong>。&lt;/p>
&lt;h3 id="2监督学习狗粮的成本很高">(2)监督学习：狗粮的成本很高&lt;/h3>
&lt;p>根据前面的例子，首先需要人类准备好非常非常多的照片，并且人要标识出来每张照片是猫还是狗，这种学习方式就是&lt;strong>监督学习&lt;/strong>。&lt;/p>
&lt;p>这就好像有个人类小孩儿不太聪明，他爸爸要把世界上所有的习题册都买回来，爸爸还要把每一道题自己先做一遍，再来一道一道教这孩子。&lt;/p>
&lt;p>在这种高昂的教学成本下，我们就可以看到父慈子孝的场面了：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/%E8%BE%85%E5%AF%BC%E5%8A%9F%E8%AF%BE.gif" alt="辅导功课">&lt;/p>
&lt;h3 id="3无监督学习从狗粮中吸收的营养有限">(3)无监督学习：从狗粮中吸收的营养有限&lt;/h3>
&lt;p>与监督学习相对的，是&lt;strong>无监督学习&lt;/strong>。无监督学习还是需要人类准备好非常多的照片，只是不需要人类把每一张照片都标注出是猫还是狗。&lt;/p>
&lt;p>人工智能在学习过程中，也能学会猫和狗两类照片的差别，但是它并没有&lt;strong>猫&lt;/strong>、&lt;strong>狗&lt;/strong>的概念。&lt;/p>
&lt;p>相当于，狗粮吃了，吸收的营养有限。&lt;/p>
&lt;h3 id="4感知机lenet神经网络喂狗工具在进化">(4)感知机、LeNet、神经网络，喂狗工具在进化&lt;/h3>
&lt;p>除了考虑狗粮问题，从Perceptron感知机，到LeNet，再到神经网络，喂狗工具也在进化，这里给出动图，我们感受一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%BC%94%E7%A4%BA1.gif" alt="神经网络演示1">&lt;/p>
&lt;h3 id="5观点">(5)观点&lt;/h3>
&lt;p>前面介绍了监督学习、无监督学习的方法论，可以看到：&lt;/p>
&lt;ul>
&lt;li>观点1：&lt;strong>对数据要求高，成本高&lt;/strong>。无论是数据清洗，还是数据标注，人工成本都很高。&lt;/li>
&lt;li>观点2：方法论决定了AI的能力&lt;strong>只能解决某些特定领域下的问题&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="22强化学习没有狗粮去喂狗人工智能还能行">2.2.强化学习：没有狗粮去喂狗，人工智能还能行&lt;/h2>
&lt;h3 id="1什么是强化学习">(1)什么是强化学习&lt;/h3>
&lt;p>先看一个实验，对强化学习有一个直观感受：&lt;/p>
&lt;ul>
&lt;li>机器人看到面前的架子，一次次地把盘子放到架子里，盘子碎了减分，盘子放好了加分。&lt;/li>
&lt;li>机器人看到面前随机出现的杯子，一次一次地把水倒进杯子里，倒进去的水越多加分，反之减分。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%A4%BA%E4%BE%8B.gif" alt="强化学习示例">&lt;/p>
&lt;p>强化学习中，有几个概念：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Agent&lt;/strong>：智能体，可以简单地认为就是人工智能本身。&lt;/li>
&lt;li>&lt;strong>Environment&lt;/strong>：环境，就是智能体所处的外在环境。&lt;/li>
&lt;li>&lt;strong>Action&lt;/strong>：行为，智能体会不断尝试做出1个行为，触发环境发生变化。&lt;/li>
&lt;li>&lt;strong>State&lt;/strong>：智能体观测环境发生此刻的状态。&lt;/li>
&lt;li>&lt;strong>Reward&lt;/strong>：当智能体做出一个行为以后，环境会对智能体产生奖励，也可能产生惩罚。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223221457273.png" alt="image-20230223221457273">&lt;/p>
&lt;p>再看看强化学习的流程：&lt;/p>
&lt;ul>
&lt;li>STEP1.观察到**Environment(环境)&lt;strong>中的&lt;/strong>State(状态)**有一杯水。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223231206199.png" alt="image-20230223231206199">&lt;/p>
&lt;ul>
&lt;li>STEP2.**Agent(智能体)&lt;strong>做出了一个&lt;/strong>Action(行为)**打翻水。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223231405476.png" alt="image-20230223231405476">&lt;/p>
&lt;ul>
&lt;li>STEP3.&lt;strong>Environment(环境)&lt;strong>产生了一个&lt;/strong>Reward(奖赏)&lt;/strong>——此时是个负向的奖赏——别那么做！&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223231328920.png" alt="image-20230223231328920">&lt;/p>
&lt;ul>
&lt;li>STEP4.**Agent(智能体)&lt;strong>再次看到的&lt;/strong>Environment(环境)&lt;strong>的&lt;/strong>State(状态)**是水杯打翻了。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223231651496.png" alt="image-20230223231651496">&lt;/p>
&lt;ul>
&lt;li>STEP5.**Agent(智能体)&lt;strong>做出了新的&lt;/strong>Action(行为)**把水擦干。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223231852875.png" alt="image-20230223231852875">&lt;/p>
&lt;ul>
&lt;li>STEP6.此时&lt;strong>Environment(环境)&lt;strong>发出的&lt;/strong>Reward(奖赏)&lt;/strong>——真棒&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223232148105.png" alt="image-20230223232148105">&lt;/p>
&lt;ul>
&lt;li>最终，人工智能学会了正确的选择。&lt;/li>
&lt;/ul>
&lt;h3 id="2强化学习的核心思想一次次的救赎">(2)强化学习的核心思想：一次次的救赎&lt;/h3>
&lt;p>这有点像电影《Source Code》的剧情，男主不断地经历同一次循环，他在循环里的每一步都在寻找突破，最终突破循环。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223232746654.png" alt="image-20230223232746654">&lt;/p>
&lt;p>作为人类的我，多么嫉妒人工智能具备的这种能力——&lt;strong>后悔药&lt;/strong>——曾经有一份真诚的爱情放在我面前，我没有珍惜，等我失去的时候才后悔莫及，人世间最疼苦的事莫过于此。如果上天能够给我一个再来一次的机会，我会对那个女孩说三个字：我爱你。如果非要在这份爱上加一个期限，我希望是……一万年。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223232959205.png" alt="image-20230223232959205">&lt;/p>
&lt;h3 id="3强化学习的难点延迟奖励探索突破灵性的灵犀一指">(3)强化学习的难点：延迟奖励&amp;amp;探索，突破灵性的灵犀一指&lt;/h3>
&lt;p>强化学习有两个难点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>延迟奖励&lt;/strong>：有一种可能——每一步都看起来得到最高的奖赏，但很可能最终还是输了整个游戏。这就是延迟奖励，&lt;strong>前面几步不仅不要赢，反而要输&lt;/strong>，赢得最终的比赛才是关键——色即是空，空即是色。&lt;/li>
&lt;li>&lt;strong>探索&lt;/strong>：再就是不走寻常路，某一步忽然走了以前没做过的动作，意外地得到奖励，也可能失败，&lt;strong>一把梭哈，撞个大运&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>强化学习的这两个难点，就好像《天龙八部》中的珍珑棋局，那么多青年才俊都无法攻克，虚竹却胡乱下了一步(&lt;strong>探索&lt;/strong>)，死了一大片子却开拓了新的天地(&lt;strong>延迟奖励&lt;/strong>)。如果再来从宏观层面谈，根据计算理论，虚竹这灵犀一指就是将&lt;strong>不可判定问题&lt;/strong>变为了&lt;strong>可判定问题&lt;/strong>，而这一指就是&lt;strong>人类的灵性&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223234346605.png" alt="image-20230223234346605">&lt;/p>
&lt;h3 id="4观点">(4)观点&lt;/h3>
&lt;ul>
&lt;li>观点1：强化学习一定程度地解决了有监督、无监督中的&lt;strong>狗粮问题&lt;/strong>。&lt;/li>
&lt;li>观点2：由于没有直接告知答案，因此需要&lt;strong>等待漫长的时间&lt;/strong>让机器去探索真理。所以强化学习的科学家们就是在不断优化其内部的数学工具，提升训练速度。
&lt;ul>
&lt;li>在强化学习中，有&lt;strong>Policy-Based&lt;/strong>和&lt;strong>Valued-Based&lt;/strong>两种策略，科学家为了解决策略梯度不好的问题，提出了&lt;strong>TROP&lt;/strong>算法，chatGPT进一步改进了这个算法，就是&lt;strong>PPO&lt;/strong>算法。&lt;/li>
&lt;li>我们在本文中不必深入这些术语的公式、原理、细节，只需要大致有个印象，知道chatGPT用这个算法到底要解决什么问题。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>观点3：强化学习的底层逻辑，其实就是&lt;strong>主动学习、反复试错&lt;/strong>，&lt;strong>你只需要给我时间，我并不需要你的狗粮&lt;/strong>。
&lt;ul>
&lt;li>这不仅仅是解决训练成本的问题，主动学习是人类的重要特质，&lt;strong>主动学习能力或许是机器具备人类灵性的突破口之一&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>观点4：强化学习的奖励机制，不一定是一个单纯的奖励模型，也可以是一个&lt;strong>人类偏好模型&lt;/strong>。
&lt;ul>
&lt;li>&lt;strong>感受自我、感知他人&lt;/strong>，这也是人类另一种重要特质，这&lt;strong>也可能是机器具备人类灵性的突破口&lt;/strong>。&lt;/li>
&lt;li>chatGPT用了人类偏好模型，这就是为什么它会惊艳到很多人的原因之一，后文会讲到。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="23看chatgpt原理图">2.3.看chatGPT原理图&lt;/h2>
&lt;p>有了前文宏观层面建立的世界观，有了前文微观层面讲述的AI算法，我们可以来理解一下chatGPT的原理图了：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230223234441157.png" alt="image-20230223234441157">&lt;/p>
&lt;h3 id="1拥有一个基础版本的聊天机器人">(1)拥有一个基础版本的聊天机器人&lt;/h3>
&lt;p>chatGPT第一阶段本质是监督+无监督，人类标注了一定数量的问题数据集，这里和大多数AI领域工程师现在的工作差不多。&lt;/p>
&lt;p>在chatGPT，把训练的结果叫做&lt;strong>SFT模型&lt;/strong>，本质就是获得了一个初级版本的聊天机器人。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230224141822069.png" alt="image-20230224141822069">&lt;/p>
&lt;h3 id="2关键步骤我知道人类喜欢什么">(2)关键步骤，我知道人类喜欢什么&lt;/h3>
&lt;p>第二步是关键步骤，用1个问题驱动&lt;strong>SFT&lt;/strong>，机器人返回4个答案，人类只需要对这4个答案进行排序。&lt;/p>
&lt;p>这太有创意了：&lt;strong>一个人类回答问题是困难的&lt;/strong>(需要这个人类是这个问题的领域专家)，但&lt;strong>让人类判断哪个回答更好是简单的&lt;/strong>(这个人类只需要有一定的领域知识)。&lt;/p>
&lt;p>排序也是一种&lt;strong>标注&lt;/strong>，这个标注不再只是&lt;strong>是猫是狗&lt;/strong>的简单标注，而是&lt;strong>&lt;font color=red>人类喜好&lt;/font>&lt;/strong>！&lt;/p>
&lt;p>chatGPT将这种人类喜欢叫做RM模型。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230224143243772.png" alt="image-20230224143243772">&lt;/p>
&lt;h3 id="3学的快我懂你">(3)学的快，我懂你&lt;/h3>
&lt;p>chatGPT到了第三步，似乎就水到渠成了。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230224150150372.png" alt="image-20230224150150372">&lt;/p>
&lt;p>关于&lt;strong>学的快&lt;/strong>，和人类学习一项新技能本质是一样的，抽象为两点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>学习有效信息&lt;/strong>：谷歌发明的注意力模型就是解决机器学习信息时，尽量像人一样关注到核心信息。
&lt;ul>
&lt;li>比如：下面这张图，我觉得大部分人类第一反应是注意到照片里有两匹马，而不是背后的风景吧(不过这里的风景真的很美)？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91chatGPT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E6%9C%BA%E5%99%A8%E8%BF%98%E9%9C%80%E8%A6%81%E5%A4%9A%E4%B9%85%E6%89%8D%E8%83%BD%E5%83%8F%E4%BA%BA%E4%B8%80%E6%A0%B7%E6%80%9D%E8%80%83/image-20230224151038341.png" alt="image-20230224151038341">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>学的过程快&lt;/strong>：PPO算法是强化学习中的一个单点算法，优化梯度问题，本质还是解决学的过程要快。&lt;/li>
&lt;/ul>
&lt;p>关于&lt;strong>我懂你&lt;/strong>，就是第二步的&lt;strong>人类喜好模型RM&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>将人类喜好模型作为&lt;strong>奖赏&lt;/strong>，让机器人的回答不断解决人类喜好的那种回答。
&lt;ul>
&lt;li>这里面还有一个细节，回答类似输入法的自动联想，回答一个词就联想下一个词，下一个词的选择会遵循人类喜好模型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>一个人类的小孩，能从课本中提取到关键知识、理解关键知识很快、并且学习的目标一直围绕着正确的方向，这孩子一定是学霸。&lt;/p>
&lt;p>这就是在&lt;strong>正确的方向上强执行力地做事&lt;/strong>。&lt;/p>
&lt;h3 id="4观点-1">(4)观点&lt;/h3>
&lt;ul>
&lt;li>观点1：chatGPT并不是一个技术突变的产品，AI发展史上所有的技术都是被它使用的，&lt;strong>能灵活运用已有的AI技术是值得我们学习的可贵之处&lt;/strong>。&lt;/li>
&lt;li>观点2：宏观层面人类的灵性是强人工智能最大的挑战，但微观层面&lt;strong>强化学习可能存在突破人类灵性的可能性&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h2 id="24小结微观层面的术在不断进步">2.4.小结：微观层面的术在不断进步&lt;/h2>
&lt;ul>
&lt;li>监督&amp;amp;无监督学习最大的问题是训练数据的成本，强化学习一定程度上解决了这个成本问题。&lt;/li>
&lt;li>chatGPT对强化学习的贡献在于：&lt;strong>获得有效的知识&lt;/strong>(注意力模型)、&lt;strong>高效的学习速度&lt;/strong>(PPO算法)、&lt;strong>正确的努力方向&lt;/strong>(人类喜好模型RM)&lt;/li>
&lt;/ul>
&lt;h1 id="3理性思考充满好奇虚心求索">3.理性思考、充满好奇、虚心求索&lt;/h1>
&lt;p>如果我的小伙伴们能看到这里，很感谢你们。这篇文章从提笔到写完，占用了我一周所有的业余时间。&lt;/p>
&lt;p>chatGPT的论文涉及到的知识面太广，远超我的认知，同时由于给我的极大震撼，我又有太多想表达的内容。&lt;/p>
&lt;p>在我的学习笔记第一篇，我选择表述我最感兴趣的话题——&lt;strong>机器像人一样思考还有多远？&lt;/strong>&lt;/p>
&lt;p>人类很多工作可能或正在被人工智能替代，这只能叫&lt;strong>岗位转换&lt;/strong>，&lt;strong>只是物理层面的替代&lt;/strong>。&lt;/p>
&lt;p>拖拉机发明了，这个岗位的人类去做了别的岗位，但至今没看到人类被拖拉机统治。&lt;/p>
&lt;p>很感谢学习过程中，身边有那些宏观、微观层面帮助我&lt;strong>理性思考&lt;/strong>的小伙伴。&lt;/p>
&lt;p>写这篇文章时，我被迫看了很多哲学和数学资料，比如：身心二元论、计算理论等等。&lt;/p>
&lt;p>&lt;strong>我们的世界底层逻辑还是数学和哲学&lt;/strong>，可惜功利的我不允许自己去探索这种没有既得利益的知识。&lt;/p>
&lt;p>或许，我偶尔应该&lt;strong>充满好奇&lt;/strong>，而不那么功利。&lt;/p>
&lt;p>最后，面对国内对chatGPT的一片喧嚣，在努力弄懂chatGPT的原理之后，大致能分辨出哪些仅仅是停留在商业数据的分析伪洞察，哪些是没搞清How就乱给Do建议的伪分析。&lt;/p>
&lt;p>&lt;strong>虚心求索&lt;/strong>，欢迎小伙伴们共同研究这些&lt;strong>有趣的技术&lt;/strong>、&lt;strong>有趣的未来&lt;/strong>。&lt;/p></description></item><item><title>【音乐】陈升-恨情歌</title><link>https://jherculesqz.github.io/post/%E6%9D%82%E8%B4%A7%E9%93%BA/%E9%9F%B3%E4%B9%90%E9%99%88%E5%8D%87-%E6%81%A8%E6%83%85%E6%AD%8C/</link><pubDate>Fri, 24 Feb 2023 00:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/%E6%9D%82%E8%B4%A7%E9%93%BA/%E9%9F%B3%E4%B9%90%E9%99%88%E5%8D%87-%E6%81%A8%E6%83%85%E6%AD%8C/</guid><description>&lt;center>&lt;font size=20>恨情歌&lt;/font>&lt;/center>
&lt;p align="right">陈升&lt;/p>
&lt;center>為了要討好你的歡心，我經常忘記我自己&lt;/center>
&lt;center>感情是件瘋狂的事， 多了並不見得好&lt;/center>
&lt;center>我不能隨便我自己， 快樂輕聲地歌唱&lt;/center>
&lt;center>都說你愛聽情歌， 來分擔你心中的苦&lt;/center>
&lt;center>不要像頑皮的孩子， 老說為我唱情歌&lt;/center>
&lt;center>常常我一個人在夜裡， 擔心迷失我自己&lt;/center>
&lt;center>而原來我是一個， 愛四處遊蕩的人&lt;/center>
&lt;center>如果有那麼一天我停住了，你是否就離開我&lt;/center>
&lt;center>於是我叫我自己恨情歌，假裝我不在乎&lt;/center>
&lt;center>或者我不再去討你歡心，我喜歡這樣的自己&lt;/center>
&lt;center>於是我叫我自己恨情歌，假裝我不在乎&lt;/center>
&lt;center>也許你從來都沒說過，是我想的太多&lt;/center>
&lt;center>而原來我是一個，愛四處遊蕩的人&lt;/center>
&lt;center>都說你愛聽情歌，來分擔你心中的苦&lt;/center>
&lt;center>於是我叫我自己恨情歌，假裝我不在乎&lt;/center>
&lt;center>或者我不再去討你歡心，我喜歡這樣的自己&lt;/center>
&lt;center>於是我叫我自己恨情歌，假裝我不在乎&lt;/center>
&lt;center>也許你從來都沒說過，是我想的太多&lt;/center>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%9D%82%E8%B4%A7%E9%93%BA/%E3%80%90%E9%9F%B3%E4%B9%90%E3%80%91%E9%99%88%E5%8D%87-%E6%81%A8%E6%83%85%E6%AD%8C/image-20230224000529962.png" alt="image-20230224000529962">&lt;/p>
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/s2xcIjcH_u8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>&lt;/iframe></description></item><item><title>【SpringOne 2022】5.Introduction to Testcontainers</title><link>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20225.introduction-to-testcontainers/</link><pubDate>Sat, 18 Feb 2023 10:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20225.introduction-to-testcontainers/</guid><description>&lt;p>SpringOne 2022第6个议题《Introduction to Testcontainers》，用3个Demo展示了TestContainers for Java的重要特性，主讲人：Oleg Selajev，辅助人：Cora lberkleid。PS：Oleg Selajev的演讲风格非常有激情。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230217074026357.png" alt="image-20230217074026357">&lt;/p>
&lt;h1 id="1概述">1.概述&lt;/h1>
&lt;h2 id="11集成测试对微服务架构的影响深远">1.1.集成测试对微服务架构的影响深远&lt;/h2>
&lt;p>演讲者核心观点是：&lt;/p>
&lt;ul>
&lt;li>在传统架构下，测试成本的投入情况是**&amp;ldquo;单元测试&amp;quot;&amp;gt;&amp;quot;集成测试&amp;quot;&amp;gt;&amp;quot;E2E测试&amp;rdquo;**(如下图左半部分)。&lt;/li>
&lt;li>在微服务架构下，存在数量巨大的微服务进程，不太可能全量测试和发布。
&lt;ul>
&lt;li>更合理的做法：仅对本轮迭代有关的微服务进行集成测试，局部发布。&lt;/li>
&lt;li>如下图右半部分：如果集成测试投入更多，那么与本次发布相关的微服务影响范围是相对可控的，进而E2E测试可能会更简单。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>总之，&lt;strong>集成测试在微服务架构下越来越重要&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230217091453992.png" alt="image-20230217091453992">&lt;/p>
&lt;h2 id="12集成测试的新方法">1.2.集成测试的新方法&lt;/h2>
&lt;p>主讲人在这部分展示了&lt;strong>没有TestContainers之前&lt;/strong>、&lt;strong>使用TestContainers之后&lt;/strong>的集成测试手段的差异：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>之前&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在服务器上部署被测微服务、依赖的组件(如：数据库、Redis、Kafka等)&lt;/li>
&lt;li>在服务器上以Docker的形式部署被测微服务、依赖的组件&lt;/li>
&lt;li>在本地电脑上部署被测微服务、依赖的组件&lt;/li>
&lt;li>&lt;/li>
&lt;li>对部署成本高的依赖组件，采用&lt;strong>模拟&lt;/strong>的方式
&lt;ul>
&lt;li>如：Wiremock这类Mock Server&lt;/li>
&lt;li>如：采用h2数据库进行测试，规避安装PostgreSQL这种更重型的数据库&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218065338566.png" alt="image-20230218065338566">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>之后&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>STEP1.TestContainers提供了丰富的&lt;code>Module&lt;/code>(这些&lt;code>Module&lt;/code>对应各类流行的中间件、数据库等)
&lt;ul>
&lt;li>比如：&lt;code>Redis Module&lt;/code>对应&lt;code>Redis&lt;/code>&lt;/li>
&lt;li>比如：&lt;code>Kafka Module&lt;/code>对应&lt;code>Kafka&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>STEP2.这些&lt;code>Module&lt;/code>，各自都提供了API(这些API封装了Docker API)
&lt;ul>
&lt;li>这就意味着我们可以通过某个&lt;code>Module&lt;/code>的API，操纵对应的Docker容器&lt;/li>
&lt;li>比如：&lt;code>Redis Module&lt;/code>提供1个&lt;code>启动redis容器&lt;/code>的API，调用以后，就会在服务器上真的运行起来1个&lt;code>Redis&lt;/code>的镜像&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>STEP3.TestContainers再和各类流行的测试框架集成，管理&lt;code>Module&lt;/code>对应的被依赖组件的容器的生命周期
&lt;ul>
&lt;li>比如：TestContainers在JUnit的&lt;code>setUp&lt;/code>方法中创建了&lt;code>Redis&lt;/code>容器，在&lt;code>TearDown&lt;/code>方法中销毁&lt;code>Redis&lt;/code>容器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218102321877.png" alt="image-20230218102321877">&lt;/p>
&lt;h2 id="13testcontainers发展历史">1.3.TestContainers发展历史&lt;/h2>
&lt;p>演讲者在这一部分讲述了TestContainers创建时的小故事：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>2014年，一位名叫Moshe Eshel的大神在GitHub上写了&lt;code>DockerContainerRule.java&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>这段代码Override了JUnit的&lt;code>@Before&lt;/code>和&lt;code>@After&lt;/code>&lt;/p>
&lt;ul>
&lt;li>在JUnit执行before方法时，会启动指定的Docker容器&lt;/li>
&lt;li>在JUnit执行after方法时，会关闭指定的Docker容器&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>2017年，TestContainers完全替代了&lt;code>DcokerContainerRule.java&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218101112791.png" alt="image-20230218101112791">&lt;/p>
&lt;p>听演讲的时候，没太跟上演讲者的语速，和chatGPT印证了一下：&lt;/p>
&lt;ul>
&lt;li>的确可以认为：&lt;code>DcokerContainerRule.java&lt;/code>是TestContainers的灵感来源&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218101251008.png" alt="image-20230218101251008">&lt;/p>
&lt;h2 id="14testcontainers成熟度">1.4.TestContainers成熟度&lt;/h2>
&lt;p>从主讲人表述的信息，TestContainers的确很成熟：&lt;/p>
&lt;ul>
&lt;li>TestContainers项目在GitHub上是6.6k星&lt;/li>
&lt;li>Docker项目发布的第2年就创建了，是这类测试框架的&lt;strong>老前辈&lt;/strong>&lt;/li>
&lt;li>TestContainers宣称&lt;strong>&lt;code>Works with anything that runs in a Docker container&lt;/code>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218103001722.png" alt="image-20230218103001722">&lt;/p>
&lt;ul>
&lt;li>在2022年被ThoughtWorks的咨询报告中，TestContainers&lt;strong>被评为&lt;code>Adopt采纳级&lt;/code>&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218103330486.png" alt="image-20230218103330486">&lt;/p>
&lt;h1 id="2demo0">2.Demo0&lt;/h1>
&lt;h2 id="21testcontainers的测试流程">2.1.TestContainers的测试流程&lt;/h2>
&lt;p>这是演讲者的第1个Demo：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：
&lt;ul>
&lt;li>在测试类上，增加了&lt;code>@Testcontainers&lt;/code>注解&lt;/li>
&lt;li>为测试类创建了&lt;code>GenericContainer&lt;/code>对象，此对象表示1个Docker容器&lt;/li>
&lt;li>在&lt;code>@Before&lt;/code>方法中，调用&lt;code>GenericContainer&lt;/code>对象，打印它的Docker容器Id&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>**日志解读：**从日志看，&lt;strong>TestContainers完整地管理了1个容器的生命周期&lt;/strong>。
&lt;ul>
&lt;li>JUnit先执行&lt;code>@BeforeEach&lt;/code>方法&lt;/li>
&lt;li>JUnit会连接Docker服务器&lt;/li>
&lt;li>Ryuk被启动(Ryuk是啥呢？稍后解释)&lt;/li>
&lt;li>进行系统检查&lt;/li>
&lt;li>启动容器镜像&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218103524464.png" alt="image-20230218103524464">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Ryuk是什么？&lt;/strong>
&lt;ul>
&lt;li>Ruyk是Moby项目中的1个工具&lt;/li>
&lt;li>这个工具支持对Docker镜像的管理&lt;/li>
&lt;li>chatGPT回答如下：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218104759166.png" alt="image-20230218104759166">&lt;/p>
&lt;h2 id="22如何重用1个容器">2.2.如何重用1个容器&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：仅需要在测试类创建&lt;code>GenericContainer&lt;/code>对象时，将该对象设置为&lt;code>static&lt;/code>&lt;/li>
&lt;li>&lt;strong>日志解读&lt;/strong>：
&lt;ul>
&lt;li>执行测试用例1时，TestContainers创建的Docker容器ID尾号&lt;code>bc739b5a&lt;/code>&lt;/li>
&lt;li>执行测试用例2时，TestContainers创建的Docker容器ID尾号也是&lt;code>bc739b5a&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218104923764.png" alt="image-20230218104923764">&lt;/p>
&lt;h1 id="3demo1">3.Demo1&lt;/h1>
&lt;h2 id="31端口配置">3.1.端口配置&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：
&lt;ul>
&lt;li>在创建&lt;code>GenericContainer&lt;/code>对象时，通过&lt;code>withExposedPorts&lt;/code>方法&lt;strong>开放了80端口&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218111638548.png" alt="image-20230218111638548">&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>在测试用例2中，通过&lt;code>GenericContainer&lt;/code>对象的&lt;code>getHost&lt;/code>和&lt;code>getFirstMappedPort&lt;/code>方法，获得Docker容器的IP和端口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218111714728.png" alt="image-20230218111714728">&lt;/p>
&lt;h2 id="32日志操作">3.2.日志操作&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：&lt;/li>
&lt;li>获得日志的方式1：调用&lt;code>GenericContainer&lt;/code>对象的&lt;code>getLogs&lt;/code>方法&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218112057805.png" alt="image-20230218112057805">&lt;/p>
&lt;ul>
&lt;li>&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>获得日志的方式2：使用&lt;code>Slf4jLogConsumer&lt;/code>对象&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218112301488.png" alt="image-20230218112301488">&lt;/p>
&lt;h2 id="33使用dockfile">3.3.使用Dockfile&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：
&lt;ul>
&lt;li>创建&lt;code>GenericContainer&lt;/code>对象时，指定DockFile文件路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218112544145.png" alt="image-20230218112544145">&lt;/p>
&lt;h1 id="4demo2">4.Demo2&lt;/h1>
&lt;h2 id="41rediskafkapostgresql">4.1.redis+kafka+PostgreSQL&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：
&lt;ul>
&lt;li>创建&lt;code>RedisContainer&lt;/code>对象和&lt;code>KafkaContainer&lt;/code>对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218113102821.png" alt="image-20230218113102821">&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>创建&lt;code>PostgreSQLContainer&lt;/code>对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218113215484.png" alt="image-20230218113215484">&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>设置&lt;code>Redis&lt;/code>容器、&lt;code>PostgreSQL&lt;/code>容器的参数：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218113306162.png" alt="image-20230218113306162">&lt;/p>
&lt;h2 id="42混沌测试">4.2.混沌测试&lt;/h2>
&lt;p>&lt;strong>Chaos Test&lt;/strong>是主讲人最出彩的一段，通过&lt;strong>Toxiproxy&lt;/strong>，可以很方便地模拟高负载、网络故障等，&lt;strong>实战中非常实用&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：
&lt;ul>
&lt;li>创建&lt;code>Network&lt;/code>对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218115356716.png" alt="image-20230218115356716">&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>创建&lt;code>Toxiproxy&lt;/code>容器对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218115429306.png" alt="image-20230218115429306">&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>通过&lt;code>Toxiproxy&lt;/code>容器对象，创建&lt;code>redis&lt;/code>容器的网络连接代理对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218115553720.png" alt="image-20230218115553720">&lt;/p>
&lt;ul>
&lt;li>
&lt;ul>
&lt;li>设置&lt;code>redis&lt;/code>容器的网络延时为2s，这样，我们就可以模拟生产环境上redis存在2s延时的网络环境了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218115652712.png" alt="image-20230218115652712">&lt;/p>
&lt;ul>
&lt;li>chatGPT对&lt;strong>Toxiproxy&lt;/strong>的介绍：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%915.IntroductiontoTestcontainers/image-20230218114014618.png" alt="image-20230218114014618">&lt;/p>
&lt;h1 id="5小结">5.小结&lt;/h1>
&lt;p>通过演讲者的3个Demo，可以得到如下的判断：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>TestContainers已经是相当成熟的集成测试组件了&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过TestContainers提供的丰富的&lt;code>Module&lt;/code>，极大地降低了集成测试时，依赖组件的部署和维护成本&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>【chatGPT】和chatGPT结对编程的6小时</title><link>https://jherculesqz.github.io/post/ai%E6%8B%BE%E9%81%97/chatgpt%E5%92%8Cchatgpt%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/</link><pubDate>Tue, 14 Feb 2023 18:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/ai%E6%8B%BE%E9%81%97/chatgpt%E5%92%8Cchatgpt%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/</guid><description>&lt;h1 id="1我对ai的偏见">1.我对AI的偏见&lt;/h1>
&lt;p>2013年我写了个微信聊天机器人，在新浪微博上小火了一把。我的认知局限性让我没想到若干年后网红如此赚钱，活该我现在还在搬砖送外卖。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214114334028.png" alt="image-20230214114334028">&lt;/p>
&lt;p>那阵子心里美滋滋——这个机器人好像我小孩儿，你教它一点，它就聪明一点。当然我那帮损友最终把它教成了流氓二混子。&lt;/p>
&lt;p>即便我很喜欢我的机器人，但还是在一年后亲手关了它的服务器，因为我对&lt;strong>2013年的AI理论基础&lt;/strong>不太看好(这也是我的偏见)：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>计算机视觉&lt;/strong>：这个算是2013年左右，AI应用最成熟的领域吧，车牌识别、人脸识别、零件识别等等。但它的理论本质还是那些天才数学家归纳出了N种&amp;quot;人类视觉&amp;quot;的模式。**你觉得人类眼睛看到的美仅仅是一堆数学公式吗？**我不觉得。&lt;/li>
&lt;li>&lt;strong>商业BI&lt;/strong>：这也是2013年那会儿，AI另一个有广泛应用的领域吧。请注意，我说的是广泛应用，而不是成熟应用。说白了，在商业智能中，那些AI理论宣称的是通过&amp;rdquo;&lt;strong>历史数据&lt;/strong>&amp;ldquo;就能&amp;rdquo;&lt;strong>预测未来&lt;/strong>&amp;quot;——咱们不要去辩论&amp;rdquo;&lt;strong>线性回归&lt;/strong>&amp;quot;、&amp;quot;&lt;strong>聚类&lt;/strong>&amp;ldquo;的理论合理性，也不要去讨论AI书本上的&amp;rdquo;&lt;strong>波士顿房价预测&lt;/strong>&amp;ldquo;的经典案例——百度识图很牛，它能告诉我们这什么花什么草，但有个AI预测出下一把投资个啥华为就能统治全宇宙，你看华为的大佬们敢不敢一把梭哈——&lt;strong>人类历史真的能归纳成1个因变量有限的简单数学公式吗&lt;/strong>？&lt;/li>
&lt;li>………——此处的省略号表示在2013年的我有限的认知中，我想不通AI的未来在哪里。&lt;/li>
&lt;/ul>
&lt;p>再后来，&lt;code>TensorFolow&lt;/code>火了、菊厂有了自己的菊厂云，我兴奋地把西瓜书翻了又翻，忽然失落了：&lt;/p>
&lt;ul>
&lt;li>这些新的AI资料，似乎和我那些尘封已久的前一代的AI书籍没啥质的飞跃。&lt;/li>
&lt;li>我师傅说：&amp;quot;&lt;strong>人工智能就是喂狗&lt;/strong>&amp;quot;——模型是数学家设计好的，我们只是不断地喂数据、确认结果。&lt;/li>
&lt;li>我说：&amp;quot;&lt;strong>此时此刻的人工智能就是更高效地喂狗&lt;/strong>&amp;quot;——喂数据的手段更高级了、算力更强了、模型测试更高效了等等。&lt;/li>
&lt;/ul>
&lt;p>于是，我得出了个人的判断：&lt;strong>可能又是资本割韭菜&lt;/strong>，我可不能把有限的时间投入到研究这门手艺上。&lt;/p>
&lt;p>我怀着对AI深深的偏见，每天研究着我更感兴趣的JVM源码、Spring源码&amp;hellip;&amp;hellip;直到上周六(2023年2月11日)的下午。&lt;/p>
&lt;h1 id="2第1个故事它不是人工智障">2.第1个故事：它不是人工智障&lt;/h1>
&lt;p>上周六朋友要我帮他写段代码：他想要一个能算个税的Excel，便于他们公司税务筹划。&lt;/p>
&lt;p>朋友讲了半天个税咋算，工作18年也没搞懂每个月咋扣税的我依然没听懂。&lt;/p>
&lt;p>作为资深码农，最烦客户讲不清楚需求(软件工程中最大的魔咒)！&lt;/p>
&lt;h2 id="第1个问题">第1个问题&lt;/h2>
&lt;p>&lt;strong>咋办呢？我问了chatGPT第1个问题&lt;/strong>，转给朋友看，他确认回答正确：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214141101548.png" alt="image-20230214141101548">&lt;/p>
&lt;h2 id="第2个问题">第2个问题&lt;/h2>
&lt;p>&lt;strong>接着，懒惰的我问它第2个问题&lt;/strong>：能不能把上述文字转成代码？&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214141035939.png" alt="image-20230214141035939">&lt;/p>
&lt;h2 id="代码生成效果咋样">&lt;strong>代码生成效果咋样？&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>首先，看完这段代码，我终于明白个税咋算了，感谢chatGPT。。。&lt;/li>
&lt;li>然后，朋友说除了&amp;quot;个税起征点&amp;quot;要乘以期数，其它都对。。。&lt;/li>
&lt;li>最后，我仔细检视并运行了它的代码：除了代码规范外，&lt;strong>它的代码还有个性能小亮点&lt;/strong>——寻找收入分级的速算系数时用了倒查，我自己还真不会这样写。。。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214140255700.png" alt="image-20230214140255700">&lt;/p>
&lt;h2 id="第3个问题">第3个问题&lt;/h2>
&lt;p>故事没完，在Excel里写公式有点难写：个税计算要分级，会有很长的IF嵌套。&lt;/p>
&lt;p>如果Google查资料+写公式+测试，我估计要1小时吧。&lt;/p>
&lt;p>&lt;strong>于是，我问了chatGPT第3个问题&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214141004154.png" alt="image-20230214141004154">&lt;/p>
&lt;p>这个公式有多长呢？我把代码贴出来，大家可以评估一下自己需要多久写得出来：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="o">=&lt;/span>&lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">36000&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">03&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">144000&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">2520&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">300000&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">2&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">16920&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">420000&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">25&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">31920&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">660000&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">3&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">52920&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">IF&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="n">960000&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">35&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">85920&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">A1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">B1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">5000&lt;/span>&lt;span class="o">)*&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">45&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">181920&lt;/span>&lt;span class="o">)))))))&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="第4个问题">第4个问题&lt;/h2>
&lt;p>这个公式只是算了一个月的个税，朋友最终想要的是1月、2月&amp;hellip;.12月的个税应缴税额。&lt;/p>
&lt;p>这样就涉及你的第2行要取第1行的单元格、第3行取第2行，依此类推。&lt;/p>
&lt;p>这样的公式咋写呢？&lt;/p>
&lt;p>我和朋友Google了半天也没知道答案，因为我想要公式的功能要用人类的一段话表达，而搜索引擎只能输入关键字。&lt;/p>
&lt;p>&lt;strong>于是，我问chatGPT的第4个问题是人类能理解的一整段话&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214141542915.png" alt="image-20230214141542915">&lt;/p>
&lt;p>通过chatGPT的回答，我知道了&lt;code>INDIRECT函数&lt;/code>。&lt;/p>
&lt;p>显然，通过搜索引擎最终也能找到&lt;code>INDIRECT函数&lt;/code>，但没chatGPT这么快。&lt;/p>
&lt;p>因为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>搜索引擎的底层逻辑&lt;/strong>：人类告诉它关键字，它给人类有关联的结果，人类自行分析，&lt;strong>人类得出结论&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>chatGPT的底层逻辑&lt;/strong>：人类告诉它人类语言，它自己找到有关联的结果并自行分析得出结论，&lt;strong>人类获得结论&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>这就有点意思了，&lt;strong>难怪微软赶紧让Bing接入chatGPT，谷歌瑟瑟发抖&lt;/strong>。&lt;/p>
&lt;p>至此，朋友要的Excel做完了，耗时半小时。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214143709735.png" alt="image-20230214143709735">&lt;/p>
&lt;h2 id="观点">观点&lt;/h2>
&lt;p>&lt;strong>chatGPT真不是人工智障&lt;/strong>，而是真的人工智能。对于第1个故事，我有几个观点：&lt;/p>
&lt;h3 id="1任务难度简单">(1)任务难度：简单&lt;/h3>
&lt;p>Excel写公式是日常、简单工作，作为人类的我们，花点时间肯定能完成。&lt;/p>
&lt;h3 id="2值得关注的突破点有可能改变软件开发模式">(2)值得关注的突破点：有可能改变软件开发模式。&lt;/h3>
&lt;p>&lt;strong>过去，需求传递是软件研发最大的工程成本&lt;/strong>。客户是业务专家，程序员软件专家。如果表达能力弱的客户遇上不懂业务的程序员，那么这个项目铁定黄。菊花厂各种工程方法和质量流程本质上还是&lt;strong>对人与人的沟通成本&lt;/strong>的妥协。&lt;/p>
&lt;p>&lt;strong>未来，chatGPT可能成为客户与程序员的沟通桥梁&lt;/strong>。chatGPT与任何一个人类相比，可以认为是通才——不会开船的公交车司机不是个好程序员——chatGPT大致是这么个意思吧。&lt;/p>
&lt;p>在亲身体验chatGPT之前，身边同事不屑地说：&amp;ldquo;我就不信有描述清楚需求的客户，需求描述不清chatGPT再牛逼也写不出来&amp;rdquo;，逻辑如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214145728163.png" alt="image-20230214145728163">&lt;/p>
&lt;p>在亲身体验chatGPT之后，不得不说这或许就是人类的局限性，难道人类不能变通一下吗：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214150532484.png" alt="image-20230214150532484">&lt;/p>
&lt;h3 id="3值得关注的突破点一般的crud代码它写的不比人类差">(3)值得关注的突破点：一般的CRUD代码，它写的不比人类差。&lt;/h3>
&lt;p>比如这个故事中的Java代码，不知道菊厂工作级的程序员能否在20分钟内，理解需求+编码+一次性测过。&lt;/p>
&lt;h1 id="3第2个故事你值得收下我的膝盖">3.第2个故事：你值得收下我的膝盖&lt;/h1>
&lt;p>完成朋友的Excel，我开始写自己的技术专栏。&lt;/p>
&lt;p>那天写的是&lt;strong>Java线程和操作系统的对应关系&lt;/strong>。&lt;/p>
&lt;p>这个技术问题有多深呢？&lt;/p>
&lt;p>除了毕昇JDK团队的专家和我这种好奇宝宝，我猜菊厂大部分Java程序猿不会意识到这个问题，更不用说阅读对应的JVM源码。&lt;/p>
&lt;p>我花了4天跟踪了JVM的相关代码，写了这篇文章《&lt;a href="https://mp.weixin.qq.com/s/O-cE6-jIYk66meYINt3gMg">【运行时数据区】-并发编程-前置知识(4.并发编程基础)-3&lt;/a>》。&lt;/p>
&lt;p>各位读者有兴趣可以看看，应该有点复杂，于是，我开始好奇在我的专业领域，chatGPT表现如何？&lt;/p>
&lt;h2 id="第1个问题-1">第1个问题&lt;/h2>
&lt;p>第1个问题我问的比较笼统，chatGPT回答的也比较含糊。&lt;/p>
&lt;p>看起来答案没啥问题，但是语言的二义性，我不确定chatGPT是不是瞎蒙的，于是我问了第2个问题。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214153034266.png" alt="image-20230214153034266">&lt;/p>
&lt;h2 id="第2个问题-1">第2个问题&lt;/h2>
&lt;p>第2个问题的回答有点惊艳：&lt;/p>
&lt;ul>
&lt;li>首先，它知道不同厂家实现的JVM可能不同，所以答案最后它在强调HotSpot是这么实现的。&lt;/li>
&lt;li>其次，它能精确理解&lt;code>scr/share/vm/runtime/thread.cpp&lt;/code>这段&lt;strong>代码的业务含义&lt;/strong>(即，这段代码在做什么事情)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214153210729.png" alt="image-20230214153210729">&lt;/p>
&lt;p>AI能理解**&amp;ldquo;代码的业务含义&amp;rdquo;**有多牛逼呢？&lt;/p>
&lt;p>回看一下业界历史上那么多代码质量检查工具，它们可以做到静态检查、内存检查、安全检查等，能理解这段代码在干啥吗？&lt;/p>
&lt;p>回到&amp;quot;Java线程和JVM线程的关系&amp;quot;这个技术问题上，JVM的启动流程有多少关键步骤呢？&lt;strong>34步&lt;/strong>。&lt;/p>
&lt;p>我花了4天时间，一边Debug、一边修正这张流程图、一边理解这段代码的业务含义，关键这还是我的专业领域：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230211233551236.png" alt="image-20230211233551236">&lt;/p>
&lt;h2 id="第3个问题-1">第3个问题&lt;/h2>
&lt;p>我问了chatGPT很具体的问题，如果没看过JVM源码的人类，应该无法回答。&lt;/p>
&lt;p>再看看chatGPT的答案：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214155311824.png" alt="image-20230214155311824">&lt;/p>
&lt;h2 id="观点-1">观点&lt;/h2>
&lt;p>大约和chatGPT玩了1小时，这就是第2个故事。对这个故事，我的观点如下：&lt;/p>
&lt;h3 id="1任务难度困难">(1)任务难度：困难&lt;/h3>
&lt;p>作为人类的我，在18年每天都在敲代码积累软件知识的前提下，需要花了4天时间去分析的源代码，应该不是个简单任务。&lt;/p>
&lt;h3 id="2值得关注的突破点学习速度惊人某些领域知识达到专业级">(2)值得关注的突破点：学习速度惊人，某些领域知识达到专业级。&lt;/h3>
&lt;p>记得有阵子一群人吐槽菊厂考试有JVM相关的题目，属于偏题怪题。&lt;/p>
&lt;p>暂不论这个人观点正确与否，至少证明这些吐槽的人类，对于JVM等编译器底层技术没有掌握和不愿了解的。&lt;/p>
&lt;p>为什么呢？因为人是趋利避害和功利性的。&lt;/p>
&lt;p>虽然理解编译器底层技术有助于写更好的代码，但这个知识难学且不影响每天搬砖，当然不会主动去学。&lt;/p>
&lt;p>然而，chatGPT毫不费劲地做到了。&lt;/p>
&lt;p>虽然，它做到的方式目前可能是机械式地&amp;rdquo;&lt;strong>搜索它的记忆&lt;/strong>&amp;quot;。&lt;/p>
&lt;p>虽然，它也可能&lt;strong>在用某种AI技巧，在答案中对我进行心理暗示、情感诱导&lt;/strong>。&lt;/p>
&lt;p>但，如果把chatGPT当做一种新的物种，从结果看：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>它的学习速度远超人类&lt;/strong>&lt;/li>
&lt;li>&lt;strong>我擅长的领域，它的未来却不可预期&lt;/strong>：某个领域的人类专家才能做到的高级任务，它至少能&lt;strong>装作&lt;/strong>也能完成。&lt;/li>
&lt;/ul>
&lt;h1 id="4第3个故事我有点笑不出来">4.第3个故事：我有点笑不出来&lt;/h1>
&lt;p>周六夜11点，忽然想到机器人学中有个算法问题，可以抽象如下：&lt;/p>
&lt;ul>
&lt;li>已知机器人要走的轨迹、初始速度、最大速度、最大加速度、最大减速度。&lt;/li>
&lt;li>希望算法进行路径规划和速度规划：汽车每时每刻的路径、速度and加速度。&lt;/li>
&lt;li>算法的规划结果要保证汽车最快到达终点、动作丝滑。&lt;/li>
&lt;/ul>
&lt;p>这个算法是机器人领域的关键算法，比如波士顿机器人：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/kaimen.gif" alt="kaimen">&lt;/p>
&lt;p>之前我对这个算法很感兴趣，断断续续也Google和图书馆查过一些论文，但仅获得了些许只言片语的信息——NURBS曲线、速度规划、路径规划。&lt;/p>
&lt;p>说白了，这是个&lt;strong>业务领域算法&lt;/strong>——这就意味着，你不是业内人士又没有明白人指路，学习效率就不会太高。&lt;/p>
&lt;p>我抱着试试看的心情问了chatGPT。。。然后。。。我就一发不可收拾地和它结对编程到了凌晨4点。&lt;/p>
&lt;h2 id="第1组问题">第1组问题&lt;/h2>
&lt;p>根据我之前的线索，我问了一下chatGPT，通过它的回答，我知道了更多知识线索，我感觉我遇到了1个不错的老师：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>NURBS算法&lt;/strong>：非均匀有理B样条。&lt;/li>
&lt;li>&lt;strong>算法能力&lt;/strong>：生成平滑轨迹、合理的加减速。&lt;/li>
&lt;li>&lt;strong>相关算法&lt;/strong>：S曲线速度规划&lt;/li>
&lt;li>&lt;strong>学习的方向&lt;/strong>：在计算机图形学、数值分析、数字信号处理等学科中，都可以获取到这个算法的更深入的知识。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214162853438.png" alt="image-20230214162853438">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214163155188.png" alt="image-20230214163155188">&lt;/p>
&lt;h2 id="第2组问题">第2组问题&lt;/h2>
&lt;p>我的第2组问题就是深入到算法的原理、依赖的数学理论，&lt;/p>
&lt;p>在接下来的2小时，chatGPT把线性插值法到B样条插值法都给我撸了一遍：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>插值的数学含义&lt;/strong>：已知有限的坐标点，自动生成N个坐标点，保证曲线是平滑的。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214171500079.png" alt="image-20230214171500079">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>插值的实际用途&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214171556561.png" alt="image-20230214171556561">&lt;/p>
&lt;ul>
&lt;li>它的回答有点像&lt;strong>插值&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214171714672.png" alt="image-20230214171714672">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>来吧，把各种插值法的数学公式都讲一遍&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214171848979.png" alt="image-20230214171848979">&lt;/p>
&lt;h2 id="第3组问题">第3组问题&lt;/h2>
&lt;p>&lt;code>Show me the code！&lt;/code>我只列举几个代码片段供大家感受：&lt;/p>
&lt;h3 id="代码片段1代码轮廓">代码片段1：代码轮廓&lt;/h3>
&lt;p>通过这段代码，我看到了&lt;strong>样条插值法的代码轮廓&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214163436511.png" alt="image-20230214163436511">&lt;/p>
&lt;h3 id="代码片段2我不知道的三方件">代码片段2：我不知道的三方件&lt;/h3>
&lt;p>代码片段2和代码片段1差不多，只不过是Java语言实现。&lt;/p>
&lt;p>但，这段代码用到了一个我没用过的三方件&lt;code>org.apache.common.math3&lt;/code>。&lt;/p>
&lt;p>这是一个亮点——原来有这么1个Java库，已经提供了很多基础的数学模型和算法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214172256770.png" alt="image-20230214172256770">&lt;/p>
&lt;h3 id="代码片段3增加速度规划">代码片段3：增加速度规划&lt;/h3>
&lt;p>我让chatGPT针对同一个问题，做了3次回答，每次回答不同。&lt;/p>
&lt;p>综合3次回答，可以得到我比较满意的答案：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第一次回答&lt;/strong>：业务流程说的很清楚，但是代码不太完整。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214172856207.png" alt="image-20230214172856207">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第二次回答&lt;/strong>：我知道了Apache的那个三方件中的&lt;code>SplineInterpolator&lt;/code>可以生成B样条曲线。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214172937781.png" alt="image-20230214172937781">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>第三个回答&lt;/strong>：业务流程和代码都相对完整。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214173043455.png" alt="image-20230214173043455">&lt;/p>
&lt;h3 id="代码片段n我和chatgpt的n次小迭代">代码片段N：我和chatGPT的N次小迭代&lt;/h3>
&lt;p>得到了这个我未知知识领域的业务算法的代码框架后，我试着在IDEA里运行，无法成功。&lt;/p>
&lt;p>有的函数有数组越界，有的函数参数个数不对。&lt;/p>
&lt;h4 id="迭代1对于明显的编译错误作为人类的我可以快速帮它修复">迭代1：对于明显的编译错误，作为人类的我可以快速帮它修复。&lt;/h4>
&lt;p>迭代1主要是我在工作，修复后，剩下的代码问题只剩下我不太理解的算法逻辑了。&lt;/p>
&lt;h4 id="迭代2漏写了一个算法相关的函数它补充了">迭代2：漏写了一个算法相关的函数，它补充了。&lt;/h4>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214173941576.png" alt="image-20230214173941576">&lt;/p>
&lt;h4 id="迭代3请注意我的问题并没有指出具体是什么错误它自己分析出来代码错在哪里了">迭代3：请注意我的问题并没有指出具体是什么错误，它自己分析出来代码错在哪里了。&lt;/h4>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214174016136.png" alt="image-20230214174016136">&lt;/p>
&lt;h4 id="迭代4由于chatgpt网站限制无法返回超长代码片段导致看不到完整代码于是我要求它想办法精简代码">迭代4：由于chatGPT网站限制(无法返回超长代码片段)，导致看不到完整代码，于是我要求它想办法精简代码。&lt;/h4>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214174356129.png" alt="image-20230214174356129">&lt;/p>
&lt;h4 id="迭代n经过4个小时不断的交互1个基础的机器人运动规划算法代码跑通了">迭代N：经过4个小时不断的交互，1个基础的机器人运动规划算法代码跑通了&lt;/h4>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/image-20230214174756076.png" alt="image-20230214174756076">&lt;/p>
&lt;h2 id="观点-2">观点&lt;/h2>
&lt;p>第3个故事结束的时候，是周六的凌晨4点，我对这个故事的观点：&lt;/p>
&lt;h3 id="1工作难度超难">(1)工作难度：超难。&lt;/h3>
&lt;p>这个任务我不会，甚至我都查不到资料找不到头绪。&lt;/p>
&lt;h3 id="2值得关注的突破点chatgpt可能变成人类的师傅此时人类仅仅是个学徒小工辅助">(2)值得关注的突破点：chatGPT可能变成人类的师傅，此时人类仅仅是个学徒、小工、辅助。&lt;/h3>
&lt;p>人类在某个领域是专家，在大部分领域是不擅长的。&lt;/p>
&lt;p>而chatGPT可能变成人类的师傅，此时人类仅仅是个学徒、小工、辅助。&lt;/p>
&lt;h1 id="5看到未来">5.看到未来&lt;/h1>
&lt;p>三个故事经历完，已经是周日的凌晨4点，我从窗口已经能看到东湖的星星点点。&lt;/p>
&lt;p>国内对于chatGPT，已经热闹了一两个月。&lt;/p>
&lt;p>有的人通过卖账号已经赚了一波，有的人做套壳儿GPT也骗走了不少流量。&lt;/p>
&lt;p>师傅说：我们的孩子还在学怎么用这些底层技术，别人的孩子已经在发明这些底层技术了。&lt;/p>
&lt;p>当喧嚣散尽时，我们还会留下什么？&lt;/p>
&lt;p>自媒体上对chatGPT有无数的测评，无论从商业前景、应用场景、技术原理等哪种角度，都是那两派：&lt;strong>&amp;ldquo;吹捧派&amp;rdquo;&lt;strong>和&lt;/strong>&amp;ldquo;唱衰派&amp;rdquo;&lt;/strong>。&lt;/p>
&lt;p>我不想夸大chatGPT，也不想盲目自大地轻视它，这6个小时，我仅仅是一个观察者。&lt;/p>
&lt;p>通过这6个小时的结对编程和观察，我有点震撼，这也可能是心理学问题：&lt;/p>
&lt;ul>
&lt;li>第1个故事，那不过是个简单的工作，花点时间我必定能完成——&lt;strong>AI能完成，行吧，你还不错&lt;/strong>。&lt;/li>
&lt;li>第2个故事，那是我的专业领域，其他人类未必能比我完成的好——&lt;strong>AI竟然能完成，我感受到被冒犯、我有了危机感&lt;/strong>。&lt;/li>
&lt;li>第3个故事，那是我的盲区，我努力过但没成功——&lt;strong>AI指导我完成了，此刻好像我知道了三体文明的存在，我没有啥反抗的机会&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>我也不知道chatGPT到底会怎样，但我感觉它和过往的AI技术不一样。&lt;/p>
&lt;p>&lt;strong>它应该不是AI历史中的一点涟漪，而是人类历史的某个里程碑&lt;/strong>。&lt;/p>
&lt;p>2019年12月6日，老爸脑梗进了ICU，守在ICU门口的那段时光，我很想做一个&lt;strong>数字老爸&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>把亲人的文字、资料、语音、照片录入到云端。&lt;/li>
&lt;li>通过某种AI技术训练出能复现亲人的模型——chatGPT看起来似乎可以做到。&lt;/li>
&lt;li>集成一些相对成熟的工程技术(如：文字转语音、VR、AR)&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>经历过ICU门口的人应该能感同身受，只不过我这个工科脑袋有点跳脱，但或许这就是未来。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/AI%E6%8B%BE%E9%81%97/%E3%80%90chatGPT%E3%80%91%E5%92%8CchatGPT%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B%E7%9A%846%E5%B0%8F%E6%97%B6/Future.png" alt="Future">&lt;/p></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-3</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-3/</link><pubDate>Sat, 11 Feb 2023 08:07:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-3/</guid><description>&lt;p>接上文《【运行时数据区】-并发编程-前置知识(4.并发编程基础)-2》，我们得到了2个推论，并且证明了推论1：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推论1&lt;/strong>：&lt;strong>此线程非彼线程&lt;/strong>——JVM层的线程应该是Java线程，操作系统层的线程是真正的系统线程。&lt;/li>
&lt;li>&lt;strong>推论2&lt;/strong>：&lt;strong>此线程与彼线程之间应该存在某种映射关系&lt;/strong>——JVM层的线程，与操作系统层的系统线程之间，应该存在某种映射关系。&lt;/li>
&lt;/ul>
&lt;p>本文跟踪&amp;rdquo;&lt;strong>JVM启动后，产生的JVM侧的main线程与java侧的main线程&lt;/strong>&amp;ldquo;的代码，来分析推论2。&lt;/p>
&lt;h1 id="1jvm相关的代码">1.JVM相关的代码&lt;/h1>
&lt;p>JVM启动后，会产生如下现象：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>JVM本身会产生一系列的系统线程，其中1个线程表示JVM进程的main线程，这个可以通过操作系统层的工具观测到。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JVM在产生操作系统层面的main线程时，会在Java层产生对等的main线程，这个可以通过JDK的工具观测到。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>与上述流程相关的JVM源码，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211163049820.png" alt="image-20230211163049820">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>main.c&lt;/strong>：JVM的入口模块&lt;/li>
&lt;li>&lt;strong>javac.c&lt;/strong>：提供了java相关的接口&lt;/li>
&lt;li>&lt;strong>java_md_solinux.c&lt;/strong>：可以简单地认为是java.c中一系列接口在Linux操作系统的实现*(为聚焦本文关注点，简化描述但不严谨)*&lt;/li>
&lt;li>&lt;strong>jni.cpp&lt;/strong>：JVM层(C++语言实现)与JDK层(Java语言实现)之间的接口
&lt;ul>
&lt;li>比如：JDK中很多native接口，可以认为是JVM层与JDK层之间的接口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>thread.cpp&lt;/strong>：提供了线程的CRUD相关的接口&lt;/li>
&lt;li>&lt;strong>os_linux.cpp&lt;/strong>：可以简单地认为是thread.cpp中一系列接口在Linux操作系统的实现*(为聚焦本文关注点，简化描述但不严谨)*&lt;/li>
&lt;li>&lt;strong>vmThread.cpp&lt;/strong>：比较杂，可以认为是辅助的线程管理模块&lt;/li>
&lt;li>&lt;strong>java_md_common.c&lt;/strong>：比较杂，可以认为是诸如解析java.exe的命令行参数解析等的辅助功能*(为聚焦本文关注点，简化描述但不严谨)&lt;/li>
&lt;/ul>
&lt;h1 id="2jvm的开始-main函数">2.JVM的开始-main函数&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>关键源码&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211163936994.png" alt="image-20230211163936994">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代码解读：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>JVM的入口&lt;/strong>：main.c中有&lt;code>main&lt;/code>函数，这就是JVM的入口&lt;/li>
&lt;li>&lt;strong>&lt;code>main&lt;/code>函数的主体代码不关键&lt;/strong>：&lt;code>main&lt;/code>函数主体代码就是适配不同操作系统的业务逻辑，这部分不关键&lt;/li>
&lt;li>&lt;strong>&lt;code>main&lt;/code>函数最后1行代码是关键&lt;/strong>：调用了java.c的&lt;code>JLI_launch&lt;/code>函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>小结&lt;/strong>：从这一段代码我们可以覆盖了下图红框中的流程&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211164732122.png" alt="image-20230211164732122">&lt;/p>
&lt;h1 id="3初现端倪-jli_launch函数">3.初现端倪-JLI_Launch函数&lt;/h1>
&lt;h2 id="31jli_launch函数主流程">3.1.JLI_Launch函数主流程&lt;/h2>
&lt;ul>
&lt;li>&lt;code>JLI_Launch&lt;/code>函数的主流程如下图红色线：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211165705460.png" alt="image-20230211165705460">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>流程粗读&lt;/strong>：笔者先宏观性地理解一下上述流程
&lt;ul>
&lt;li>&lt;strong>流程开始&lt;/strong>：JVM的&lt;code>main&lt;/code>函数初始化JVM的环境，这部分在整体流程中属于&lt;strong>辅助流程&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>流程核心1&lt;/strong>：加载真正的JVM，JVM核心代码是编译到&lt;code>libjvm.so&lt;/code>中的，这部分是整体流程的&lt;strong>重要流程&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>辅助流程&lt;/strong>：完成&lt;strong>流程核心1&lt;/strong>后，JVM做了一些辅助任务，这部分是整体流程的&lt;strong>辅助流程&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>流程核心2&lt;/strong>：创建新的线程，这部分也是整体流程的&lt;strong>重要流程&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="32初始化执行环境">3.2.初始化执行环境&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关键代码&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211165052590.png" alt="image-20230211165052590">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211171604091.png" alt="image-20230211171604091">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码解读&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在&lt;code>CreateExecutionEnvironment&lt;/code>函数位于&lt;code>java_md_solinux.c&lt;/code>中。&lt;/li>
&lt;li>此函数检索并判断jre的路径、libjvm.so路径、jvm.cfg路径。jre是大家比较熟悉的，我们来看看libjvm.so和jvm.cfg&lt;/li>
&lt;li>jvm的核心代码被编译到libjvm.so中，以动态库的形式提供给JVM各模块调用。&lt;/li>
&lt;li>jvm.cfg内容如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211171140542.png" alt="image-20230211171140542">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>小结&lt;/strong>：这部分流程不太关键，快速了解即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211171303745.png" alt="image-20230211171303745">&lt;/p>
&lt;h2 id="33加载jvm">3.3.加载JVM&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关键代码&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211171659120.png" alt="image-20230211171659120">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211171711846.png" alt="image-20230211171711846">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码解读&lt;/strong>：在java_md_solinux.c的&lt;code>LoadJavaVM&lt;/code>函数有关键的2步&lt;/p>
&lt;ul>
&lt;li>关键1：通过&lt;code>dlopen&lt;/code>函数加载&lt;code>libjvm.so&lt;/code>动态库。&lt;/li>
&lt;li>关键2：通过&lt;code>dlsym&lt;/code>函数确认并获得&lt;code>libjvm.so&lt;/code>中的3个函数句柄，通过这3个函数句柄的名字大致可知是对JVM的创建和获取：
&lt;ul>
&lt;li>JNI_CreateJavaVM&lt;/li>
&lt;li>JNI_GetDefaultJavaVMInitArgs&lt;/li>
&lt;li>JNI_GetCreatedJavaVMs&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>小结：此段流程是后续流程的基础，可以跟踪一下JVM源码详细理解一下：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211172256201.png" alt="image-20230211172256201">&lt;/p>
&lt;h2 id="34javaexe的参数配置等辅助设置">3.4.java.exe的参数/配置等辅助设置&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关键代码&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211172956425.png" alt="image-20230211172956425">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211173009296.png" alt="image-20230211173009296">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211173022693.png" alt="image-20230211173022693">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211173033605.png" alt="image-20230211173033605">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211173046878.png" alt="image-20230211173046878">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211173056715.png" alt="image-20230211173056715">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>代码解读&lt;/strong>：这部分代码属于辅助流程，根据上述代码截图，基本可以自行理解，此处不赘述&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>小结&lt;/strong>：代码阅读理解到这里，我们当前在流程的这个地方(下图红线处)：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211173252080.png" alt="image-20230211173252080">&lt;/p>
&lt;h2 id="34创建新线程">3.4.创建新线程&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关键代码&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211222347685.png" alt="image-20230211222347685">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211222409464.png" alt="image-20230211222409464">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211223134192.png" alt="image-20230211223134192">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>代码解读&lt;/strong>：
&lt;ul>
&lt;li>当流程执行到java_md_solinux.c的&lt;code>JVMInit&lt;/code>函数时，内部会调用java.c的&lt;code>ContinueInNewThread&lt;/code>函数&lt;/li>
&lt;li>java.c的&lt;code>ContinueInNewThread&lt;/code>函数会调用java_md_solinux.c的&lt;code>ContinueInNewThread&lt;/code>函数&lt;/li>
&lt;li>java_md_solinux.c的&lt;code>ContinueInNewThread0&lt;/code>函数的内部实现便是创建系统线程、Java线程的关键点了
&lt;ul>
&lt;li>此函数调用&lt;code>pthread&lt;/code>库函数，创建Linux上的系统线程，这个就是JVM进程中的main线程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>小结&lt;/strong>：本章节解读到下图红色线的流程，至此，我们就找到了JVM启动时与main线程创建的入口了&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211222315626.png" alt="image-20230211222315626">&lt;/p>
&lt;h1 id="4平行世界-javamain">4.平行世界-JavaMain&lt;/h1>
&lt;p>根据第3章节，JVM会创建系统线程&lt;code>main&lt;/code>，而&lt;code>main&lt;/code>线程的线程回调函数就是&lt;code>JavaMain&lt;/code>函数，从这个函数名我们大致可以猜测这个函数就代表在JVM层面看到的Java代码层的包含main函数的主类。&lt;/p>
&lt;p>我们接下来详细分析一下&lt;code>JavaMain&lt;/code>函数：&lt;/p>
&lt;h2 id="41jvm创建javathread对象">4.1.JVM创建JavaThread对象&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关键流程&lt;/strong>：这条调用链比较复杂，也很关键，关键就在这里：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211232016635.png" alt="image-20230211232016635">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>java.c的JavaMain()函数&lt;/strong>：调用&lt;code>InitializeVM&lt;/code>函数&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211230147509.png" alt="image-20230211230147509">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>java.c的InitializeJVM()&lt;/strong>： 调用jni.cpp的JNI_CreateJavaVM函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211230950971.png" alt="image-20230211230950971">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211231011066.png" alt="image-20230211231011066">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>jni.cpp的JNI_CreateJavaVM()&lt;/strong>：调用thread.cpp的Threads::create_vm()&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211231026944.png" alt="image-20230211231026944">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>thread.cpp的Threads::create_vm()&lt;/strong>：这里JVM创建了名为&lt;code>JavaThread&lt;/code>的对象，这个对象表示站在JVM层维护的Java线程对象。
&lt;ul>
&lt;li>这个对象表示Java代码层的&lt;code>main&lt;/code>线程。&lt;/li>
&lt;li>创建了这个对象后，调用了thread.cpp的&lt;code>set_as_starting_thread()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211231105900.png" alt="image-20230211231105900">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211231140633.png" alt="image-20230211231140633">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>thread.cpp的&lt;code>set_as_starting_thread()&lt;/code>&lt;/strong>：调用os_linux.cpp的&lt;code>create_main_thread()&lt;/code>，传入创建好的&lt;code>JavaThread&lt;/code>对象。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211232635496.png" alt="image-20230211232635496">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>os_linux.cpp的&lt;code>create_main_thread()&lt;/code>&lt;/strong>：调用os_linux.cpp的&lt;code>create_attached_thread()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211232726011.png" alt="image-20230211232726011">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>os_linux.cpp的&lt;code>create_attached_thread()&lt;/code>&lt;/strong>：创建&lt;code>OSThread&lt;/code>对象，记录当前所在的线程对象记录到&lt;code>OSThread&lt;/code>对象中，
&lt;ul>
&lt;li>当前所在的线程对象就是&lt;strong>第3章中讲到的JVM层的系统线程&lt;code>main&lt;/code>线程&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211232855155.png" alt="image-20230211232855155">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>小结&lt;/strong>：此时在JVM层，已经在操作系统层面创建了2个线程，1个线程是JVM进程自身的主线程，另1个线程就是JVM为Java代码的&lt;code>main&lt;/code>线程创建的操作系统线程。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211233412288.png" alt="image-20230211233412288">&lt;/p>
&lt;h2 id="42jvm创建java代码侧的java线程">4.2.JVM创建Java代码侧的Java线程&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>关键流程&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211233551236.png" alt="image-20230211233551236">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>thread.cpp的&lt;code>create_initial_thread()&lt;/code>&lt;/strong>：JVM通过JNI，创建JDK的&lt;code>java.lang.Thread&lt;/code>类的&lt;code>klass&lt;/code>对象，进而创建了Java代码侧的&lt;code>java.lang.Thread&lt;/code>对象，最后将这个&lt;code>klass&lt;/code>对象设置到&lt;code>OSThread&lt;/code>对象中。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211233920369.png" alt="image-20230211233920369">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>小结&lt;/strong>：至此，站在JVM层，JVM维护了1个&lt;code>OSThread&lt;/code>对象，这个对象中维护&lt;strong>Java的&lt;code>main&lt;/code>线程对象&lt;/strong>和&lt;strong>系统线程对象&lt;/strong>
&lt;ul>
&lt;li>Java的&lt;code>main&lt;/code>线程对象：
&lt;ul>
&lt;li>在Java代码侧，Java程序猿看到的是&lt;code>java.lang.Thread&lt;/code>对象&lt;/li>
&lt;li>在JVM侧，对应的就是&lt;code>klass&lt;/code>对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="5总结">5.总结&lt;/h1>
&lt;p>回到本文一开始的2个推论：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推论1&lt;/strong>：&lt;strong>此线程非彼线程&lt;/strong>——JVM层的线程应该是Java线程，操作系统层的线程是真正的系统线程。&lt;/li>
&lt;li>&lt;strong>推论2&lt;/strong>：&lt;strong>此线程与彼线程之间应该存在某种映射关系&lt;/strong>——JVM层的线程，与操作系统层的系统线程之间，应该存在某种映射关系。&lt;/li>
&lt;/ul>
&lt;p>本文跟踪了JVM创建Java进程的&lt;code>main&lt;/code>线程的全流程，可以将推论2进一步明确：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推论2(New)&lt;/strong>：从JVM层观测到的线程是Java代码层的Java线程，从操作系统层观测到的JVM层相关的系统线程中，有1个系统线程就对应Java层的Java线程。
&lt;ul>
&lt;li>JVM层用1个&lt;code>OSThread&lt;/code>对象维护了&lt;code>pthread&lt;/code>创建的系统线程和对应的&lt;code>java.lang.Thread&lt;/code>的&lt;code>klass&lt;/code>对象。&lt;/li>
&lt;li>JVM层的&lt;code>java.lang.Thread&lt;/code>的&lt;code>klass对象&lt;/code>在Java层还对应1个&lt;code>java.lang.Thread&lt;/code>对象，这两个对象在各自的层次中表示Java线程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230211234854597.png" alt="image-20230211234854597">&lt;/p>
&lt;h1 id="6感慨知识的尽头">6.感慨：知识的尽头&lt;/h1>
&lt;p>玩了1个多月chatGPT，刚开始只认为它不过是AI发展史中的涟漪，谁知chatGPT可能是历史的某个里程碑：&lt;/p>
&lt;ul>
&lt;li>笔者在软件行业从业有18年，初次阅读并梳理本文涉及到的&amp;quot;JVM的Java线程与操作系统线程的关系&amp;quot;大约花了4天的时间&lt;/li>
&lt;li>出于好奇，把这个问题抛给了chatGPT，愕然！&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>经常感慨计算机世界的知识浩渺无尽，自己却那般无知渺小。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>随着文明的发展，浩渺无尽是相对的，对于我是无尽，对于AI可能是有穷。&lt;/strong>&lt;/p>
&lt;p>附上&lt;strong>chatGPT对Java主线程与系统线程关系&lt;/strong>的答案：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-3/image-20230212001032910.png" alt="image-20230212001032910">&lt;/p></description></item><item><title>【SpringOne 2022】4.Running Untrusted Code in Spring Using WebAssembly</title><link>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20224.running-untrusted-code-in-spring-using-webassembly/</link><pubDate>Thu, 09 Feb 2023 10:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20224.running-untrusted-code-in-spring-using-webassembly/</guid><description>&lt;p>SpringOne 2022第4个议题《Running Untrusted Code in Spring Using WebAssembly》，主要在介绍WebAssembly的Host和Guest，引申出Spring结合WebAssembly的一些展望，演讲者：Dave Syer。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209102504607.png" alt="image-20230209102504607">&lt;/p>
&lt;h1 id="1what-is-webassembly">1.What is WebAssembly?&lt;/h1>
&lt;ul>
&lt;li>WebAssembly有两个概念&lt;code>Host&lt;/code>和&lt;code>Guest&lt;/code>:
&lt;ul>
&lt;li>&lt;code>Host&lt;/code>可以认为是能够执行WebAssembly的容器，比如：浏览器。&lt;/li>
&lt;li>&lt;code>Guest&lt;/code>就是&lt;code>WASM&lt;/code>(WebAssembly)，我们可以直接编写&lt;code>WASM&lt;/code>，也可以用C/C#/AssemblyScript/Rust这些语言去写再编译成&lt;code>WASM&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209104158257.png" alt="image-20230209104158257">&lt;/p>
&lt;ul>
&lt;li>WebAssembly的语言规范在此：
&lt;ul>
&lt;li>&lt;a href="https://github.com/WebAssembly/spec">https://github.com/WebAssembly/spec&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209104813110.png" alt="image-20230209104813110">&lt;/p>
&lt;ul>
&lt;li>其它说明：
&lt;ul>
&lt;li>由于&lt;code>WASM&lt;/code>主要的应用场景是在浏览器领域，所以&lt;code>JavaScript&lt;/code>是比较主流的&lt;code>Host&lt;/code>编程语言。&lt;/li>
&lt;li>其它&lt;code>Host&lt;/code>编程语言还有Rust、Go、Python、C#、Java等等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="2wasm与spring可以结合的应用场景">2.WASM与Spring可以结合的应用场景&lt;/h1>
&lt;ul>
&lt;li>Serverless(无服务器)架构是云原生领域比较受欢迎的理念，其核心目的是增效降本。如下图：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209111925644.png" alt="image-20230209111925644">&lt;/p>
&lt;ul>
&lt;li>Serverless架构提供一种更加&amp;quot;代码碎片化&amp;quot;的软件架构范式——&lt;code>FAAS(Function as a Services)&lt;/code>，以Amazon Lambda为例：
&lt;ul>
&lt;li>&lt;code>AWS Lambda&lt;/code>可以作为&lt;code>Host&lt;/code>执行&lt;strong>用户提交的函数&lt;/strong>——这个可以认为是&lt;code>Guest&lt;/code>侧的代码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209112437086.png" alt="image-20230209112437086">&lt;/p>
&lt;ul>
&lt;li>通过对&lt;code>Serverless&lt;/code>/&lt;code>FAAS&lt;/code>的介绍，我们可以看到可以基于&lt;code>Spring&lt;/code>+&lt;code>WASM&lt;/code>快速实现&lt;code>FAAS&lt;/code>：
&lt;ul>
&lt;li>STEP1.用户用自己擅长的编程语言实现的&lt;code>Guest&lt;/code>代码&lt;/li>
&lt;li>STEP2.用户提交这段&lt;code>Guest&lt;/code>代码，提交时被编译为&lt;code>WASM&lt;/code>&lt;/li>
&lt;li>STEP3.&lt;code>Spring&lt;/code>实现的云端微服务执行STEP2的&lt;code>WASM&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="3一个简单的demo">3.一个简单的Demo&lt;/h1>
&lt;ul>
&lt;li>演讲者编写了1个简单的&lt;code>WASM&lt;/code>，
&lt;ul>
&lt;li>此&lt;code>WASM&lt;/code>实现了1个名为&lt;code>add&lt;/code>的函数&lt;/li>
&lt;li>&lt;code>add&lt;/code>函数包含2个入参，入参都是整型(&lt;code>i32&lt;/code>)&lt;/li>
&lt;li>&lt;code>add&lt;/code>函数返回整型(&lt;code>i32&lt;/code>)&lt;/li>
&lt;li>add函数的内部实现是将2个入参相加&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209142449065.png" alt="image-20230209142449065">&lt;/p>
&lt;ul>
&lt;li>演讲者的使用MDN提供的测试工具作为&lt;code>Host&lt;/code>执行上述&lt;code>WASM&lt;/code>，JavaScript代码如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209142856947.png" alt="image-20230209142856947">&lt;/p>
&lt;h1 id="4wasm的guest端可选的编程语言">4.&lt;code>WASM&lt;/code>的&lt;code>Guest&lt;/code>端可选的编程语言&lt;/h1>
&lt;h2 id="41c语言">4.1.C语言&lt;/h2>
&lt;ul>
&lt;li>使用C语言编写如下代码：
&lt;ul>
&lt;li>函数&lt;code>echo&lt;/code>返回整型，内部实现是调用函数&lt;code>get&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>将C语言编译成&lt;code>WASM&lt;/code>的可选工具如下：
&lt;ul>
&lt;li>Emscripten&lt;/li>
&lt;li>Wasi SDK&lt;/li>
&lt;li>Binaryen&lt;/li>
&lt;li>LLVM/Clang&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209143034320.png" alt="image-20230209143034320">&lt;/p>
&lt;ul>
&lt;li>编译后得到的&lt;code>WASM&lt;/code>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209143359629.png" alt="image-20230209143359629">&lt;/p>
&lt;h2 id="42assemblyscript">4.2.AssemblyScript&lt;/h2>
&lt;ul>
&lt;li>使用TypeScript编写如下代码：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209143514050.png" alt="image-20230209143514050">&lt;/p>
&lt;ul>
&lt;li>编译后得到的&lt;code>WASM&lt;/code>很长，在此仅展示部分。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209144136043.png" alt="image-20230209144136043">&lt;/p>
&lt;h2 id="43rust">4.3.Rust&lt;/h2>
&lt;ul>
&lt;li>使用Rust编写的代码如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209144304144.png" alt="image-20230209144304144">&lt;/p>
&lt;h2 id="44java">4.4.Java&lt;/h2>
&lt;ul>
&lt;li>使用Java编写的代码如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209144431808.png" alt="image-20230209144431808">&lt;/p>
&lt;ul>
&lt;li>可选的编译器如下：
&lt;ul>
&lt;li>TeamVM&lt;/li>
&lt;li>JSweet&lt;/li>
&lt;li>J2cl&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="5wasm的host端可选的编程语言">5.&lt;code>WASM&lt;/code>的&lt;code>Host&lt;/code>端可选的编程语言&lt;/h1>
&lt;h2 id="51javascript">5.1.JavaScript&lt;/h2>
&lt;ul>
&lt;li>使用JavaScript执行&lt;code>WASM&lt;/code>的代码如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209144643281.png" alt="image-20230209144643281">&lt;/p>
&lt;h2 id="52java">5.2.Java&lt;/h2>
&lt;ul>
&lt;li>使用Java执行&lt;code>WASM&lt;/code>的代码如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%914.RunningUntrustedCodeinSpringUsingWebAssembly/image-20230209144755430.png" alt="image-20230209144755430">&lt;/p>
&lt;h1 id="6小结">6.小结&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;code>WASM&lt;/code>还在发展阶段，有的人看好，有的人认为是伪命题，但&lt;code>WASM&lt;/code>肯定会是未来3~5年的热点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>WASM&lt;/code>可应用的场景绝对不是在浏览器里运行对GPU有要求的游戏，云原生领域也可能应用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Spring团队也在探索性地将某些模块使用&lt;code>WASM&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>【SpringOne 2022】3.Protect Your Microservices with Spring Cloud Gateway</title><link>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20223.protect-your-microservices-with-spring-cloud-gateway/</link><pubDate>Tue, 07 Feb 2023 10:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20223.protect-your-microservices-with-spring-cloud-gateway/</guid><description>&lt;p>SpringOne 2022第3个议题《Protect Your Microservices with Spring Cloud Gateway》，主要展示Spring Cloud Gateway的特性，演讲者：Cora lberkleid。&lt;/p>
&lt;h1 id="1项目简介">1.项目简介&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>&lt;code>Spring Cloud Gateway&lt;/code>不是一个新项目&lt;/strong>：它能入选&lt;code>SpringOne 2022&lt;/code>的议题，应该是它的确非常实用。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>PS：SpringOne的每个议题不一定都是讲新技术，演讲者也很接地气(不太甩大词和抛概念)，赞！&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>&lt;code>Spring Cloud Gateway&lt;/code>的架构地位&lt;/strong>：在整个架构中的位置是&lt;code>API网关&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207101213825.png" alt="image-20230207101213825">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Spring Cloud Gateway的愿景&lt;/strong>：议题材料中有一段话，表明了此项目的愿景和价值，如下图：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207103316835.png" alt="image-20230207103316835">&lt;/p>
&lt;h1 id="2基本原理">2.基本原理&lt;/h1>
&lt;h2 id="21职责">2.1.职责&lt;/h2>
&lt;p>Gateway的本质就是一组&lt;strong>路由转发规则集&lt;/strong>+&lt;strong>按规则进行路由转发&lt;/strong>：&lt;/p>
&lt;p>即，当Gateway发现：&lt;strong>如果&lt;/strong>调用方的请求满足某些条件，&lt;strong>则&lt;/strong>在路由转发过程中do something。&lt;/p>
&lt;p>其中，&lt;code>在路由转发过程中do something&lt;/code>具备如下大颗粒的能力：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>熔断&lt;/strong>：集成 Hystrix 断路器。&lt;/li>
&lt;li>&lt;strong>动态路由&lt;/strong>&lt;/li>
&lt;li>&lt;strong>限流&lt;/strong>&lt;/li>
&lt;li>&lt;strong>请求修改&lt;/strong>：修改请求的输入输出、路径重写等。&lt;/li>
&lt;li>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207105042685.png" alt="image-20230207105042685">&lt;/p>
&lt;h2 id="22how-it-works">2.2.How it works?&lt;/h2>
&lt;ul>
&lt;li>Gateway提出了3个架构概念&lt;code>Route(路由)&lt;/code>、&lt;code>Predicate(断言)&lt;/code>、&lt;code>Filter(过滤器)&lt;/code>。&lt;/li>
&lt;li>这3个架构概念的关系是：1个&lt;code>Route(路由)&lt;/code>配置=N个&lt;code>Predicate(断言)&lt;/code>+N个&lt;code>Filter(过滤器)&lt;/code>+1个&lt;code>URI&lt;/code>。&lt;/li>
&lt;li>路由匹配和路由转发的过程：
&lt;ul>
&lt;li>STEP1.Gateway拦截到Client侧的请求。&lt;/li>
&lt;li>STEP2.用STEP1拦截到的请求去匹配&lt;code>Route(路由)&lt;/code>中的&lt;code>Predicate(断言)&lt;/code>。&lt;/li>
&lt;li>STEP3.如果STEP2成功匹配到某个&lt;code>Route(路由)&lt;/code>配置，则将STEP1拦截到的请求转发到该&lt;code>Route(路由)&lt;/code>配置中的URI上。&lt;/li>
&lt;li>STEP4.在转发到目标URI的过程中，执行该&lt;code>Route(配置)&lt;/code>中的N个&lt;code>Filter(过滤器)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="3demo">3.Demo&lt;/h1>
&lt;p>演讲人Cora lberkleid现场演示了如何使用&lt;code>Spring Cloud Gateway&lt;/code>快速开发1个API网关，Demo的代码地址：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/ciberkleid/spring-cloud-gateway-sample">https://github.com/ciberkleid/spring-cloud-gateway-sample&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="31一个简单的route配置">3.1.一个简单的Route配置&lt;/h2>
&lt;ul>
&lt;li>演讲人首先展示了一个简单的Route配置：
&lt;ul>
&lt;li>Path=/uuid：这个断言表示客户端请求为&lt;code>http://localhost/uuid&lt;/code>时，则匹配成功。&lt;/li>
&lt;li>uri=https://httpbin.org：表示断言匹配成功后，将客户端请求转发到&lt;code>https://httpbin.org&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207111959581.png" alt="image-20230207111959581">&lt;/p>
&lt;p>如下是执行效果：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207114627396.png" alt="image-20230207114627396">&lt;/p>
&lt;h2 id="32host断言">3.2.Host断言&lt;/h2>
&lt;ul>
&lt;li>红框：在3.1的配置基础上增加了Host断言，表示客户端请求为&lt;code>http://localhost/uuid&lt;/code>，且http的Host=example.com，则匹配成功。&lt;/li>
&lt;li>绿框：演示了客户端请求虽然是&lt;code>http://localhost/uuid&lt;/code>但Host没有值时，无法匹配，进而转发失败。&lt;/li>
&lt;li>蓝框：演示了客户端请求是&lt;code>http://localhost/uuid&lt;/code>且Host=example.com时，成功匹配，进而转发成功。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207114804353.png" alt="image-20230207114804353">&lt;/p>
&lt;h2 id="33转发过滤器">3.3.转发过滤器&lt;/h2>
&lt;ul>
&lt;li>SetPath=/uuid：表示客户端请求&lt;code>http://localhost/demo&lt;/code>，Gateway会将此请求转发为&lt;code>http://httpbin.org/uuid&lt;/code>&lt;/li>
&lt;li>测试结果如下：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207135559062.png" alt="image-20230207135559062">&lt;/p>
&lt;h2 id="34灰度发布">3.4.灰度发布&lt;/h2>
&lt;ul>
&lt;li>Gateway支持设置路由的权重，进而实现灰度发布。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207140904664.png" alt="image-20230207140904664">&lt;/p>
&lt;ul>
&lt;li>演讲人演示了配置了两个&lt;code>Route&lt;/code>，如果将&lt;code>route1&lt;/code>的&lt;code>Weight&lt;/code>属性改小，将会引流到&lt;code>route2&lt;/code>，进而实现灰度发布。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207141250833.png" alt="image-20230207141250833">&lt;/p>
&lt;h2 id="35熔断">3.5.熔断&lt;/h2>
&lt;ul>
&lt;li>Demo中，熔断器定义5秒内接口必须返回。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207142305789.png" alt="image-20230207142305789">&lt;/p>
&lt;ul>
&lt;li>配置文件中，使能熔断器&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207142345120.png" alt="image-20230207142345120">&lt;/p>
&lt;ul>
&lt;li>执行效果：
&lt;ul>
&lt;li>红框：如果接口在4秒内返回，Gateway正常响应&lt;/li>
&lt;li>绿框：如果接口在10秒才能返回，Gateway熔断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%913.ProtectYourMicroserviceswithSpringCloudGateway/image-20230207142641006.png" alt="image-20230207142641006">&lt;/p>
&lt;h1 id="4总结">4.总结&lt;/h1>
&lt;ul>
&lt;li>在本议题，演讲者Cora lberkleid展示了&lt;code>Spring Cloud Gateway&lt;/code>的原理和Demo。&lt;/li>
&lt;li>&lt;code>Spring Cloud Gateway&lt;/code>采用&amp;rdquo;&lt;strong>断言=&amp;gt;过滤器链=&amp;gt;转发&lt;/strong>&amp;ldquo;的思想实现了API网关，开发效率不错。&lt;/li>
&lt;/ul></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-2</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-2/</link><pubDate>Sat, 04 Feb 2023 08:07:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-2/</guid><description>&lt;h1 id="1为什么要理解进程与线程的关系">1.为什么要理解进程与线程的关系？&lt;/h1>
&lt;blockquote>
&lt;p>A process will contain at least one thread, which is created to execute the point of entry of the application.&lt;/p>
&lt;p>Usually this entry point is the main() function of the application.&lt;/p>
&lt;/blockquote>
&lt;p>引用《Learning Concurrency in Kotlin》书中的一段话，它阐述了进程与线程的关系。&lt;/p>
&lt;p>为什么要理解进程与线程的关系呢？因为理解了进程与线程的关系有利于我们定位问题。&lt;/p>
&lt;p>比如：当生产环境出现高CPU占用时，我们通常需要先找到高CPU占用的进程，再找到该进程下高CPU占用的线程。&lt;/p>
&lt;h1 id="2一个java进程会产生几个线程">2.一个Java进程，会产生几个线程?&lt;/h1>
&lt;p>我们回到Java本身，我们引出这样1个问题：&lt;strong>执行&amp;quot;1个Java进程，会产生几个线程呢？&amp;quot;&lt;/strong>&lt;/p>
&lt;p>我们有2种方式观测：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从JVM层观测&lt;/strong>：通过JDK自带的工具(如：jps、jstack等)，通过IDE的调试工具(如：IDEA的debug视图)。&lt;/li>
&lt;li>&lt;strong>从操作系统层观测&lt;/strong>：通过操作系统工具(如：ps、top等)&lt;/li>
&lt;/ul>
&lt;h1 id="3从jvm层观测">3.从JVM层观测&lt;/h1>
&lt;h2 id="31测试代码">3.1.测试代码&lt;/h2>
&lt;p>首先，我们先用一段简单的代码——这段代码只有1个main函数，main函数中打印了&lt;code>Hello world...&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230203165720496.png" alt="image-20230203165720496">&lt;/p>
&lt;p>我们在IDEA中做个测试——在14行处打个断点，测试结果可以看到有该Java进程产生了5个线程：&lt;/p>
&lt;ul>
&lt;li>main线程&lt;/li>
&lt;li>Attach Listener线程&lt;/li>
&lt;li>Finalizer线程&lt;/li>
&lt;li>Reference Handler线程&lt;/li>
&lt;li>Signal Dispatcher线程&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230203165533977.png" alt="image-20230203165533977">&lt;/p>
&lt;h2 id="32测试代码改进">3.2.测试代码改进&lt;/h2>
&lt;p>为了方便观测，我们修改一下测试代码——通过&lt;code>Thread.getAllStackTraces()&lt;/code>在main函数中打印出该Java进程包含的线程：&lt;/p>
&lt;ul>
&lt;li>通过&lt;code>Thread.getAllStackTraces()&lt;/code>，可以让我们在命令行中，也能方便地观察测试结果。&lt;/li>
&lt;li>&lt;code>Thread.sleep(Integer.MAX_VALUE)&lt;/code>可以持续阻塞住该进程，方便观察。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204135454957.png" alt="image-20230204135454957">&lt;/p>
&lt;p>这里补充说明一下&lt;code>Thread.getAllStackTraces()&lt;/code>方法：&lt;/p>
&lt;ul>
&lt;li>&lt;code>getAllStackTraces()&lt;/code>是&lt;code>java.lang.Thread&lt;/code>类的静态方法&lt;/li>
&lt;li>首先，此方法调用&lt;code>java.lang.Thread&lt;/code>类的native方法&lt;code>getThreads()&lt;/code>，获得JVM上当前进程包含的所有线程对象&lt;code>threads&lt;/code>&lt;/li>
&lt;li>然后，此方法调用&lt;code>java.lang.Thread&lt;/code>类的native方法&lt;code>dumpThreads()&lt;/code>，将所有线程对象&lt;code>threads&lt;/code>转换为&lt;code>StackTraceElement[][]&lt;/code>&lt;/li>
&lt;li>最后，此方法将&lt;code>StackTraceElement[][]&lt;/code>转换为&lt;code>Map&lt;/code>，该Map的key就是该线程包含的1个线程对象&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204135619621.png" alt="image-20230204135619621">&lt;/p>
&lt;h1 id="4从操作系统层观测">4.从操作系统层观测&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>首先，我们在Linux上运行起来2.2中的测试代码，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后，通过&lt;strong>&lt;code>ps -ef | grep java&lt;/code>&lt;/strong>命令查看该Java进程信息——该Java进程的进程号是6526：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204142512012.png" alt="image-20230204142512012">&lt;/p>
&lt;ul>
&lt;li>然后，通过&lt;strong>&lt;code>top -H -p 6526&lt;/code>&lt;/strong>查看该Java进程下的线程信息——该Java进程下包含了&lt;strong>15个线程&lt;/strong>：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204142900818.png" alt="image-20230204142900818">&lt;/p>
&lt;h1 id="5不一致的观测结果说明了什么">5.不一致的观测结果，说明了什么?&lt;/h1>
&lt;p>从JVM层观测，我们看到被测的这个Java进程包含了5个线程：&lt;/p>
&lt;ul>
&lt;li>main线程&lt;/li>
&lt;li>Attach Listener线程&lt;/li>
&lt;li>Finalizer线程&lt;/li>
&lt;li>Reference Handler线程&lt;/li>
&lt;li>Signal Dispatcher线程&lt;/li>
&lt;/ul>
&lt;p>从操作系统层观测，我们看到同1个被测的Java进程包含了15个线程：&lt;/p>
&lt;ul>
&lt;li>PID：6527&lt;/li>
&lt;li>PID：6531&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;li>PID：6544&lt;/li>
&lt;/ul>
&lt;p>通过上述不一致的观测结果，我们可以产生两个推论：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推论1&lt;/strong>：&lt;strong>此线程非彼线程&lt;/strong>——JVM层的线程应该是Java线程，操作系统层的线程是真正的系统线程。&lt;/li>
&lt;li>&lt;strong>推论2&lt;/strong>：&lt;strong>此线程与彼线程之间应该存在某种映射关系&lt;/strong>——JVM层的线程，与操作系统层的系统线程之间，应该存在某种映射关系。&lt;/li>
&lt;/ul>
&lt;h1 id="6验证推论">6.验证推论&lt;/h1>
&lt;p>在JVM层观测得到的4个线程，其中的&lt;code>main&lt;/code>线程比较单纯(就是Java测试代码中main函数所在的主线程)，相比其它线程(如：&lt;code>Finalizer&lt;/code>线程)更单纯，因此我们可以跟踪JVM源码中的main函数：&lt;/p>
&lt;h2 id="step1通过执行测试代码进入jvm的main函数">STEP1.通过执行测试代码进入JVM的main函数&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204144631761.png" alt="image-20230204144631761">&lt;/p>
&lt;h2 id="step2进入jli_launch函数">STEP2.进入JLI_Launch函数&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204144827592.png" alt="image-20230204144827592">&lt;/p>
&lt;ul>
&lt;li>此时，操作系统中的该&lt;code>Java进程&lt;/code>(&lt;code>Java进程ID=6627&lt;/code>)下包含1个&lt;code>系统线程&lt;/code>(&lt;code>系统线程ID=6627&lt;/code>)：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204145133920.png" alt="image-20230204145133920">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204145221020.png" alt="image-20230204145221020">&lt;/p>
&lt;h2 id="step3执行loadjavavm函数">STEP3.执行LoadJavaVM函数&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204145333363.png" alt="image-20230204145333363">&lt;/p>
&lt;ul>
&lt;li>此时，操作系统中的该&lt;code>Java进程&lt;/code>(&lt;code>Java进程ID=6627&lt;/code>)下依然只包含1个&lt;code>系统线程&lt;/code>(&lt;code>系统线程ID=6627&lt;/code>)：&lt;/li>
&lt;/ul>
&lt;h2 id="step4执行jvminit函数">STEP4.执行JVMInit函数&lt;/h2>
&lt;p>此时，可以看到1个函数名&lt;code>ContinueInNewThread&lt;/code>，疑似JVM准备创建新的系统线程。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204145550135.png" alt="image-20230204145550135">&lt;/p>
&lt;h2 id="step5执行continueinnewthread函数">STEP5.执行ContinueInNewThread函数&lt;/h2>
&lt;p>此函数会进一步调用&lt;code>ContinueInNewThread0()&lt;/code>函数，疑似JVM在这个函数中会创建新的系统线程。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204145738721.png" alt="image-20230204145738721">&lt;/p>
&lt;h2 id="step6执行continueinnewthread0函数">STEP6.执行ContinueInNewThread0函数&lt;/h2>
&lt;ul>
&lt;li>在此，我们终于看到了JVM调用了Linux系统API&lt;code>pthread&lt;/code>系列函数来创建系统线程&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204145917391.png" alt="image-20230204145917391">&lt;/p>
&lt;ul>
&lt;li>我们执行到1013行，&lt;code>pthread_create&lt;/code>函数，再来观察操作系统，此时产生了1个新的系统线程(线程ID=6840)&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204150109863.png" alt="image-20230204150109863">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204150126981.png" alt="image-20230204150126981">&lt;/p>
&lt;h2 id="step7在新的系统线程中会回调到javamain函数">STEP7.在新的系统线程中会回调到JavaMain函数&lt;/h2>
&lt;ul>
&lt;li>JVM通过pthread创建新的系统线程后，该系统线程会执行&lt;code>JavaMain函数&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204150329012.png" alt="image-20230204150329012">&lt;/p>
&lt;ul>
&lt;li>在&lt;code>JavaMain&lt;/code>函数中，会继续执行&lt;code>InitializeJVM&lt;/code>函数。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204150518536.png" alt="image-20230204150518536">&lt;/p>
&lt;h2 id="step8执行initializejvm函数">STEP8.执行&lt;code>InitializeJVM&lt;/code>函数&lt;/h2>
&lt;ul>
&lt;li>此函数会进一步执行&lt;code>libjvm.so&lt;/code>中的&lt;code>CreateJavaVM&lt;/code>函数&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204150918046.png" alt="image-20230204150918046">&lt;/p>
&lt;ul>
&lt;li>&lt;code>CreateJavaVM&lt;/code>函数调用栈很深，我们直接执行这个函数，查看此时操作系统中，Java进程下的系统线程，此时JVM已经在操作系统中创建了13个新的系统线程：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204151107186.png" alt="image-20230204151107186">&lt;/p>
&lt;h2 id="step9执行回到javamain函数">STEP9.执行回到JavaMain函数&lt;/h2>
&lt;ul>
&lt;li>JVM执行&lt;code>LoadMainClass&lt;/code>函数和&lt;code>GetStaticMethodID&lt;/code>函数，获得Java侧的main函数所在的类和main函数Id。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204151238640.png" alt="image-20230204151238640">&lt;/p>
&lt;ul>
&lt;li>JVM通过JNI接口，调用Java代码中的main函数，Java代码打印出4个Java进程下包含的&lt;code>Java线程&lt;/code>：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明：在不同IDE下，Run模式和Debug模式打印的Java线程是有差异的。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204151535458.png" alt="image-20230204151535458">&lt;/p>
&lt;ul>
&lt;li>此时，操作系统层，这个Java进程包含的&lt;code>系统线程&lt;/code>依然为15个：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/image-20230204151107186.png" alt="image-20230204151107186">&lt;/p>
&lt;h1 id="7结论">7.结论&lt;/h1>
&lt;p>通过6中跟踪JVM的main函数执行过程，可知：&lt;/p>
&lt;ul>
&lt;li>JVM在执行被测Java代码的&lt;code>java xxxx&lt;/code>命令时，在操作系统层产生了&lt;code>1个java进程&lt;/code>JVM会在它的main函数中，通过系统API创建&lt;code>系统线程&lt;/code>(如：Linux下的&lt;code>pthread&lt;/code>库)&lt;/li>
&lt;li>JVM在该java进程内，第1个创建的&lt;code>系统线程&lt;/code>是用来执行Java侧代码的main函数的。
&lt;ul>
&lt;li>在这个系统线程内，JVM先初始化JVM，此时会产生新的系统线程。&lt;/li>
&lt;li>在这个系统线程内，JVM再通过JNI接口得到Java侧代码的main函数以及main函数所在的类，并执行Java侧代码的main函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>因此，证明了我们的推论1：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推论1&lt;/strong>：&lt;strong>此线程非彼线程&lt;/strong>——JVM层的线程应该是Java线程，操作系统层的线程是真正的系统线程。&lt;/li>
&lt;/ul>
&lt;h1 id="8下一步">8.下一步&lt;/h1>
&lt;p>对于推论2，需要进一步分析JVM的main函数执行流程，本文篇幅有限，且听下回分解。&lt;/p>
&lt;p>笔者先附上JVM的main函数执行流程，便于展开下一篇论述：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-2/JVM%E7%9A%84main%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B.png" alt="JVM的main函数流程">&lt;/p></description></item><item><title>【SpringOne 2022】2.Introducing Spring Boot 3.0</title><link>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20222.introducing-spring-boot-3.0/</link><pubDate>Mon, 30 Jan 2023 10:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20222.introducing-spring-boot-3.0/</guid><description>&lt;p>SpringOne 2022第2个议题《Introducing Spring Boot 3.0》，主要展示Spring Boot 3.0的性能以及要点，演讲者：DaShaun Carter。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130165407830.png" alt="image-20230130165407830">&lt;/p>
&lt;h1 id="1测试前提">1.测试前提&lt;/h1>
&lt;h2 id="硬件">硬件&lt;/h2>
&lt;p>演讲者强调了测试的两款典型的CPU：&lt;code>Apple M1&lt;/code>和&lt;code>Raspberry Pi(Broadcom BCM2711)&lt;/code>。&lt;/p>
&lt;p>本文不展开两款CPU对比的性能差异，如果您对这两种CPU的性能参数感兴趣，可以在此看到详细的参数对比：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://www.cpu-monkey.com/en/compare_cpu-raspberry_pi_4_b_broadcom_bcm2711-vs-apple_m1_max_24_gpu">https://www.cpu-monkey.com/en/compare_cpu-raspberry_pi_4_b_broadcom_bcm2711-vs-apple_m1_max_24_gpu&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130160044858.png" alt="image-20230130160044858">&lt;/p>
&lt;h2 id="被测对象">被测对象&lt;/h2>
&lt;p>执行如下脚本，可获得被测对象：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">curl https://start.spring.io/starter.tgz &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-d dependencies-web, actuator &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-d &lt;span class="nv">javaVersion&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="m">17&lt;/span> &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-d &lt;span class="nv">bootVersion&lt;/span>&lt;span class="o">=&lt;/span>3.0.0-RC2 &lt;span class="se">\
&lt;/span>&lt;span class="se">&lt;/span>-d &lt;span class="nv">type&lt;/span>&lt;span class="o">=&lt;/span>maven-project &lt;span class="p">|&lt;/span> tar -xzf -
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="代码归档">代码归档&lt;/h2>
&lt;p>测试代码归档在此：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/dashaun/spring-boot-3-with-aot-processing">https://github.com/dashaun/spring-boot-3-with-aot-processing&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130160316666.png" alt="image-20230130160316666">&lt;/p>
&lt;h2 id="java版本">Java版本&lt;/h2>
&lt;p>采用GraalVM：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130160356760.png" alt="image-20230130160356760">&lt;/p>
&lt;h1 id="2测试mvnw-vs-mvnd">2.测试：mvnw vs mvnd&lt;/h1>
&lt;p>演讲者对比测试了&lt;code>mvnw clean package&lt;/code>和&lt;code>mvnd clean package&lt;/code>，对比了&lt;code>mvnw&lt;/code>和&lt;code>mvnd&lt;/code>的性能差异。&lt;/p>
&lt;h2 id="mvnw-clean-package">mvnw clean package&lt;/h2>
&lt;blockquote>
&lt;p>测试结果：8.3s&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130161233119.png" alt="image-20230130161233119">&lt;/p>
&lt;h2 id="mvnd-clean-package">mvnd clean package&lt;/h2>
&lt;blockquote>
&lt;p>测试结果：5.6s&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130161255058.png" alt="image-20230130161255058">&lt;/p>
&lt;h2 id="结论mvnd构建性能优于mvnw">结论：&lt;code>mvnd&lt;/code>构建性能优于&lt;code>mvnw&lt;/code>&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130161311506.png" alt="image-20230130161311506">&lt;/p>
&lt;h2 id="对mvnd的延伸阅读">对mvnd的延伸阅读&lt;/h2>
&lt;p>&lt;code>mvnd&lt;/code>也是一种maven wrapper，相比&lt;code>mvnw&lt;/code>性能更好。详细资料如下：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://github.com/apache/maven-mvnd">https://github.com/apache/maven-mvnd&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130160948600.png" alt="image-20230130160948600">&lt;/p>
&lt;h1 id="3测试graalvm-aot">3.测试：GraalVM AOT&lt;/h1>
&lt;p>演讲者展示了采用&lt;code>AOT&lt;/code>技术构建Spring Boot 3.0应用，体现了性能的差异。&lt;/p>
&lt;h2 id="mvnw--pnative-nativecompile">mvnw -Pnative native:compile&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>构建时间延长至分钟级&lt;/strong>：使用&lt;code>mvnw -Pnative native:compile&lt;/code>构建，构建时间长达6分钟。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130161937854.png" alt="image-20230130161937854">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>启动时间缩短50%&lt;/strong>：未采用&lt;code>AOT&lt;/code>方式的SpringBoot进程启动时间通常在1.5s左右，采用&lt;code>AOT&lt;/code>方式缩短至0.7s。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130162028761.png" alt="image-20230130162028761">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>资源消耗下降66%&lt;/strong>：未采用&lt;code>AOT&lt;/code>方式的SpringBoot进程通常占用120m物理内存，采用&lt;code>AOT&lt;/code>方式占用38m物理内存。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%912.IntroducingSpringBoot3.0/image-20230130162322180.png" alt="image-20230130162322180">&lt;/p>
&lt;h2 id="结论aot可极大缩短热启动时间和资源消耗">结论：AOT可极大缩短热启动时间和资源消耗&lt;/h2>
&lt;p>AOT方式虽然延长了构建时间，但运行时的资源消耗会极大降低。&lt;/p>
&lt;h1 id="4开发建议">4.开发建议&lt;/h1>
&lt;p>演讲者给出了4点建议：&lt;/p>
&lt;ul>
&lt;li>The paved path to production starts at your laptop.&lt;/li>
&lt;li>Deploy all the things on your laptop.&lt;/li>
&lt;li>Scale to zero：Startup quickly, Chaos Happens.&lt;/li>
&lt;li>Be a better consumer of infrastructure.&lt;/li>
&lt;/ul>
&lt;p>这4点建议的本质是：Spring Boot 3.0更强调单体服务的&lt;strong>小型化&lt;/strong>，进而支撑将所有的微服务部署在1台笔记本上。&lt;/p>
&lt;p>在1台笔记本上就能把整个产品中的各种微服务都跑起来，才能提升开发效率(&lt;strong>尽快Startup，尽快暴露问题&lt;/strong>)。&lt;/p>
&lt;p>&lt;strong>小型化&lt;/strong>一定是有微服务实战经验后才能体会的&lt;strong>重要经验&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>在微服务架构兴起之初，&lt;/p>
&lt;p>笔者曾经所在的产品团队仅仅学会了微服务架构的形(把1个单进程盲目地拆解成了N个微服务进程)，但没有学会微服务的神(面向接口)，&lt;/p>
&lt;p>导致开发阶段对服务器等环境资源极度依赖，最终导致开发效率极低。&lt;/p>
&lt;/blockquote>
&lt;h1 id="5总结">5.总结&lt;/h1>
&lt;ul>
&lt;li>在本议题，演讲者DaShaun提供了&lt;code>AOT&lt;/code>、&lt;code>mvnd&lt;/code>等手段降低单体服务的资源消耗。&lt;/li>
&lt;li>Spring Boot 3.0的核心思想也是在强调&lt;strong>小型化&lt;/strong>(小到可以部署到1台笔记本上)有助于&lt;strong>提升开发效率&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>小型化&lt;/strong>与&lt;strong>微服务架构&lt;/strong>不仅不矛盾，而且是微服务架构&lt;strong>重要的实践经验&lt;/strong>。&lt;/li>
&lt;/ul></description></item><item><title>【SpringOne 2022】1.Introducing Spring Framework 6</title><link>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20221.introducing-spring-framework-6/</link><pubDate>Sat, 28 Jan 2023 10:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/spring%E6%8B%BE%E9%81%97/springone-20221.introducing-spring-framework-6/</guid><description>&lt;p>SpringOne 2022第1个议题《Introducing Spring Framework 6》，主要介绍了Spring Framework6的关键特性以及里程碑，演讲者：Juergen Hoeller。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%911.IntroducingSpringFramework6/image-20230128153953141.png" alt="image-20230128153953141">&lt;/p>
&lt;h1 id="1版本里程碑">1.版本里程碑&lt;/h1>
&lt;h2 id="2个ga版本">2个GA版本&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>2022-11，发布&lt;code>Spring Framework 6.0 GA&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>Spring Framework 6.0 GA&lt;/code>配套&lt;code>Java 17/18/19&lt;/code>&lt;/li>
&lt;li>匹配&lt;code>Spring Boot 3.0&amp;amp;3.1&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>2023-07，发布&lt;code>Spring Framework 6.1 GA&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;code>Spring Framework 6.1 GA&lt;/code>配套&lt;code>Java 17/18/19/20/21&lt;/code>&lt;/li>
&lt;li>匹配&lt;code>Spring Boot 3.2&amp;amp;3.3&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%911.IntroducingSpringFramework6/image-20230128165742669.png" alt="image-20230128165742669">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>详细日程表&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Spring%E6%8B%BE%E9%81%97/%E3%80%90SpringOne2022%E3%80%911.IntroducingSpringFramework6/image-20230128170617815.png" alt="image-20230128170617815">&lt;/p>
&lt;h2 id="6x-vs-53x">&lt;code>6.x&lt;/code> vs &lt;code>5.3.x&lt;/code>&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Spring Framework 5.3.x&lt;/th>
&lt;th>Spring Framework 6.x&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Java版本&lt;/td>
&lt;td>&lt;code>Java 8/11/17&lt;/code>&lt;/td>
&lt;td>&lt;code>Java 17+&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Java EE版本&lt;/td>
&lt;td>&lt;code>Java EE 7/8&lt;/code>(javax namespace)&lt;/td>
&lt;td>&lt;code>Jakarta EE 9/10&lt;/code>(jakarta namespace)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>命令式编程模型&lt;/code>和&lt;code>响应式编程模型&lt;/code>&lt;/td>
&lt;td>新增&lt;/td>
&lt;td>继承&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>配套&lt;code>Spring Boot&lt;/code>&lt;/td>
&lt;td>&lt;code>Spring Boot 2.7.x&lt;/code>&lt;/td>
&lt;td>&lt;code>Spring Boot 3.x&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>AOT&lt;/code>(Ahead-Of-Time)&lt;/td>
&lt;td>-&lt;/td>
&lt;td>新增&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>虚拟线程&lt;/code>&lt;/td>
&lt;td>-&lt;/td>
&lt;td>新增(基于Loom)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="2java对spring-framework的影响">2.Java对Spring Framework的影响&lt;/h1>
&lt;p>如下列举了对&lt;code>Spring Framework&lt;/code>产生影响的&lt;code>Java 17新特性&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>语言层&lt;/strong>：text blocks、switch改进
&lt;ul>
&lt;li>&lt;strong>类型系统&lt;/strong>：records、sealed classes&lt;/li>
&lt;li>&lt;strong>代码组织形式&lt;/strong>：module introspection、module path scanning&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>标准库&lt;/strong>：集合的工厂方法(&lt;code>collection factory methods&lt;/code>)
&lt;ul>
&lt;li>如：&lt;code>List&amp;lt;Integer&amp;gt; list = List.of();&lt;/code>&lt;/li>
&lt;li>参考：https://stackoverflow.com/questions/43533835/java-9-what-are-collection-factory-methods&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="3java-ee对spring-framework的影响">3.Java EE对Spring Framework的影响&lt;/h1>
&lt;p>从&lt;code>Java EE 8&lt;/code>到&lt;code>Jakarta EE 9&lt;/code>的升级，也会对&lt;code>Spring Framework&lt;/code>产生影响：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>Servlet API 5.0&lt;/code>&lt;/strong>：&lt;code>javax.servlet&lt;/code>变为&lt;code>jakarta.servlet&lt;/code>
&lt;ul>
&lt;li>基于&lt;code>Servlet API 5.0/6.0&lt;/code>的Web容器：
&lt;ul>
&lt;li>&lt;code>Tomcat 10.0/10.1&lt;/code>&lt;/li>
&lt;li>&lt;code>Jetty 11/12&lt;/code>&lt;/li>
&lt;li>&lt;code>Undertow 2.3&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>&lt;code>JPA 3.0&lt;/code>&lt;/strong>：&lt;code>javax.persistence&lt;/code>变为&lt;code>jakarta.persistence&lt;/code>
&lt;ul>
&lt;li>基于&lt;code>JPA 3.0/3.1&lt;/code>的&lt;code>ORM&lt;/code>及&lt;code>Validator&lt;/code>：
&lt;ul>
&lt;li>&lt;code>Hibernate ORM 6.1&lt;/code>&lt;/li>
&lt;li>&lt;code>Hibernate Validator 7.0/8.0&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="4aot对spring-framework的影响">4.AOT对Spring Framework的影响&lt;/h1>
&lt;p>伴随&lt;code>Java17&lt;/code>对&lt;code>AOT&lt;/code>的关注和支持，Spring Framework也增加了对&lt;code>AOT&lt;/code>的支持。&lt;/p>
&lt;p>Java对&lt;code>AOT&lt;/code>的支持有两种技术路线：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;code>GraalVM&lt;/code>&lt;/strong>：编译期直接将Java源码变成可执行二进制(&lt;code>native executables&lt;/code>)&lt;/li>
&lt;li>&lt;strong>&lt;code>CRaC&lt;/code>&lt;/strong>：保存JVM的Checkpoint，进而支持针对Checkpoint的还原(&lt;code>Coordinated Restore at Checkpoint&lt;/code>)
&lt;ul>
&lt;li>&lt;code>OpenJDK&lt;/code>启动了名为&lt;code>CRaC&lt;/code>的项目&lt;/li>
&lt;li>参考：https://wiki.openjdk.org/display/crac&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="5虚拟线程对spring-framework的影响">5.虚拟线程对Spring Framework的影响&lt;/h1>
&lt;p>随着&lt;code>虚拟线程&lt;/code>作为&lt;code>Java19&lt;/code>的预览特性，Spring Framework也进行了支持，但&lt;code>Juergen Hoeller&lt;/code>对&lt;code>虚拟线程&lt;/code>的阐述比较辩证：&lt;/p>
&lt;ul>
&lt;li>不要盲目迷信&lt;code>虚拟线程&lt;/code>，需要在合适的场景下使用，演讲中举了两类适用的场景：
&lt;ul>
&lt;li>如：基于IO流的Servlet&lt;/li>
&lt;li>如：@Scheduler管理的消息型系统&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>不适用的场景：纯CPU计算型的业务逻辑(&lt;code>purely CPU-bound handlers&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h1 id="6总结">6.总结&lt;/h1>
&lt;ul>
&lt;li>&lt;code>Spring Framework&lt;/code>作为一个底层框架，它的输入往往来自于Java语言规范、Java EE标准。&lt;/li>
&lt;li>Spring团队规划的新特性非常紧贴Java新版本/新特性，即便这个新特性仅仅是&lt;code>Preview Feature&lt;/code>。&lt;/li>
&lt;li>深刻理解Java新版本/新特性，有助于理解&lt;code>Spring Framework&lt;/code>的新特性以及它的市场规划。&lt;/li>
&lt;/ul></description></item><item><title>【运行时数据区】-并发编程-前置知识(4.并发编程基础)-1</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-1/</link><pubDate>Thu, 01 Dec 2022 08:07:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%864.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-1/</guid><description>&lt;h1 id="浅析协程">浅析协程&lt;/h1>
&lt;p>并发编程的核心目标之一就是&amp;rdquo;&lt;strong>快&lt;/strong>&amp;quot;，并发编程发展史中若干特性与改进无不围绕这个目标。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/quick.gif" alt="quick.gif">&lt;/p>
&lt;p>笔者通过&lt;strong>&lt;code>《Learning Concurrency in Kotlin》&lt;/code>&lt;/strong>书中的&lt;strong>&lt;code>&amp;quot;Processes, threads, and coroutines&amp;quot;&lt;/code>&lt;/strong>章节，浅析一下&lt;strong>&lt;code>&amp;quot;协程&amp;quot;&lt;/code>&lt;/strong>。&lt;/p>
&lt;h2 id="进程processes">进程(Processes)&lt;/h2>
&lt;ul>
&lt;li>我们先看看书中对&lt;strong>&lt;code>进程(Processes)&lt;/code>&lt;/strong>的介绍：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>A process is an instance of an application that is being executed. Each time an application is started, a process is started for it.&lt;/p>
&lt;/blockquote>
&lt;p>进程是正在执行的应用程序的实例。每次启动应用程序时，都会为其启动一个进程。&lt;/p>
&lt;blockquote>
&lt;p>A process has a state, things such as handles to open resources, a process ID, data, network connections, and so on, are part of the state of a process and can be accessed by the threads inside that process.&lt;/p>
&lt;/blockquote>
&lt;p>进程是有状态的，打开资源的句柄、进程 ID、数据、网络连接等都是进程状态的一部分，这些信息都可以被该进程内的线程访问。&lt;/p>
&lt;blockquote>
&lt;p>An application can be composed of many processes, a common practice for example for internet browsers.&lt;/p>
&lt;p>&amp;hellip;&amp;hellip;But implementing a multi-process application brings challenges that are out of the scope of this book. For this book, we will cover the implementation of applications that run in more than one thread, but still in a single process&amp;hellip;&amp;hellip;.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>归纳一下书中内容：&lt;/strong>
&lt;ul>
&lt;li>1个应用可以包含N个进程。&lt;/li>
&lt;li>&lt;a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/">Chrome的多进程架构图&lt;/a>展示了：1个Chrome浏览器包含了浏览器进程、渲染进程等N个进程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/arch.png" alt="img">&lt;/p>
&lt;h2 id="线程threads">线程(Threads)&lt;/h2>
&lt;ul>
&lt;li>我们再看看书中对&lt;strong>&lt;code>线程(Threads)&lt;/code>&lt;/strong>的介绍：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>A thread of execution encompasses a set of instructions for a processor to execute.&lt;/p>
&lt;p>So a process will contain at least one thread, which is created to execute the point of entry of the application; usually this entry point is the main() function of the application. This thread is called the main thread, and the life cycle of the process will be tied to it; if this thread ends, the process will end as well, regardless of any other threads in the process.&lt;/p>
&lt;/blockquote>
&lt;p>线程包含一组供处理器执行的指令。1个进程至少会包含1个线程，这个线程就是主线程。应用程序在入口点创建该线程，并绑定了该线程与进程的生命周期。&lt;/p>
&lt;p>其中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">(1)应用程序的入口点通常是main()函数。
(2)主线程结束，则进程也结束，即使这个进程中还有其它未执行完的线程。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>Each thread can access and modify the resources contained in the process it&amp;rsquo;s attached to, but it also has its own local storage, called thread-local storage.&lt;/p>
&lt;/blockquote>
&lt;p>每个线程都可以访问和修改它所附加的进程中包含的资源，但它也有自己的本地存储，称为线程本地存储(&lt;code>thread-local&lt;/code>)。&lt;/p>
&lt;blockquote>
&lt;p>Only one of the instructions in a thread can be executed at a given time. So if a thread is blocked, the execution of any other instruction in that same thread will not be possible until the blocking ends. Nevertheless, many threads can be created for the same process, and they can communicate with each other. So it is expected that an application will never block a thread that can affect negatively the experience of the user; instead, the blocking operations should be assigned to threads that are dedicated to them.&lt;/p>
&lt;p>In Graphic User Interface (GUI) applications, there is a thread called a UI thread; its function is to update the User Interface and listen to user interactions with the application. Blocking this thread, obstructs the application from updating its UI and from receiving interactions from the user. Because of this, GUI applications are expected to never block the UI thread*,* in order to keep the application responsive at all times.&lt;/p>
&lt;p>Android 3.0 and above, for example, will crash an application if a networking operation is made in the UI thread, in order to discourage developers from doing it, given that networking operations are thread-blocking.&lt;/p>
&lt;/blockquote>
&lt;p>在给定的时间内，只能执行1个线程中的1条指令。如果一个线程被阻塞，则在阻塞结束前，该线程内任何其它的指令都不可能被执行。&lt;/p>
&lt;p>尽管如此，我们可以在1个进程内创建N个线程，线程间可以互相通信。&lt;/p>
&lt;p>因此，为了不影响用户体验，我们应该将阻塞操作分配给专门的线程，而不是阻塞主线程。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">在GUI应用程序中，存在1个UI线程，这个线程的功能是更新用户界面并监听用户与应用程序的交互，阻塞了UI线程就会阻止用户界面的更新和交互。
因此，我们永远不会阻塞UI线程。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">在Android 3.0+的版本中，如果在UI 线程中进行网络操作，Android会触发应用程序崩溃，因为Android认为网络操作是一种阻塞操作。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>Throughout the book, we will refer to the main thread of a GUI application both as a UI thread and as a main thread (because in Android, by default, the main thread is also the UI thread), while for command-line applications we will refer to it only as a main thread. Any thread different from those two will be called a background thread, unless a distinction between background threads is required, in which case each background thread will receive a unique identifier for clarity.&lt;/p>
&lt;/blockquote>
&lt;p>在本书中，&lt;/p>
&lt;p>我们将GUI应用程序的主线程称为&lt;code>UI线程&lt;/code>，也称为&lt;code>主线程&lt;/code>——比如：在 Android 中，默认情况下，主线程就是UI线程。&lt;/p>
&lt;p>我们将命令行应用程序的主线程，仅称为&lt;code>主线程&lt;/code>。&lt;/p>
&lt;p>任何不同于前述两个线程的其它线程都称为&lt;code>后台线程&lt;/code>。&lt;/p>
&lt;p>Given the way that the Kotlin has implemented concurrency, you will find that it&amp;rsquo;s not necessary for you to manually start or stop a thread. The interactions that you will have with threads will commonly be limited to tell Kotlin to create or use a specific thread or pool of threads to run a coroutine – usually with one or two lines of code. The rest of the handling of threads will be done by the framework.&lt;/p>
&lt;p>鉴于Kotlin实现并发的方式，我们没有必要手动启动或停止线程。&lt;/p>
&lt;p>我们与线程的交互通常仅限于告诉Kotlin创建/使用特定线程，或者告诉Kotlin使用线程池中的某个空闲的协程，线程的其余处理将由底层框架完成。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>归纳一下书中内容：&lt;/strong>
&lt;ul>
&lt;li>1个进程包含N个线程，这些线程包含主线程、后台线程等。&lt;/li>
&lt;li>&lt;a href="https://www.chromium.org/developers/design-documents/multi-process-architecture/">Chrome的多进程架构图&lt;/a>展示了：浏览器进程中包含了主线程、IO线程，渲染进程包含了主线程、渲染线程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/arch.png" alt="img">&lt;/p>
&lt;h2 id="协程coroutines">协程(Coroutines)&lt;/h2>
&lt;ul>
&lt;li>我们还是看看书中对&lt;strong>&lt;code>协程(Coroutines)&lt;/code>&lt;/strong>的介绍：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Kotlin&amp;rsquo;s documentation often refers to coroutines as lightweight threads. This is mostly because, like threads, coroutines define the execution of a set of instructions for a processor to execute. Also, coroutines have a similar life cycle to that of threads.&lt;/p>
&lt;/blockquote>
&lt;p>在Kotlin中，通常将协程称为轻量级线程。这主要是因为，与线程一样，协程定义了处理器执行的一组指令的执行。此外，协程具有与线程相似的生命周期。&lt;/p>
&lt;blockquote>
&lt;p>A coroutine is executed inside a thread. One thread can have many coroutines inside it, but as already mentioned, only one instruction can be executed in a thread at a given time. This means that if you have ten coroutines in the same thread, only one of them will be running at a given point in time.&lt;/p>
&lt;/blockquote>
&lt;p>协程在线程内执行。1个线程内部可以有N个协程。&lt;/p>
&lt;p>但正如前文提到的：在给定时间内，1个线程中只能执行1条指令，因此1个线程中有10个协程，那么在给定的时间点只会运行其中1个协程。&lt;/p>
&lt;blockquote>
&lt;p>The biggest difference between threads and coroutines, though, is that coroutines are fast and cheap to create. Spawning thousands of coroutines can be easily done, it is faster and requires fewer resources than spawning thousands of threads.&lt;/p>
&lt;/blockquote>
&lt;p>不过，线程和协程之间的最大区别在于：创建协程速度快、成本低，它比产生数千个线程更快、需要更少的资源。&lt;/p>
&lt;blockquote>
&lt;p>Take this code as an example. Don&amp;rsquo;t worry about the parts of the code you don&amp;rsquo;t understand yet:&lt;/p>
&lt;p>This function creates as many coroutines as specified in the parameter amount, delays each one for a second, and waits for all of them to end before returning. This function can be called, for example, with 10,000 as the amount of coroutines:&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">createCoroutines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">jobs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Job&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="m">1.&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">jobs&lt;/span> &lt;span class="p">+=&lt;/span> &lt;span class="n">launch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">jobs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">runBlocking&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">time&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">measureTimeMillis&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">createCoroutines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="n">_000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Took $time ms&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上述代码为例：&lt;code>createCoroutines()&lt;/code>支持创建指定数量的协程，执行每个协程就是休眠1秒，此函数等待所有协程结束后就会返回。&lt;/p>
&lt;blockquote>
&lt;p>In a test environment, running it with an amount of 10,000 took around 1,160 ms, while running it with 100,000 took 1,649 ms. The increase in execution time is so small because Kotlin will use a pool of threads with a fixed size, and distribute the coroutines among those threads – so adding thousands of coroutines will have little impact. And while a coroutine is suspended – in this case because of the call to delay() – the thread it was running in will be used to execute another coroutine, one that is ready to be started or resumed.&lt;/p>
&lt;/blockquote>
&lt;p>在测试环境中，创建1万个协程需要1160毫秒，创建10万个协程需要1649毫秒。协程增加了9万个，执行时间却没有增加太多，是因为：&lt;/p>
&lt;p>Kotlin使用了固定大小的线程池，并将协程分布在线程池中的这些线程上，所以增加协程数量，并不会增加更多的资源消耗和时间消耗。&lt;/p>
&lt;p>所谓的将&amp;quot;协程分布在线程池中的这些线程上&amp;rdquo;，就是将1个协程放到1个线程中去执行，当这个协程被挂起时(因为调用了&lt;code>delay()&lt;/code>函数)，它所属的这个线程就用来执行其它准备好的协程。&lt;/p>
&lt;blockquote>
&lt;p>How many threads are active can be determined by calling the activeCount() method of the Thread class.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>activeCount()&lt;/code>函数可以确定当前有多少个线程处于活动状态。&lt;/p>
&lt;blockquote>
&lt;p>For example, let&amp;rsquo;s update the main() function to do so:&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">runBlocking&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;${Thread.activeCount()} threads active at the start&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">time&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">measureTimeMillis&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">createCoroutines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">10&lt;/span>&lt;span class="n">_000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;${Thread.activeCount()} threads active at the end&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Took $time ms&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>比如：我们修改&lt;code>main()&lt;/code>函数的实现，分别打印了&lt;code>main()&lt;/code>函数创建协程前的线程个数、创建协程后的线程个数。&lt;/p>
&lt;blockquote>
&lt;p>In the same test environment as before, it was found that in order to create 10,000 coroutines, only four threads needed to be created:&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/72fd74aa-f292-4680-b520-7e12a750a438.png" alt="img">&lt;/p>
&lt;blockquote>
&lt;p>But once the value of the amount being sent to createCoroutines() is lowered to one, for example, only two threads are created:&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/c6df4fce-5556-4fa3-9fb8-7653c2f7972d.png" alt="img">&lt;/p>
&lt;p>在测试环境上，创建1万个协程需要4个线程(6个线程-2个线程)，创建1个协程仅需要创建2个线程(4个线程-2个线程)。&lt;/p>
&lt;blockquote>
&lt;p>It&amp;rsquo;s important to understand that even though a coroutine is executed inside a thread, it&amp;rsquo;s not bound to it. As a matter of fact, it&amp;rsquo;s possible to execute part of a coroutine in a thread, suspend the execution, and later continue in a different thread. In our previous example this is happening already, because Kotlin will move coroutines to threads that are available to execute them. For example, by passing 3 as the amount to createCoroutines(), and updating the content of the launch() block so that it prints the current thread, we can see this in action:&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">createCoroutines&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">jobs&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">ArrayList&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Job&lt;/span>&lt;span class="p">&amp;gt;()&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="m">1.&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">amount&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">jobs&lt;/span> &lt;span class="p">+=&lt;/span> &lt;span class="n">launch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Started $i in ${Thread.currentThread().name}&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1000&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Finished $i in ${Thread.currentThread().name}&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">jobs&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">forEach&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另一个很重要的点是：即使协程在线程内执行，它也不会受线程约束。&lt;/p>
&lt;p>事实上，可以在1个线程中执行1个协程的一部分，当这个协程被挂起再恢复执行时，可以在另1个线程中继续执行这个协程的剩余部分。&lt;/p>
&lt;blockquote>
&lt;p>You will find that in many cases they are being resumed in a different thread:&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/3d118878-25a4-4bec-8fb7-fd13335ed4cf.png" alt="img">&lt;/p>
&lt;p>我们可以看到示例代码创建了3个协程，协程1在线程1中执行，延迟1000毫秒后，协程1在线程2中继续执行完毕。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>归纳一下书中内容：&lt;/strong>
&lt;ul>
&lt;li>1个线程包含N个协程。&lt;/li>
&lt;li>同1个协程可以在线程1中执行一部分，在线程2中执行剩余部分。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="全局观">全局观&lt;/h2>
&lt;ul>
&lt;li>最后我们看看书中对&lt;strong>&lt;code>进程、线程、协程&lt;/code>&lt;/strong>的总结：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>So far, we have learned that an application is composed of one or more processes and that each process has one or more threads. We have also learned that blocking a thread means halting the execution of the code in that thread, and for that reason, a thread that interacts with a user is expected to never be blocked. We also know that a coroutine is basically a lightweight thread that resides in a thread but is not tied to one. The following diagram encapsulates the content of this section so far. Notice how each coroutine is started in one thread but at some point is resumed in a different one:&lt;/p>
&lt;/blockquote>
&lt;p>至此，&lt;/p>
&lt;p>我们可以知道：1个应用程序是由N个进程组成，1个进程包含N线程。&lt;/p>
&lt;p>我们还知道：阻塞线程意味着停止该线程中代码的执行，因此永远不应该阻塞与用户交互的线程。&lt;/p>
&lt;p>我们还知道：协程是1个轻量级线程，它驻留在1个线程中但又不绑定到具体的这个线程中。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">1个协程可以在1个线程中启动，但在某个时刻又可以在另一个线程中恢复执行。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下图概括了本节到目前为止的内容。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/4435aef0-eb0f-4a75-a6aa-ff8bf9462740.png" alt="img">&lt;/p>
&lt;h1 id="协程的语言实现java版">协程的语言实现(Java版)&lt;/h1>
&lt;p>协程在Java中的实现非常落后，直到Java8也没有在正式版本中支持协程。&lt;/p>
&lt;p>OpenJDK团队后来引入了&lt;code>quasar&lt;/code>库的大神，启动了&lt;code>Loom&lt;/code>项目，&lt;code>Loom&lt;/code>项目的最新进展后续另开文章介绍，本文就基于&lt;code>quasar&lt;/code>体验一下Java版的协程性能。&lt;/p>
&lt;p>在此，我们模仿前文翻译的&lt;code>《Learning Concurrency in Kotlin》&lt;/code>中的示例代码：&lt;/p>
&lt;ul>
&lt;li>创建10万个线程，每个线程执行20万次加法，等待10万个线程都执行完，打印总耗时。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Main1&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">MAX_COUNT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">100000&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">iStartTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">Thread&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">arrThread&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">MAX_COUNT&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arrThread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arrThread&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">Main1&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">calc&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">arrThread&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Thread&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">arrThread&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">join&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">InterruptedException&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Total: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">iStartTime&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">calc&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">iRes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">10000&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">20&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">iRes&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">iRes&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行结果：消耗了8945毫秒。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/image-20221201183245050.png" alt="image-20221201183245050">&lt;/p>
&lt;ul>
&lt;li>我们再创建10万个协程，每个协程也是执行20万次加法，等待10万个协程都执行完，打印总耗时。
&lt;ul>
&lt;li>这里我们用到了&lt;code>quasar&lt;/code>来创建协程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Main2&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">iStartTime&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">Fiber&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Void&lt;/span>&lt;span class="o">&amp;gt;[]&lt;/span> &lt;span class="n">arrFiber&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Fiber&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">Main1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MAX_COUNT&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">arrFiber&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">arrFiber&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Fiber&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;(&lt;/span>&lt;span class="n">Main1&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">calc&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Fiber&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Void&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">fiber&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">arrFiber&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">fiber&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">start&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Fiber&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Void&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">thread&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">arrFiber&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">thread&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">join&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Exception&lt;/span> &lt;span class="n">e&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">e&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">printStackTrace&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">&amp;#34;Total: &amp;#34;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">currentTimeMillis&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">iStartTime&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行结果：消耗了1812毫秒。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/image-20221201183730909.png" alt="image-20221201183730909">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>测试结论&lt;/strong>：反复执行上述测试代码，Java协程的性能远高于比Java线程的性能。&lt;/li>
&lt;/ul>
&lt;h1 id="参考">参考&lt;/h1>
&lt;blockquote>
&lt;p>《Learning Concurrency in Kotlin》：https://www.amazon.com/Learning-Concurrency-Kotlin-efficient-applications/dp/1788627164&lt;/p>
&lt;p>Wiki：https://en.wikipedia.org/wiki/Coroutine&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86(4.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80)-1/image-20221121164732405.png" alt="image-20221121164732405">&lt;/p></description></item><item><title>【宏观】-0-性能之巅笔记-上</title><link>https://jherculesqz.github.io/post/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E5%AE%8F%E8%A7%82-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/</link><pubDate>Wed, 25 May 2022 10:00:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E5%AE%8F%E8%A7%82-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/</guid><description>&lt;h1 id="1brendan-gregg是谁">1.Brendan Gregg是谁&lt;/h1>
&lt;p>Brendan Gregg，性能界大神，曾就职于Netflix、Sun、Oracle、Joyent(被三星收购的一家云计算公司)，从2022年5月的博客看，他目前就职于Intel。&lt;/p>
&lt;p>Brendan Gregg在性能方面的成就数不胜数，仅列出两项就可以让我们膜拜了：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>《Systems Performance : Enterprise and the Cloud》&lt;/strong>：中文名《性能之巅》，一本风靡全球的性能工程的圣经。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220526101942669.png" alt="image-20220526101942669">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&amp;ldquo;The Flame Graph&amp;rdquo;&lt;/strong>：Brendan Gregg于2013年提出的&amp;quot;火焰图&amp;rdquo;，火焰图方法也成为现在各种性能工具中必备的可视化能力。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220526103724186.png" alt="image-20220526103724186">&lt;/p>
&lt;p>Brendan Gregg在性能领域，还有一个被广为传播的骚操作——对着磁盘狂吼引发磁盘IO的性能问题。。。大神的世界我们永远不懂。。。&lt;/p>
&lt;ul>
&lt;li>油管：&lt;a href="https://www.youtube.com/watch?v=tDacjrSCeq4">https://www.youtube.com/watch?v=tDacjrSCeq4&lt;/a>&lt;/li>
&lt;li>B站：&lt;a href="https://www.bilibili.com/video/BV1gY4y1L7Px/">https://www.bilibili.com/video/BV1gY4y1L7Px/&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220526105433607.png" alt="image-20220526105433607">&lt;/p>
&lt;h1 id="2第一章笔记">2.第一章笔记&lt;/h1>
&lt;p>Brendan Gregg在《性能之巅》第一章主要讲了2个问题：&lt;/p>
&lt;ul>
&lt;li>为什么学习性能工程很难？&lt;/li>
&lt;li>为什么实施性能工程很难？&lt;/li>
&lt;/ul>
&lt;h2 id="为什么学习性能工程很难">为什么学习性能工程很难？&lt;/h2>
&lt;p>作者想表达的核心观点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>性能工程要求工程师具备宽广的技术广度，同时也要具备深邃的技术深度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然而，技术深度与技术广度兼备的确是一件很困难的事情。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>作者引用了2002年美国国防部长论述国际关系时的一段话：&lt;/p>
&lt;blockquote>
&lt;p>国际关系中，&lt;/p>
&lt;p>有已知的已知：有些事情我们知道自己知道。&lt;/p>
&lt;p>也有已知的未知：我们知道有些事情我们不知道。&lt;/p>
&lt;p>但还有未知的未知：有些事情我们知道自己不知道。&lt;/p>
&lt;/blockquote>
&lt;p>美国防部长这段话的本意是想论述国际关系复杂多变，任何一项决策要考虑充分，避免未知的未知引发不可估量的后果。&lt;/p>
&lt;p>作者认为这段话也可以类比于性能工程：&lt;/p>
&lt;blockquote>
&lt;p>当我们开展性能优化工作时，由于未知的未知太多，会导致：&lt;/p>
&lt;p>(1)缺乏&amp;quot;高效&amp;quot;的定位手段——而且我们还不自知操作系统早已为我们准备好了对应的方法和工具。&lt;/p>
&lt;p>(2)缺乏&amp;quot;有效&amp;quot;的解决办法。&lt;/p>
&lt;/blockquote>
&lt;p>作者的观点，与庄子的《养生主》异曲同工：&lt;/p>
&lt;blockquote>
&lt;p>吾生也有涯，而知也无涯。以有涯随无涯，殆已！&lt;/p>
&lt;/blockquote>
&lt;p>人类的生命是非常有限的，而知识无边无尽，以有限的生命追求无边的知识，显然是不可能的。&lt;/p>
&lt;p>作者有什么建议呢？可以归纳为两点：&lt;/p>
&lt;ul>
&lt;li>对策1：对知识进行归纳，抽象出知识的本质。&lt;/li>
&lt;li>对策2：有选择地、有优先级地学习。
&lt;ul>
&lt;li>巩固已知的已知，扩大已知的未知，减少未知的未知。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>作者认为知识肯定是学不完的，但学习时可以：&lt;/p>
&lt;ul>
&lt;li>首先，将尽可能多的&amp;quot;未知的未知&amp;quot;转换为&amp;quot;已知的未知&amp;rdquo;。&lt;/li>
&lt;li>然后，实战时再查资料，将&amp;quot;已知的未知&amp;quot;转换为&amp;quot;已知的已知&amp;rdquo;。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220526162559859.png" alt="image-20220526162559859">&lt;/p>
&lt;p>但，工程师分三种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>天才型工程师：知识结构大多是已知的已知，这是大神，也是少数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>扎实型工程师：知识结构大多是已知的已知、已知的未知，这是大多数人的可能达到的状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>愚昧型工程师：知识结构大多是未知的知识，这种工程师往往觉得自己就是全世界。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&amp;ldquo;&lt;strong>用到的时候再查文档&lt;/strong>&amp;ldquo;这句话，&lt;/p>
&lt;p>对于扎实性工程师是有效的。&lt;/p>
&lt;p>对于愚昧性工程师是无效的——即便实战时给他充足的时间查资料，首先他都不会去查(因为他不知道)，即便去查也可能查不到、查到也看不懂。&lt;/p>
&lt;p>作者的这个学习论，可以推广到各种知识的学习中。&lt;/p>
&lt;h2 id="为什么实施性能工程很难">为什么实施性能工程很难？&lt;/h2>
&lt;p>作者归纳了实战中性能工程的3个难点：&lt;/p>
&lt;ul>
&lt;li>性能的主观性&lt;/li>
&lt;li>系统的复杂性&lt;/li>
&lt;li>人员的协作性&lt;/li>
&lt;/ul>
&lt;h3 id="性能的主观性">性能的主观性&lt;/h3>
&lt;p>作者认为性能是主观的，同样是&lt;code>磁盘单次IO的时间是1ms&lt;/code>，&lt;/p>
&lt;p>在实时系统场景下是很慢的，在管理信息系统场景下却是很快的。&lt;/p>
&lt;p>因此，性能工程要结合实际产品制定合理、合适的性能标准。&lt;/p>
&lt;h3 id="系统的复杂性">系统的复杂性&lt;/h3>
&lt;p>作者认为&lt;strong>被测系统是复杂的&lt;/strong>，进而&lt;strong>导致2个问题&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>寻找性能问题时，找不到分析的&lt;strong>起点&lt;/strong>。
&lt;ul>
&lt;li>很多性能培训案例，是假定我们已知问题起点了。&lt;/li>
&lt;li>比如：假定我们已经知道就是进程A的线程B疑似死锁了，于是演示各种工具如何证明是死锁。&lt;/li>
&lt;li>关键我们怎么知道就是进程A有性能问题？怎么知道就是线程B有问题？怎么知道就是死锁问题？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解决性能问题时，往往&lt;strong>牵一发而动全身&lt;/strong>。
&lt;ul>
&lt;li>修改死锁问题，可能CPU的瓶颈没有了。&lt;/li>
&lt;li>但，应用程序继续往下一个环节运行，又引发了IO的瓶颈。&lt;/li>
&lt;li>所以才有程序猿感慨：&amp;ldquo;时间是不可能被消灭的，只可能被转移。&amp;ldquo;&lt;img src="https://jherculesqz.github.io/性能拾遗/【宏观】-0-性能之巅笔记-上/image-20220526172626038.png" alt="image-20220526172626038" style="zoom:25%;" />&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="人员的协作性">人员的协作性&lt;/h3>
&lt;p>作者根据经验总结了3个与人相关的问题：&lt;/p>
&lt;ul>
&lt;li>性能工程涉及到产品研发体系的众多角色。比如：系统管理员、应用开发者、DBA、网络工程师。&lt;/li>
&lt;li>角色间的部门墙可能导致性能工程断点。&lt;/li>
&lt;li>即使是性能工程师，也可能专注于某个领域。比如：Java性能工程师、MySQL性能工程师等。&lt;/li>
&lt;/ul>
&lt;p>看来在哪儿都有部门墙，有人的地方就有江湖。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527103458466.png" alt="image-20220527103458466">&lt;/p>
&lt;h1 id="3第二章笔记">3.第二章笔记&lt;/h1>
&lt;p>Brendan Gregg在《性能之巅》第二章主要从6个方面讲了性能工程的方法论：&lt;/p>
&lt;ul>
&lt;li>开展性能工程的21种方法&lt;/li>
&lt;li>被测系统的架构&lt;/li>
&lt;li>被测系统的模型&lt;/li>
&lt;li>性能工程的2种分析视角&lt;/li>
&lt;li>性能指标&lt;/li>
&lt;li>性能工程涉及的数学模型&lt;/li>
&lt;/ul>
&lt;h2 id="开展性能工程的21种方法">开展性能工程的21种方法&lt;/h2>
&lt;p>作者在这一段讲了21种性能工程常用的方法(英文&lt;code>anti-methodologies&lt;/code>)，译者生造了个词——&lt;code>讹方法&lt;/code>。&lt;/p>
&lt;p>&lt;code>讹方法&lt;/code>？难道是&lt;code>讹人&lt;/code>的意思？我选了两种方法说明一下：&lt;/p>
&lt;h3 id="街灯讹方法">街灯讹方法&lt;/h3>
&lt;p>作者讲了个故事：&lt;/p>
&lt;blockquote>
&lt;p>有个醉汉在路灯下找钥匙，警察帮忙找了半天也没找到。&lt;/p>
&lt;p>警察问醉汉确不确定就在这个路灯下丢的钥匙。&lt;/p>
&lt;p>醉汉说：我也不确定，但是这里是最亮的。&lt;/p>
&lt;/blockquote>
&lt;p>这。。。&lt;/p>
&lt;p>不就是某些程序猿定位性能问题但找不到切入点时，先随便怀疑一段代码，碰碰运气吗。。。&lt;/p>
&lt;h3 id="责怪他人讹方法">责怪他人讹方法&lt;/h3>
&lt;p>作者说了一下操作步骤：&lt;/p>
&lt;blockquote>
&lt;p>第一步、找到一个不是自己负责的模块——注意，一定不是自己负责的模块！&lt;/p>
&lt;p>第二步、假定问题就是这个模块造成的。&lt;/p>
&lt;p>第三步、把问题扔给那个模块的负责人。&lt;/p>
&lt;p>第四步、如果那个模块的负责人证明不是他的问题，重复步骤1。&lt;/p>
&lt;/blockquote>
&lt;p>这。。。&lt;/p>
&lt;p>不就是某些程序猿最喜欢干的事儿吗——甩锅大法！！！&lt;/p>
&lt;p>Brendan Gregg竟然给甩锅大法取了这么牛X的名字，还给出了甩锅的详细步骤。。。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527120219336.png" alt="image-20220527120219336">&lt;/p>
&lt;h3 id="赤果果的调侃">赤果果的调侃&lt;/h3>
&lt;p>行了，这一段儿基本可以跳过了。。。&lt;/p>
&lt;p>这一段儿就是作者一本正经地调侃。。。&lt;/p>
&lt;p>当然，以作者的骚气，他在这么权威的书里面写出这种段子，我们也不应该太意外。。。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527114756476.png" alt="image-20220527114756476">&lt;/p>
&lt;h2 id="被测系统的架构">被测系统的架构&lt;/h2>
&lt;p>作者表达了1个观点和1个常用的架构：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>1个观点&lt;/strong>：性能工程是针对整个系统(包括所有硬件和软件栈)，实施性能工程前画出完整的架构图可以避免&lt;code>只见树木不见森林&lt;/code>。&lt;/li>
&lt;li>&lt;strong>1个常用架构&lt;/strong>：如下图。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527121255677.png" alt="image-20220527121255677">&lt;/p>
&lt;h2 id="被测系统的模型">被测系统的模型&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>SUT模型&lt;/strong>：system under test&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527121828041.png" alt="image-20220527121828041">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>排队系统&lt;/strong>：这个模型很重要，作者贯穿全书的理念就是能将所有的性能问题都归纳为排队系统。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527122023060.png" alt="image-20220527122023060">&lt;/p>
&lt;h2 id="性能工程的2种分析视角">性能工程的2种分析视角&lt;/h2>
&lt;p>在梳理好被测系统的架构后，我们有两种选择：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自下而上&lt;/strong>：resource analysis，从硬件、内核、系统调用寻找资源瓶颈，进而定位到应用程序的进程、线程。&lt;/li>
&lt;li>&lt;strong>自上而下&lt;/strong>：workload analysis，从应用程序出发，找到资源瓶颈。&lt;/li>
&lt;/ul>
&lt;p>作者认为，其实两种分析视角要结合起来，才是最有效的性能工程方法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527122439419.png" alt="image-20220527122439419">&lt;/p>
&lt;h2 id="性能指标">性能指标&lt;/h2>
&lt;p>对于常用的性能指标就不展开了。如：延时、响应时间、时间量级、使用率、饱和度等。&lt;/p>
&lt;p>作者重点展开了对&lt;strong>缓存的基础知识&lt;/strong>介绍：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>什么是缓存&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>将数据不再存储在较慢的存储层，而是将数据存储到较快的存储层中。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>典型的缓存&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>CPU的L1、L2、L3缓存&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>缓存的命中率是什么&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>命中率 = 命中次数 / (命中次数+失效次数)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>失效率是什么&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>每秒缓存失效次数&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>命中率、失效率与运行性能的关系&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>运行时间 = 命中率 * 命中延时 + 失效率 * 失效延时&lt;/p>
&lt;p>比如：&lt;/p>
&lt;p>任务1的命中率很高(90%)，失效率也很高(200/s)。&lt;/p>
&lt;p>任务2的命中率略低(80%)，失效率也很低(20/s)。&lt;/p>
&lt;p>那么，最终任务2的性能会更好。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>实现缓存的算法有哪些&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>MRU：将最近最长使用的数据保留在缓存中。&lt;/p>
&lt;p>LRU：将最近最少使用的数据移出缓存。&lt;/p>
&lt;p>其它算法还有NFU、MFU、LFU。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>缓存温度有哪些&lt;/strong>？&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>冷：命中率无限接近于0，比如缓存是空的。&lt;/p>
&lt;p>热：命中率无限接近于预期的高度。&lt;/p>
&lt;p>温：命中率还没有达到预期的高度。比如：缓存中存了一定有用的数据，但不全是有用的数据。&lt;/p>
&lt;/blockquote>
&lt;p>大白话一点，缓存机制的本质和海王海后的鱼塘逻辑差不多：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>MRU、LRU&lt;/strong>：MRU——最近经常撩的，加到鱼塘里、LRU——最近不咋联系的，踢出鱼塘。&lt;/li>
&lt;li>&lt;strong>命中率高、失效率低，性能好&lt;/strong>：鱼塘里都是鱼，鱼还很活跃，随便撩一下都是鱼，你说那啥效率高不高？&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527150414981.png" alt="image-20220527150414981">&lt;/p>
&lt;h2 id="性能工程涉及的数学模型">性能工程涉及的数学模型&lt;/h2>
&lt;h3 id="amdahl扩展定律">Amdahl扩展定律&lt;/h3>
&lt;p>由计算机科学家阿姆达尔，在1967年AFIPS春季联合计算机会议上提出。&lt;/p>
&lt;p>这个阿姆达尔扩展定律的目的是为了预测性能优化到什么程度。&lt;/p>
&lt;p>阿姆达尔定律本质上用严谨的公式证明了&amp;quot;木桶原理&amp;rdquo;——无法优化的那个部件决定了性能优化的上线。&lt;/p>
&lt;p>如果：1个单线程的程序需要20小时，其中有1个小时无法并行化处理，&lt;/p>
&lt;p>那么：将剩余19小时并行化了，最短执行时间也不可能小于1小时。&lt;/p>
&lt;p>因此：我们就可以预测性能优化后可以加速20倍。&lt;/p>
&lt;p>道理很通俗，但科学家需要严谨的公式推导，详细推导过程可以看看维基百科：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">https://en.wikipedia.org/wiki/Amdahl%27s_law&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>但阿姆达尔定律有一个缺陷：以上述案例，是不是我们19个小时的任务并行化，就一定可以将性能优化到1小时呢？&lt;/p>
&lt;p>显然不是——随着CPU增加，可能会达到一个瓶颈点，随后无论怎么增加CPU，性能也不会优化了。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527160717677.png" alt="image-20220527160717677">&lt;/p>
&lt;h3 id="通用扩展定律">通用扩展定律&lt;/h3>
&lt;p>通用扩展定律：Universal Scalability Law，USL。由计算机科学家Neil J. Gunther于2008年提出。&lt;/p>
&lt;p>这个定律就是用来更加精细化地预测：当我持续增加资源，实际的性能优化与阿姆达尔定律的理想化性能优化的偏移量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/%E6%80%A7%E8%83%BD%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91-0-%E6%80%A7%E8%83%BD%E4%B9%8B%E5%B7%85%E7%AC%94%E8%AE%B0-%E4%B8%8A/image-20220527161219066.png" alt="image-20220527161219066">&lt;/p>
&lt;h3 id="排队论">排队论&lt;/h3>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Agner_Krarup_Erlang">Agner Krarup Erlang&lt;/a>于1909年第一次提出了排队理论。&lt;/p>
&lt;p>排队论描述了现实世界中有形、无形的各种排队场景。比如：12306抢票、网红店取号排队、超市排队买单等。&lt;/p>
&lt;p>顾客肯定希望排队越短越好、办事儿时间越快越好。超市安排过多的收银员就浪费了，安排太少的收银员又会被顾客投诉。&lt;/p>
&lt;p>顾客肯定不是按顺序一个个来超市，有可能在一个热点时间一拥而上来超市。&lt;/p>
&lt;p>超市的排队规则是先到先处理，但是车牌摇号就是随机处理了。&lt;/p>
&lt;p>……&lt;/p>
&lt;p>上述这些，就是排队论研究的内容：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>被服务者的到达遵循何种分布&lt;/strong>：如泊松分布。&lt;/li>
&lt;li>&lt;strong>服务机构的服务能力遵循何种统计特征&lt;/strong>：如每个收银员的处理速度。&lt;/li>
&lt;li>&lt;strong>排队的原则是什么&lt;/strong>：如先到先处理or随机处理。&lt;/li>
&lt;li>&lt;strong>排队的Topo结构&lt;/strong>：如超市最多放下10个收银台，那就有10条并行的排队结构。&lt;/li>
&lt;/ul>
&lt;p>最终排队论给出评估：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>怎么排队，收益最大&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>Brendan Gregg的核心观点是：&lt;/p>
&lt;ul>
&lt;li>无论应用程序，还是CPU、IO、网络、磁盘都可以用排队模型化。&lt;/li>
&lt;li>按照排队论，多种性能优化手段，最终一定有一个从&amp;quot;运筹学&amp;quot;上性能收益最大的选择。&lt;/li>
&lt;/ul>
&lt;p>理解排队论的推导，对于笔者还很困难，各位读者有兴趣可以参考相关资料：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://zh.m.wikipedia.org/zh-sg/%E7%AD%89%E5%80%99%E7%90%86%E8%AB%96">https://zh.m.wikipedia.org/zh-sg/%E7%AD%89%E5%80%99%E7%90%86%E8%AB%96&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="基本统计指标">基本统计指标&lt;/h3>
&lt;p>平均值、标准方差、百分位数、中位数、变异系数、多重模态分布、异常值，这些都是数理统计的基本概念，不赘述了。&lt;/p>
&lt;h1 id="4第一章第二章小结">4.第一章/第二章小结&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>未知的未知&lt;/strong>：Brendan Gregg的观点很赞，知道的越多就更容易知道自己的无知。&lt;/li>
&lt;li>&lt;strong>性能工程的视角&lt;/strong>：利用操作系统的工具链定位出CPU/内存/IO/网络的瓶颈找到性能切入点，进而定位到应用程序的进程/线程，虽然技能要求高，但能获得逻辑自洽的逻辑链，比撞大运靠谱。&lt;/li>
&lt;li>&lt;strong>性能工程的工程方法依托于数学&lt;/strong>：阿姆达尔定律、通用扩展定律、排队论，世界的尽头果然是数学啊。&lt;/li>
&lt;/ul>
&lt;h1 id="5参考文献">5.参考文献&lt;/h1>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">《性能之巅》第一章、第二章
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item></channel></rss>