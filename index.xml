<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>妙木山</title><link>https://jherculesqz.github.io/</link><description>Recent content on 妙木山</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 06 Aug 2021 15:00:31 +0800</lastBuildDate><atom:link href="https://jherculesqz.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>关于</title><link>https://jherculesqz.github.io/about/</link><pubDate>Thu, 05 Aug 2021 13:01:37 +0800</pubDate><guid>https://jherculesqz.github.io/about/</guid><description>&lt;h1 id="关于博客">关于博客&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>独立&lt;/strong>：一直在写技术博客，从微信公众号、头条号、SegmentFault、掘金、简书一路折腾过来，还是希望有一个自己独立的空间。&lt;/li>
&lt;li>&lt;strong>坚持&lt;/strong>：随着年龄增长，逐渐欲说还休，还是文字更有韵味，希望自己能坚持写下去。&lt;/li>
&lt;li>&lt;strong>浪漫&lt;/strong>：按照&lt;a href="https://archiveprogram.github.com">Archive Program&lt;/a>计划的愿景，我的博客会在&amp;rdquo; GitHub北极代码库&amp;quot;中保存千年。想想1000年以后，我的后代们能读到我这个中二祖先的文字，还是一件挺浪漫的事儿。&lt;/li>
&lt;li>&lt;strong>感谢&lt;/strong>：感谢GitHub Pages、Hugo、Jane提供的技术支持。&lt;/li>
&lt;li>&lt;strong>妙木山&lt;/strong>：妙木山是修炼仙术的地方，作为火影的死忠粉，&amp;ldquo;妙木山&amp;quot;无比适合这个博客的定位——修炼、探索。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/about/MiaoMu.png" alt="MiaoMu">&lt;/p>
&lt;h1 id="关于我">关于我&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>行业&lt;/strong>：软件行业16年，无法用语言表达对编程的喜爱——举个栗子吧：有段时间喜欢在酒吧里写代码，同去的小伙伴无聊地陌陌上约人，自我介绍就是&amp;quot;A+吧台，旁边有个写代码的沙雕&amp;rdquo;。&lt;/li>
&lt;li>&lt;strong>技术方向&lt;/strong>：近几年痴迷语言和编译器技术，还有点痴迷计算机图形学。
&lt;ul>
&lt;li>&lt;strong>编程语言&lt;/strong>：目前工作Java和JavaScript用的最多，但我最喜欢C#——PHP是最好的语言，行了吧！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>哲学&lt;/strong>：不知何时，开始期待理解生命的意义。东一本西一本的书拿来乱翻，也没找到答案。不过，也不是全无收获——能模模糊糊地体会诗词的意境、能回味出毛选的奇妙、能敬畏金刚经的高深……继续求索吧……&lt;/li>
&lt;li>&lt;strong>兴趣&lt;/strong>：年轻的时候，喜欢轮滑、滑板、快乐肥仔水。现在，喜欢滑雪、乒乓球、茶(特指正山小种)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/about/Me.png" alt="Me">&lt;/p></description></item><item><title>【执行引擎】-1-理清前端编译、即时编译、提前编译</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/</link><pubDate>Fri, 06 Aug 2021 15:00:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/</guid><description>&lt;h1 id="1如何学习jit">1.如何学习JIT？&lt;/h1>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/1.png" alt="1">&lt;/p>
&lt;p>查阅java.exe文档，有三个参数：&lt;code>-Xcomp&lt;/code>、&lt;code>-Xint&lt;/code>、&lt;code>-Xmixed&lt;/code>，引发了笔者的思考：&lt;/p>
&lt;p>虽然JIT是JVM中技术含量极高的核心特性之一，但实战中我们却极少触及(除非您从事的是编译器相关的工作)。&lt;/p>
&lt;p>我们应该如何快速了解JIT的各种编译模式？如何针对性地在实战灵活使用它们？本着将围绕上述问题与读者展开探讨。&lt;/p>
&lt;h1 id="1试题">1.试题&lt;/h1>
&lt;h2 id="11java试题">1.1.Java试题&lt;/h2>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">JVM中，可以通过哪种参数，强制虚拟机不使用即时编译器？
A.-clint
B.-server
C.-Xint
D.-Xcomp
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>答案：C&lt;/p>
&lt;h2 id="12试题解读">1.2.试题解读&lt;/h2>
&lt;p>本题考查的知识点是JIT(Just-In-Time compilation)，java.exe的命令行参数支持强制虚拟机以不同模式(解释模式、编译模式、混合模式)运行。&lt;/p>
&lt;p>虽然JIT是JVM中技术含量极高的核心特性之一，但实战中我们却极少触及(除非您从事的是编译器相关的工作)。&lt;/p>
&lt;p>我们应该如何快速了解JIT的各种编译模式？如何针对性地在实战灵活使用它们？本着将围绕上述问题与读者展开探讨。&lt;/p>
&lt;h1 id="2对立统一编译能力的技术指标">2.对立统一：编译能力的技术指标&lt;/h1>
&lt;h2 id="21在折腾啥">2.1.在折腾啥？&lt;/h2>
&lt;p>了解编译能力技术指标之前，我们先搞清楚现代编译器在折腾啥？&lt;/p>
&lt;p>主流编程语言可以分为2种编译流派：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>直奔主题派&lt;/strong>：编译期直接生成机器码，以C/C++为例：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/2.png" alt="2">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>含蓄婉约派&lt;/strong>：编译期不直接生成机器码，以Java为例：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/3.png" alt="3">&lt;/p>
&lt;p>这里存在一个有趣的技术细节：&lt;code>是不是含蓄婉约派都是在运行时获得机器码呢？&lt;/code>，答案是否定的：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>纯解释器时代&lt;/strong>：在Java的初期版本，仅依靠解释器，在这个时期，Java是运行时获得机器码的。&lt;/li>
&lt;li>&lt;strong>解释器+即时编译器时代&lt;/strong>：纯解释器引发了&lt;code>Java的执行性能远低于C/C++&lt;/code>的诟病，于是Java很快就有了即时编译器。在这个时期，Java虽然还是在运行时获得机器码，但机器码除了来自于解释器，很大部分可能来自于即时编译器(被JIT识别为热点代码的字节码会被编译成机器码缓存下来，减少解释器在运行时重复编译的损耗)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/image-20210806114107579.png" alt="image-20210806114107579">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>提前编译器时代&lt;/strong>：随着云原生、大数据等业务领域出现，Java也提供了提前编译器。在这个时期，Java就有可能从编译期获得机器码。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/image-20210806114918865.png" alt="image-20210806114918865">&lt;/p>
&lt;p>上面这个技术细节的有趣之处在于：它体现了现代编译器在编译技术上面临的挑战与发展趋势。&lt;/p>
&lt;p>&lt;a href="http://www.best-of-robotics.org/pages/publications/gherardi12java.pdf">《A Java vs. C++ performance evaluation: a 3D modeling benchmark》&lt;/a>这篇论文，对Java和C++进行性能测试，得到的3个观点也在说明这个趋势：&lt;/p>
&lt;ul>
&lt;li>在纯解释器模式下，Java速度比C++慢10+倍。&lt;/li>
&lt;li>在解释器+即时编译模式下，Java比C++平均慢1.45到2.91倍。
&lt;ul>
&lt;li>在Long-running应用中(JVM有机会进入热机状态)，Java比C++慢1.09~1.91倍。&lt;/li>
&lt;li>在Short-running应用中(JVM无机会进入冷机状态)，Java比C++慢2.72~5.61倍。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>JIT(即时编译器)无论如何优化，也无法忽视AOT(提前编译器)带来的优势。&lt;/li>
&lt;/ul>
&lt;p>我们可以看到，现代编译器在折腾3个东西：&lt;/p>
&lt;ul>
&lt;li>静态编译(前端编译)&lt;/li>
&lt;li>即时编译&lt;/li>
&lt;li>提前编译&lt;/li>
&lt;/ul>
&lt;h2 id="22折腾的原动力对立统一的编译能力技术指标">2.2.折腾的原动力：对立统一的编译能力技术指标&lt;/h2>
&lt;p>如果说互联网高速发展的源动力是人们对苍老师和PxxxHub的需要，那么现代编译器的驱动力是矛盾的评价指标：&lt;/p>
&lt;ul>
&lt;li>代码优化质量&lt;/li>
&lt;li>编译速度&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/image-20210806152946493.png" alt="image-20210806152946493">&lt;/p>
&lt;p>&lt;strong>首先，代码优化是很有灰度的工作：&lt;/strong>&lt;/p>
&lt;p>无论编译器如何发展，它们都必须心存敬畏地讨好它们的神——&lt;code>CPU&lt;/code>&lt;/p>
&lt;p>代码优化就是在做&lt;code>讨好CPU&lt;/code>的工作。&lt;/p>
&lt;p>但，过犹不及地&lt;code>讨好&lt;/code>就上升为了&lt;code>欺骗&lt;/code>，马屁拍到马腿上的后果就是&lt;code>过度地代码优化&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/image-20210806135534437.png" alt="image-20210806135534437">&lt;/p>
&lt;p>&lt;strong>其次，在高质量地优化代码的前提下，还要保证编译速度。&lt;/strong>&lt;/p>
&lt;p>一个质量指标，一个效率指标，两个矛盾的指标，最终&lt;strong>催生了对立统一的优化手段&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>解释器+即时编译器混合模式：先基于解释器解释获得机器码，然后将热点代码交给即时编译器获得机器码并缓存&lt;/p>
&lt;ul>
&lt;li>即时编译器优化先做激进优化，激进优化成功了就缓存激进优化后的机器码&lt;/li>
&lt;li>即时编译器激进优化失败了，就降低代码优化级别，再缓存保守优化的机器码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>提前编译模式：啥也不说了，直接一步到位的获得机器码&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明：在虚拟机类型的世界里，有个假设，静态编译永远不如即时编译和提前编译的代码优化质量好。&lt;/p>
&lt;/blockquote>
&lt;h2 id="23各领风骚">2.3.各领风骚&lt;/h2>
&lt;p>了解了编译器的技术指标，也就了解了编译器追求的方向，也就形成了这3类编译器各领风骚的技术发展现状。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>各厂家持续在即时编译器领域发力&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>如下图所示，Hotspot虚拟机的即时编译器就包含了C1和C2，同时在Java10加入了C2的替代者Graal。&lt;/p>
&lt;blockquote>
&lt;p>说明：C1的职责只是常规的编译优化，C2则承担了更多激进优化的任务。。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>各厂家在探索提前编译器&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>如下图所示，Hotspot虚拟机提供了实验性质的jaotc。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/5.png" alt="5">&lt;/p>
&lt;h1 id="3实战中的应用场景">3.实战中的应用场景&lt;/h1>
&lt;h2 id="31场景1解释器c1c2">3.1.场景1：解释器+C1+C2&lt;/h2>
&lt;p>在实战环境中，解释模式+C1+C2是最常用的应用场景。&lt;/p>
&lt;p>以Hotspot为例，解释器与即时编译器的配合过程：首先还是解释器工作，然后热点代码触发即时编译器，即时编译一旦出现激进优化失败就优化降级，甚至把执行权还给解释器。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/6.png" alt="6">&lt;/p>
&lt;p>上图特指Java7及更高版本，在这个前提下，才会有C1和C2，才会发生激进优化、优化降级，这个过程称为&lt;code>分层编译&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>说明：本文不展开分层编译原理。&lt;/p>
&lt;/blockquote>
&lt;h2 id="32场景2解释器">3.2.场景2：解释器&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/image-20210806144744523.png" alt="image-20210806144744523">&lt;/p>
&lt;p>如上图所示，解释器+即时编译器模式挺好，为啥还需要纯粹的解释器模式呢？实战中，这种一般用于性能调优和测试。&lt;/p>
&lt;p>由于C1和C2的代码优化，我们在产品代码中编写的&lt;code>性能不太友好&lt;/code>的代码可能被JVM自动优化掉。&lt;/p>
&lt;p>但，我们就不能精准、高效地发现这些&lt;code>性能不友好&lt;/code>的代码了。&lt;/p>
&lt;p>所以JVM才通过java.exe的参数提供了这种强制关闭即时编译器的开关。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/1.png" alt="1">&lt;/p>
&lt;p>JVM默认采用混合模式运行(无论JVM处于client模式还是server模式)：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-1-%E7%90%86%E6%B8%85%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91/image-20210806145459698.png" alt="image-20210806145459698">&lt;/p>
&lt;p>在java.exe的参数中，提供了三个参数，强制控制运行模式：&lt;/p>
&lt;ul>
&lt;li>-Xint：强制虚拟机运行于解释模式。&lt;/li>
&lt;li>-Xcomp:强制虚拟机运行于编译模式&lt;/li>
&lt;li>-Xmixed:运行于混合模式&lt;/li>
&lt;/ul>
&lt;h1 id="4总结">4.总结&lt;/h1>
&lt;p>本文主要内容：&lt;/p>
&lt;ul>
&lt;li>编译器技术指标：代码优化质量、编译速度。&lt;/li>
&lt;li>各厂商重点在即时编译器领域发力，在提前编译器领域探索。&lt;/li>
&lt;li>生产环境上，通常采用解释器+C1+C2模式。&lt;/li>
&lt;li>开发态做性能调优，可以采用强制解释器模式。&lt;/li>
&lt;/ul>
&lt;h1 id="5参考文献">5.参考文献&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>【编译引擎】-4-学习阅读Class文件指令-概览</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/</link><pubDate>Thu, 05 Aug 2021 15:05:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/</guid><description>&lt;h1 id="1前言">1.前言&lt;/h1>
&lt;p>在《【编译引擎】学习阅读Class文件结构(javap版)》中，我们看到了Code属性包含了JVM指令序列。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702135411052.png" alt="image-20210702135411052">&lt;/p>
&lt;p>在理解了Class文件结构之后，学习JVM指令有助于我们更进一步地理解Class文件结构。&lt;/p>
&lt;p>然而，JVM指令是JVM规范另一个大篇幅知识点，我们应该如何高效学习它呢？&lt;/p>
&lt;p>本文将通过上述代码，阐述JVM指令的执行过程(例如：局部变量表中的数据入栈、栈上数据存储回局部变量表等)，为读者展示JVM指令的全貌以及学习方法。&lt;/p>
&lt;h1 id="2jvm指令概览">2.JVM指令概览&lt;/h1>
&lt;h2 id="21本质-信息压缩">2.1.本质-信息压缩&lt;/h2>
&lt;p>在学习具体的JVM之前，我们应该先来看看JVM指令的本质以及它存在的意义。&lt;/p>
&lt;p>不知道您是否考虑过这样一个问题：&amp;ldquo;如何表达一个方法的实现呢？&amp;rdquo;&lt;/p>
&lt;p>您可能会说：可以用代码来描述，如下伪码所示：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kt">void&lt;/span> &lt;span class="nf">func1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">print&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么，我们把问题增加一些限制：&amp;ldquo;如何用最小的信息量表达一个方法的实现？&amp;rdquo;&lt;/p>
&lt;p>聪明的读者可能会想到&amp;quot;代号法&amp;rdquo;，即为上述伪码取个特殊的代号(假设&amp;quot;int i = 1&amp;quot;的代号是&amp;quot;帅哥&amp;rdquo;，&amp;ldquo;print(i)&amp;ldquo;的代号是&amp;quot;美女&amp;rdquo;)，那么上述伪码可以简化为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kt">void&lt;/span> &lt;span class="nf">func1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">帅哥&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">美女&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们继续把问题增加一些限制：&amp;ldquo;如何用计算机能理解的最小信息量表达一个方法的实现？&amp;rdquo;&lt;/p>
&lt;p>什么是计算机能理解的信息？显然是字节。所以，我们可以约定&amp;quot;0A&amp;quot;就是&amp;quot;帅哥&amp;rdquo;，&amp;ldquo;0B&amp;quot;就是&amp;quot;美女&amp;rdquo;，如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kt">void&lt;/span> &lt;span class="nf">func1&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">0A&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">0B&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样的信息，在某些场景下(对于人)越大越好，在某些场景下(对于机器)越小越好。&lt;/p>
&lt;p>更关键的是，二者能相互转换——这就好像三体中智子的高维折叠和低维展开。&lt;/p>
&lt;p>这或许就是计算机的世界中，最令人着迷的地方。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702144922740.png" alt="image-20210702144922740">&lt;/p>
&lt;h2 id="22jvm指令格式">2.2.JVM指令格式&lt;/h2>
&lt;p>JVM指令的格式一般是这样的：&lt;/p>
&lt;blockquote>
&lt;p>操作码+操作数&lt;/p>
&lt;/blockquote>
&lt;p>操作码为1个字节，在JVM规范中约定了这个字节表达的具体的JVM指令含义。&lt;/p>
&lt;p>这是一个有趣的细节：1个字节是8位，所以JVM指令的操作码最多只有255个&lt;/p>
&lt;p>操作数可以没有，也可能有多个。&lt;/p>
&lt;h2 id="23jvm指令分类">2.3.JVM指令分类&lt;/h2>
&lt;p>JVM规范中的JVM指令非常多，我们可以根据指令的使用场景分类，本文仅列举实战中最常用的场景：&lt;/p>
&lt;ul>
&lt;li>加载与存储：比如将局部变量表的数据放到虚拟机栈中&lt;/li>
&lt;li>算数指令：比如i++&lt;/li>
&lt;li>类型转换指令：比如int转double&lt;/li>
&lt;li>对象创建/字段访问：比如创建一个类的实例，并且访问该实例的某个属性&lt;/li>
&lt;li>方法调用：比如访问一个类的静态方法&lt;/li>
&lt;li>异常处理：比如抛出一个异常&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;h2 id="24真理都在规范中">2.4.真理都在规范中&lt;/h2>
&lt;p>当我们具备了前面的基本知识，最高效、最准确地学习JVM指令，就要查阅JVM规范了：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702150908956.png" alt="image-20210702150908956">&lt;/p>
&lt;h1 id="3实例解读">3.实例解读&lt;/h1>
&lt;p>为了方便阅读，我们将javap输出的日志简化后展示如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">String&lt;/span>&lt;span class="o">[]);&lt;/span>
&lt;span class="err">……………………&lt;/span>
&lt;span class="n">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">getstatic&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="c1">// Field java/lang/System.out:Ljava/io/PrintStream;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ldc&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="c1">// String start
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">5&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokevirtual&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="c1">// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">8&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokestatic&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">5&lt;/span> &lt;span class="c1">// Method test:()V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">11&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">getstatic&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="c1">// Field java/lang/System.out:Ljava/io/PrintStream;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">14&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ldc&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">6&lt;/span> &lt;span class="c1">// String end
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">16&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokevirtual&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="c1">// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">19&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span>
&lt;span class="err">……………………&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">test&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="err">……………………&lt;/span>
&lt;span class="n">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">7&lt;/span> &lt;span class="c1">// class java/lang/IllegalArgumentException
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">dup&lt;/span>
&lt;span class="n">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ldc&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">8&lt;/span> &lt;span class="c1">// String exception
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">6&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokespecial&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">9&lt;/span> &lt;span class="c1">// Method java/lang/IllegalArgumentException.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:(Ljava/lang/String;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">9&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">athrow&lt;/span>
&lt;span class="err">……………………&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="31对象创建指令">3.1对象创建指令&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702152821188.png" alt="image-20210702152821188">&lt;/p>
&lt;p>new是操作码，#7是操作数。&lt;/p>
&lt;p>#7表示常量池中的常量，从javap的输出可知，#7表示IllegalArgumentException异常。&lt;/p>
&lt;p>new表示创建了IllegalArgumentException异常对象。&lt;/p>
&lt;p>创建了异常对象后，对象本身放到堆中，对象的内存地址会放到栈中。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702152324438.png" alt="image-20210702152324438">&lt;/p>
&lt;p>下一步就是dup，dup只有操作码，没有操作数。&lt;/p>
&lt;p>dup就是将栈中前一个元素进行了复制。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702152609221.png" alt="image-20210702152609221">&lt;/p>
&lt;p>那么为什么要dup呢？&lt;/p>
&lt;p>这就涉及到后面方法调用的指令了，当执行了&lt;code>invokespecial&lt;/code>指令，就会将栈中的&lt;code>#0001&lt;/code>出栈。&lt;/p>
&lt;p>所以，一般创建了对象后，会紧跟着dup一下。&lt;/p>
&lt;h2 id="32常量入栈指令">3.2.常量入栈指令&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702152857941.png" alt="image-20210702152857941">&lt;/p>
&lt;p>ldc是操作码，#8是操作数。&lt;/p>
&lt;p>根据javap的输出提示，#8表示的是字符串类型常量&amp;quot;exception&amp;rdquo;。&lt;/p>
&lt;p>ldc负责将这个常量入栈：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702153046669.png" alt="image-20210702153046669">&lt;/p>
&lt;h2 id="33方法调用指令">3.3.方法调用指令&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702153131436.png" alt="image-20210702153131436">&lt;/p>
&lt;p>invokespecial是操作码，#9是操作数&lt;/p>
&lt;p>#9表示&lt;code>IllegalArgumentException&lt;/code>异常的构造函数&lt;/p>
&lt;p>invokespecial表示了调用特定的函数，在这里调用的是&lt;code>IllegalArgumentException&lt;/code>异常的构造函数，并且需要给构造函数输入一个字符串参数&amp;quot;exception&amp;rdquo;。&lt;/p>
&lt;p>此时运行时数据区变成了这样：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702153403860.png" alt="image-20210702153403860">&lt;/p>
&lt;h2 id="34异常处理指令">3.4.异常处理指令&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702153452470.png" alt="image-20210702153452470">&lt;/p>
&lt;p>athrow只有操作码，表示抛出&lt;code>IllegalArgumentException&lt;/code>异常，并结束了test方法。&lt;/p>
&lt;p>至此，我们通过test()方法，就覆盖了JVM指令主要的4个场景：创建对象-&amp;gt;常量入栈-&amp;gt;调用方法-&amp;gt;抛出异常。&lt;/p>
&lt;h2 id="35main函数的jvm指令执行过程">3.5.main函数的JVM指令执行过程&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-4-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E6%8C%87%E4%BB%A4-%E6%A6%82%E8%A7%88/image-20210702153713484.png" alt="image-20210702153713484">&lt;/p>
&lt;p>有了3.1~3.4的基础，我们再看main函数的执行就很容易举一反三了：&lt;/p>
&lt;p>&lt;code>getstatic #2&lt;/code>属于类/对象的属性获取场景，即将System.out放到栈中&lt;/p>
&lt;p>&lt;code>invokevirtual #4&lt;/code>类似invokestatic指令，也是调用方法，即调用System.out.println&lt;/p>
&lt;p>此时，控制台打印了&amp;quot;start&amp;rdquo;。&lt;/p>
&lt;p>执行到invokestatic #5，即执行了test()方法，会抛出异常，导致main函数不再往下执行后面的JVM指令。&lt;/p>
&lt;p>因此，最终控制台打印了start后抛出&lt;code>IllegalArgumentException&lt;/code>异常&lt;/p>
&lt;h1 id="4总结">4.总结&lt;/h1>
&lt;p>本文接着javap案例，进一步解读了javap的JVM指令部分，具体如下：&lt;/p>
&lt;ul>
&lt;li>JVM指令的本质是信息压缩&lt;/li>
&lt;li>JVM指令格式一般包含1个操作码+N个操作数&lt;/li>
&lt;li>可以根据场景对JVM指令分类，有助于高效学习JVM指令&lt;/li>
&lt;li>通过一个示例代码，解读了JVM指令的运行过程&lt;/li>
&lt;/ul>
&lt;h1 id="5参考资料">5.参考资料&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html&lt;/a>&lt;/p>
&lt;p>《深入理解Java虚拟机：JVM高级特性与最佳实践》&lt;/p>
&lt;/blockquote></description></item><item><title>【编译引擎】-3-学习阅读Class文件结构(javap版)</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84javap%E7%89%88/</link><pubDate>Thu, 05 Aug 2021 15:00:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84javap%E7%89%88/</guid><description>&lt;h1 id="1前言">1.前言&lt;/h1>
&lt;p>在《【编译引擎】学习阅读Class文件结构(16进制版)》中，我们一起直接阅读了Class文件的16进制版本。&lt;/p>
&lt;p>虽然这种方式可以帮助我们深刻理解Class文件结构，但如果您从事的是应用软件开发(而不是编译器相关工作)，这样就比较低效了。&lt;/p>
&lt;p>今天我们就来看看JVM提供的javap，如何提升我们解读Class结构的工作效率。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210129115436313.png" alt="image-20210129115436313">&lt;/p>
&lt;h1 id="2javap">2.javap&lt;/h1>
&lt;h2 id="21命令行学习方法">2.1.命令行学习方法&lt;/h2>
&lt;p>最好的学习资源就是官方文档：&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.oracle.com/en/java/javase/11/tools/javap.html#GUID-BE20562C-912A-4F91-85CF-24909F212D7F">https://docs.oracle.com/en/java/javase/11/tools/javap.html#GUID-BE20562C-912A-4F91-85CF-24909F212D7F&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>在这里，我们可以获得最全面的javap使用指导。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604135122739.png" alt="image-20210604135122739">&lt;/p>
&lt;h2 id="22命令行详解">2.2.命令行详解&lt;/h2>
&lt;h3 id="221javap的命令行结构">2.2.1.javap的命令行结构&lt;/h3>
&lt;blockquote>
&lt;p>javap [options] classfiles&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>[options]：javap的命令行选项&lt;/p>
&lt;p>classfiles：是我们需要反汇编的一个或多个类文件。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604135556794.png" alt="image-20210604135556794">&lt;/p>
&lt;h3 id="222最常用的options">2.2.2.最常用的options&lt;/h3>
&lt;p>实战中，比较常用的options是输出所有显示所有类和成员、输出类的附件信息(如：堆栈大小、局部变量数量和方法的参数)&lt;/p>
&lt;blockquote>
&lt;p>javap -v -p Test.class&lt;/p>
&lt;/blockquote>
&lt;p>其中，&lt;/p>
&lt;ul>
&lt;li>-v：输出类的附件信息(如：堆栈大小、局部变量数量和方法的参数)&lt;/li>
&lt;li>-p：显示所有的类和成员&lt;/li>
&lt;/ul>
&lt;h3 id="223梳理options">2.2.3.梳理options&lt;/h3>
&lt;p>在官方文档中，javap的options很多，笔者做了这样的归类：&lt;/p>
&lt;ul>
&lt;li>与类有关的options：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>-l：打印行和局部变量表&lt;/p>
&lt;p>-package：显示程序包/受保护的/公共类和成员 (默认)&lt;/p>
&lt;p>-public：只显示公共类和成员&lt;/p>
&lt;p>-protected：只显示受保护的和公共的类和成员&lt;/p>
&lt;p>-p -private：显示所有的类和成员&lt;/p>
&lt;p>-s：打印内部类型签名&lt;/p>
&lt;p>-constants：显示static final常量&lt;/p>
&lt;p>-c：打印类中每个方法的反汇编代码，例如，组成Java字节码的指令&lt;/p>
&lt;p>-v，-verbose：打印堆栈大小、局部变量数量和方法的参数&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>与JVM有关的options：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>-classpath &lt;path>，-cp &lt;path>：指定javap命令用于查找类的路径。覆盖默认的CLASSPATH环境变量
-bootclasspath &lt;path>：指定加载引导类的路径。默认情况下，引导类是实现位于jre/lib/rt.jar和其它几个jar
-extdir dirs：覆盖扩展类的位置。扩展的默认位置是java.ext.dirs的值
Joption：将指定的选项传递给JVM(JVM的options详见java命令文档)
eg:
javap -J-version
javap -J-Djava.security.manager -J-Djava.security.policy=MyPolicy MyClassName
-sysinfo：显示正在处理的类的系统信息(路径、大小、日期、MD5哈希值)&lt;/p>
&lt;/blockquote>
&lt;h3 id="224javap的形和神">2.2.4.javap的形和神&lt;/h3>
&lt;p>前面解读了javap的命令行手册，这些只能算作javap的形，也比较好掌握，我们看看官方文档的javap输出的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">Compiled&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="s">&amp;#34;HelloWorldFrame.java&amp;#34;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">HelloWorldFrame&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">javax&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">swing&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">JFrame&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">java&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">String&lt;/span> &lt;span class="n">message&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="nf">HelloWorldFrame&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">Code&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokespecial&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="c1">// Method javax/swing/JFrame.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">5&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ldc&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="c1">// String Hello World!
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">7&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">putfield&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="c1">// Field message:Ljava/lang/String;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">11&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="c1">// class HelloWorldFrame$1
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">14&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">dup&lt;/span>
&lt;span class="n">15&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">16&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokespecial&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">5&lt;/span> &lt;span class="c1">// Method HelloWorldFrame$1.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:(LHelloWorldFrame;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">19&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokevirtual&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">6&lt;/span> &lt;span class="c1">// Method setContentPane:(Ljava/awt/Container;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">22&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">23&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">bipush&lt;/span> &lt;span class="n">100&lt;/span>
&lt;span class="n">25&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">bipush&lt;/span> &lt;span class="n">100&lt;/span>
&lt;span class="n">27&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokevirtual&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">7&lt;/span> &lt;span class="c1">// Method setSize:(II)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">30&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">java&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">String&lt;/span>&lt;span class="o">[]);&lt;/span>
&lt;span class="n">Code&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">8&lt;/span> &lt;span class="c1">// class HelloWorldFrame
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">dup&lt;/span>
&lt;span class="n">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokespecial&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">9&lt;/span> &lt;span class="c1">// Method &amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">7&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">astore_1&lt;/span>
&lt;span class="n">8&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_1&lt;/span>
&lt;span class="n">9&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">iconst_1&lt;/span>
&lt;span class="n">10&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokevirtual&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">10&lt;/span> &lt;span class="c1">// Method setVisible:(Z)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">13&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>不了解JVM字节码的程序猿依然看不懂，这些就是javap的神。&lt;/p>
&lt;p>这就好像&lt;code>辟邪剑法&lt;/code>与&lt;code>辟邪剑谱&lt;/code>的关系。&lt;/p>
&lt;p>接下来，我们就来解读一下javap的输出结果——字节码。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604142536789.png" alt="image-20210604142536789">&lt;/p>
&lt;h1 id="3javap输出结果解读">3.javap输出结果解读&lt;/h1>
&lt;blockquote>
&lt;p>说明：Java虚拟机规范中很大的篇幅就是约定字节码各个Section的职责、含义、约束，以及JVM指令集，本文不可能一一详尽阐述。因此本文聚焦于解读字节码的总体结构，旨在最快速地为大家建立Class文件结构的脉络，后续案例也会进一步展开字节码技术，对试题进行更有深度的解读。&lt;/p>
&lt;/blockquote>
&lt;h2 id="31字节码的基础知识">3.1.字节码的基础知识&lt;/h2>
&lt;p>为了便于不太了解JVM字节码的程序猿更快进入下一章节，我们简单回顾和小结一下字节码的知识：&lt;/p>
&lt;ul>
&lt;li>STEP1.我们通过java命令，将.java文件转化为.class文件(也就是字节码)&lt;/li>
&lt;li>STEP2.字节码文件本身是什么呢？我们可以用16进制编辑器打开它&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>字节码文件本身就是一串字节流。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604144157084.png" alt="image-20210604144157084">&lt;/p>
&lt;ul>
&lt;li>STEP3.为了看的更加清楚一些，我们将有关联的字节用同一种颜色着色：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果您做过网络协议的开发，会发现字节码(字节流)与协议栈(如：ModBus)的逻辑很类似，几个字节为一组表达一个信息。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604144211764.png" alt="image-20210604144211764">&lt;/p>
&lt;ul>
&lt;li>STEP4.抽象一下上述着色字节流，我们可以将Class文件结构抽象如下&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>字节码基础属性&lt;/p>
&lt;p>常量池：占据字节码文件最大的篇幅&lt;/p>
&lt;p>类的基本信息：包含类名的索引、类访问标识、父类名的索引、实现了多少接口等信息&lt;/p>
&lt;p>字段列表：包含有多少字段，每个字段名的索引、访问标识等&lt;/p>
&lt;p>方法列表：包含多少方法，每个方法名的索引、访问标识、方法的实现等&lt;/p>
&lt;p>附加属性&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604145305097.png" alt="image-20210604145305097">&lt;/p>
&lt;h2 id="32通过示例代码解读javap的输出">3.2.通过示例代码，解读javap的输出&lt;/h2>
&lt;p>我们以一段示例代码，来解读javap的输出：&lt;/p>
&lt;ul>
&lt;li>示例代码：&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604150455456.png" alt="image-20210604150455456">&lt;/p>
&lt;ul>
&lt;li>javap输出&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;span class="lnt">60
&lt;/span>&lt;span class="lnt">61
&lt;/span>&lt;span class="lnt">62
&lt;/span>&lt;span class="lnt">63
&lt;/span>&lt;span class="lnt">64
&lt;/span>&lt;span class="lnt">65
&lt;/span>&lt;span class="lnt">66
&lt;/span>&lt;span class="lnt">67
&lt;/span>&lt;span class="lnt">68
&lt;/span>&lt;span class="lnt">69
&lt;/span>&lt;span class="lnt">70
&lt;/span>&lt;span class="lnt">71
&lt;/span>&lt;span class="lnt">72
&lt;/span>&lt;span class="lnt">73
&lt;/span>&lt;span class="lnt">74
&lt;/span>&lt;span class="lnt">75
&lt;/span>&lt;span class="lnt">76
&lt;/span>&lt;span class="lnt">77
&lt;/span>&lt;span class="lnt">78
&lt;/span>&lt;span class="lnt">79
&lt;/span>&lt;span class="lnt">80
&lt;/span>&lt;span class="lnt">81
&lt;/span>&lt;span class="lnt">82
&lt;/span>&lt;span class="lnt">83
&lt;/span>&lt;span class="lnt">84
&lt;/span>&lt;span class="lnt">85
&lt;/span>&lt;span class="lnt">86
&lt;/span>&lt;span class="lnt">87
&lt;/span>&lt;span class="lnt">88
&lt;/span>&lt;span class="lnt">89
&lt;/span>&lt;span class="lnt">90
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="n">javap&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">v&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="n">Demo2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>
&lt;span class="n">Classfile&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="n">C&lt;/span>&lt;span class="o">:/&lt;/span>&lt;span class="n">Demo2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">class&lt;/span>
&lt;span class="n">Last&lt;/span> &lt;span class="n">modified&lt;/span> &lt;span class="n">2021&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">25&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">size&lt;/span> &lt;span class="n">613&lt;/span> &lt;span class="n">bytes&lt;/span>
&lt;span class="n">MD5&lt;/span> &lt;span class="n">checksum&lt;/span> &lt;span class="n">f7c661d99330a1eefb32b6429e5a48b4&lt;/span>
&lt;span class="n">Compiled&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="s">&amp;#34;Demo2.java&amp;#34;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">com&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">firelord&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">zsample&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">jvm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">frontcompiler&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Demo2&lt;/span>
&lt;span class="n">minor&lt;/span> &lt;span class="n">version&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="n">major&lt;/span> &lt;span class="n">version&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">52&lt;/span>
&lt;span class="n">flags&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ACC_PUBLIC&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">ACC_SUPER&lt;/span>
&lt;span class="n">Constant&lt;/span> &lt;span class="n">pool&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Methodref&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">7&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">21&lt;/span> &lt;span class="c1">// java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Fieldref&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">6&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">22&lt;/span> &lt;span class="c1">// com/firelord/zsample/lang/jvm/frontcompiler/Demo2.field1:I
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Fieldref&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">23&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">24&lt;/span> &lt;span class="c1">// java/lang/System.out:Ljava/io/PrintStream;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">25&lt;/span> &lt;span class="c1">// hello world
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">5&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Methodref&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">26&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">27&lt;/span> &lt;span class="c1">// java/io/PrintStream.println:(Ljava/lang/String;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">6&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">28&lt;/span> &lt;span class="c1">// com/firelord/zsample/lang/jvm/frontcompiler/Demo2
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">7&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">29&lt;/span> &lt;span class="c1">// java/lang/Object
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">8&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">field1&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">9&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">I&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">10&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">init&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">11&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="o">()&lt;/span>&lt;span class="n">V&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">12&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">Code&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">13&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">LineNumberTable&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">14&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">LocalVariableTable&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">15&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="k">this&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">16&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">Lcom&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">firelord&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">zsample&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">jvm&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">frontcompiler&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Demo2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">17&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">hello&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">18&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">i&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">19&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">SourceFile&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">20&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">Demo2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">java&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">21&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NameAndType&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">10&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">11&lt;/span> &lt;span class="c1">// &amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">22&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NameAndType&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">8&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">9&lt;/span> &lt;span class="c1">// field1:I
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">23&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">30&lt;/span> &lt;span class="c1">// java/lang/System
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">24&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NameAndType&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">31&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">32&lt;/span> &lt;span class="c1">// out:Ljava/io/PrintStream;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">25&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">hello&lt;/span> &lt;span class="n">world&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">26&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Class&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">33&lt;/span> &lt;span class="c1">// java/io/PrintStream
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">27&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NameAndType&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">34&lt;/span>&lt;span class="o">:&lt;/span>&lt;span class="err">#&lt;/span>&lt;span class="n">35&lt;/span> &lt;span class="c1">// println:(Ljava/lang/String;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">28&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">com&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">firelord&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">zsample&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">jvm&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">frontcompiler&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Demo2&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">29&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">java&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Object&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">30&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">java&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">System&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">31&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">out&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">32&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">Ljava&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">io&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">PrintStream&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">33&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">java&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">io&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">PrintStream&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">34&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="n">println&lt;/span>
&lt;span class="err">#&lt;/span>&lt;span class="n">35&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Utf8&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Ljava&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">;)&lt;/span>&lt;span class="n">V&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="kd">private&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">field1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">descriptor&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">I&lt;/span>
&lt;span class="n">flags&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ACC_PRIVATE&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">com&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">firelord&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">zsample&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">lang&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">jvm&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">frontcompiler&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">Demo2&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">descriptor&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="o">()&lt;/span>&lt;span class="n">V&lt;/span>
&lt;span class="n">flags&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ACC_PUBLIC&lt;/span>
&lt;span class="n">Code&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">locals&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">args_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">1&lt;/span>
&lt;span class="n">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokespecial&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">1&lt;/span> &lt;span class="c1">// Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">aload_0&lt;/span>
&lt;span class="n">5&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">iconst_1&lt;/span>
&lt;span class="n">6&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">putfield&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">2&lt;/span> &lt;span class="c1">// Field field1:I
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">9&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span>
&lt;span class="n">LineNumberTable&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">line&lt;/span> &lt;span class="n">3&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="n">line&lt;/span> &lt;span class="n">4&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">4&lt;/span>
&lt;span class="n">LocalVariableTable&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">Start&lt;/span> &lt;span class="n">Length&lt;/span> &lt;span class="n">Slot&lt;/span> &lt;span class="n">Name&lt;/span> &lt;span class="n">Signature&lt;/span>
&lt;span class="n">0&lt;/span> &lt;span class="n">10&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="k">this&lt;/span> &lt;span class="n">Lcom&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">firelord&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">zsample&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">jvm&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">frontcompiler&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Demo2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">hello&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">descriptor&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="o">()&lt;/span>&lt;span class="n">V&lt;/span>
&lt;span class="n">flags&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ACC_PUBLIC&lt;/span>
&lt;span class="n">Code&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">stack&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">locals&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">args_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">1&lt;/span>
&lt;span class="n">0&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">iconst_1&lt;/span>
&lt;span class="n">1&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">istore_1&lt;/span>
&lt;span class="n">2&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">getstatic&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">3&lt;/span> &lt;span class="c1">// Field java/lang/System.out:Ljava/io/PrintStream;
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">5&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">ldc&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">4&lt;/span> &lt;span class="c1">// String hello world
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">7&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">invokevirtual&lt;/span> &lt;span class="err">#&lt;/span>&lt;span class="n">5&lt;/span> &lt;span class="c1">// Method java/io/PrintStream.println:(Ljava/lang/String;)V
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">10&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="k">return&lt;/span>
&lt;span class="n">LineNumberTable&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">line&lt;/span> &lt;span class="n">7&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">0&lt;/span>
&lt;span class="n">line&lt;/span> &lt;span class="n">8&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">2&lt;/span>
&lt;span class="n">line&lt;/span> &lt;span class="n">9&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="n">10&lt;/span>
&lt;span class="n">LocalVariableTable&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="n">Start&lt;/span> &lt;span class="n">Length&lt;/span> &lt;span class="n">Slot&lt;/span> &lt;span class="n">Name&lt;/span> &lt;span class="n">Signature&lt;/span>
&lt;span class="n">0&lt;/span> &lt;span class="n">11&lt;/span> &lt;span class="n">0&lt;/span> &lt;span class="k">this&lt;/span> &lt;span class="n">Lcom&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">firelord&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">zsample&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">lang&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">jvm&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">frontcompiler&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">Demo2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">2&lt;/span> &lt;span class="n">9&lt;/span> &lt;span class="n">1&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="n">I&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="nl">SourceFile:&lt;/span> &lt;span class="s">&amp;#34;Demo2.java&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="321class文件基础信息">3.2.1.Class文件基础信息&lt;/h3>
&lt;p>Class文件的基础信息包括：&lt;/p>
&lt;ul>
&lt;li>class文件的路径&lt;/li>
&lt;li>class文件的修改时间、class文件的大小&lt;/li>
&lt;li>class文件的MD5值&lt;/li>
&lt;li>java文件的名称&lt;/li>
&lt;li>jdk的大版本/小版本号&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604151205810.png" alt="image-20210604151205810">&lt;/p>
&lt;h3 id="332常量池">3.3.2.常量池&lt;/h3>
&lt;p>常量池的细节知识有很多，但是有3个关键点：&lt;/p>
&lt;ul>
&lt;li>访问权限、字符串等等，都是JVM所认为的&amp;quot;常量&amp;rdquo;&lt;/li>
&lt;li>常量池中存储了多种类型的常量&lt;/li>
&lt;li>常量之间以类似&amp;quot;指针&amp;quot;的形式来表达源代码&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>例如：class Demo2，那么常量池有就会有一个UTF-8类型的常量表示&amp;quot;Demo2&amp;rdquo;，还会有一个类的符号引用指向&amp;quot;Demo2&amp;quot;这个UTF-8的常量。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604151237501.png" alt="image-20210604151237501">&lt;/p>
&lt;h3 id="333访问标识类索引">3.3.3.访问标识、类索引&lt;/h3>
&lt;p>在常量池的基础上，JVM首先要表达源文件中的类，类的关键要素包括：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>类名：javap的输出结果中有多处呈现了类名是Demo2。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>类的访问权限：本例中，javap的输出就是表示Demo2类是public的，并且继承于Object类&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604151731952.png" alt="image-20210604151731952">&lt;/p>
&lt;h3 id="334字段表">3.3.4.字段表&lt;/h3>
&lt;p>进一步，字节码要表达：&lt;/p>
&lt;ul>
&lt;li>Demo2类中有几个字段：javap的输出告诉我们，Demo2只有1个字段field1&lt;/li>
&lt;li>field1字段的数据类型：从输出可以看到，field1是int类型&lt;/li>
&lt;li>field1字段的访问权限：从输出可以看出，field1是private&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604152056658.png" alt="image-20210604152056658">&lt;/p>
&lt;h3 id="335方法表">3.3.5.方法表&lt;/h3>
&lt;p>更进一步，字节码要表达：&lt;/p>
&lt;ul>
&lt;li>Demo2@类中有几个方法：本例中，有一个默认的构造函数，还有一个hello方法&lt;/li>
&lt;li>方法的原型：从输出看，hello方法的访问权限是public，返回值是void，没有输入参数&lt;/li>
&lt;li>方法的具体实现：从输出看，hello方法被转换为了73~88行的JVM指令序列、行号表、局部变量表。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-3-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(javap%E7%89%88)/image-20210604152334770.png" alt="image-20210604152334770">&lt;/p>
&lt;blockquote>
&lt;p>说明：本文篇幅有限，无法展开讲解hello方法的指令执行过程，以及如何动态set/get局部变量表。有兴趣的读者可以尝试解读一下hello方法的指令执行过程。&lt;/p>
&lt;/blockquote>
&lt;h1 id="4总结">4.总结&lt;/h1>
&lt;p>本文解读了javap的使用以及javap的输出结果，具体如下：&lt;/p>
&lt;ul>
&lt;li>理解字节码以及JVM价值&lt;/li>
&lt;li>javap的学习方法&lt;/li>
&lt;li>javap命令行常用option&lt;/li>
&lt;li>javap命令行的options解读&lt;/li>
&lt;li>字节码的主体结构&lt;/li>
&lt;li>通过一个示例代码，演练了javap输出结果中各个section的含义&lt;/li>
&lt;/ul>
&lt;h1 id="5参考资料">5.参考资料&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.oracle.com/en/java/javase/11/tools/javap.html#GUID-BE20562C-912A-4F91-85CF-24909F212D7F">https://docs.oracle.com/en/java/javase/11/tools/javap.html#GUID-BE20562C-912A-4F91-85CF-24909F212D7F&lt;/a>&lt;/p>
&lt;p>《深入理解Java虚拟机：JVM高级特性与最佳实践》&lt;/p>
&lt;/blockquote></description></item><item><title>【编译引擎】-2-学习阅读Class文件结构(16进制版)-下</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8B/</link><pubDate>Thu, 05 Aug 2021 14:55:02 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8B/</guid><description>&lt;p>在《【编译引擎】学习阅读Class文件结构(16进制版)-上》、《【编译引擎】学习阅读Class文件结构(16进制版)-中》两篇文章中，笔者讲解了如何以16进制的方式，解读Demo2.java对应字节码的常量池、字段表、方法表。&lt;/p>
&lt;p>我们继续解读Demo2.class字节码的方法表的Code属性片段。&lt;/p>
&lt;h1 id="1复杂信息的树状表达属性树">1.复杂信息的树状表达：属性树&lt;/h1>
&lt;p>如果说前面两篇文章描述的信息相对简单，那么当我们需要用一种形式表达一个函数的实现就显得更加复杂了。&lt;/p>
&lt;p>我们逆向思考一下，假设我们就是JVM，JVM需要完成哪些&lt;strong>重要的任务&lt;/strong>：&lt;/p>
&lt;h2 id="11源代码转化为指令序列">1.1.源代码转化为指令序列&lt;/h2>
&lt;p>在编译阶段，JVM能够获得的信息形式是——&lt;strong>函数实现的源代码X&lt;/strong>&lt;/p>
&lt;p>而在运行阶段，JVM需要输出给CPU的信息形式是——&lt;strong>CPU能够理解并执行的CPU指令序列Z&lt;/strong>&lt;/p>
&lt;p>因此，JVM需要将&lt;strong>源代码X&lt;/strong>转换为&lt;strong>指令序列Z&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Z = G(X)&lt;/p>
&lt;/blockquote>
&lt;p>为了实现&lt;strong>转换函数G&lt;/strong>，首先，在编译阶段，JVM将&lt;strong>源代码X&lt;/strong>转换为&lt;strong>JVM指令序列Y&lt;/strong>，即&lt;/p>
&lt;blockquote>
&lt;p>Y = F1(X)&lt;/p>
&lt;/blockquote>
&lt;p>然后，在运行阶段，JVM动态地将&lt;strong>JVM指令序列Y&lt;/strong>转换为&lt;strong>CPU指令序列Z&lt;/strong>，即&lt;/p>
&lt;blockquote>
&lt;p>Z = F2(Y)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/1.png" alt="image-20201213164014831">&lt;/p>
&lt;p>至此，我们可以得到一个结论：&lt;strong>JVM指令序列是表示函数实现源代码的重要信息之一&lt;/strong>。&lt;/p>
&lt;h2 id="12维护局部变量列表">1.2.维护局部变量列表&lt;/h2>
&lt;p>我们至少知道3个经验：&lt;/p>
&lt;blockquote>
&lt;p>如果函数内一条语句使用了前面已经定义过的局部变量，则该语句能获得此局部变量最新的值。&lt;/p>
&lt;p>如果函数内一条语句使用了一个局部变量，但局部变量没有定义，IDE就会出现语法错误。&lt;/p>
&lt;p>即使是一个空的函数实现，这个函数里面，IDE至少能联想出一个变量this。&lt;/p>
&lt;/blockquote>
&lt;p>通过这3个经验，我们知道JVM至少具备如下能力：&lt;/p>
&lt;blockquote>
&lt;p>函数内定义了哪些局部变量，这些局部变量最新的值是多少。&lt;/p>
&lt;p>这些局部变量的作用范围从哪里开始，到哪里结束。&lt;/p>
&lt;/blockquote>
&lt;p>JVM通过实现&lt;strong>局部变量表&lt;/strong>存储上述信息：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/2.png" alt="image-20201213165522458">&lt;/p>
&lt;p>因此，我们可以得到另一个结论：&lt;strong>局部变量表也是表示函数实现源代码的必要信息&lt;/strong>。&lt;/p>
&lt;h2 id="13源代码与jvm指令序列的映射关系">1.3.源代码与JVM指令序列的映射关系&lt;/h2>
&lt;p>从1.1可知，调试程序本质是调试运行时指令序列，我们必然需要知道调试的指令序列对应于源代码中的位置。&lt;/p>
&lt;p>JVM通过行号表存储了映射关系：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/3.png" alt="image-20201213210037072">&lt;/p>
&lt;p>同样的，我们得到另一个结论：&lt;strong>行号表也是表示函数实现源代码的必要信息&lt;/strong>。&lt;/p>
&lt;h2 id="14属性树">1.4.属性树&lt;/h2>
&lt;p>综合前述的分析，JVM需要定义一个&lt;strong>表达属性的树表结构&lt;/strong>才能表示一个函数的内部实现，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/4.png" alt="image-20201213225139342">&lt;/p>
&lt;p>&lt;strong>Code属性自身具有一些基础信息&lt;/strong>(例如：操作数栈最大深度)，Code属性还包含&lt;strong>子属性&lt;/strong>(例如：行号表子属性、局部变量表子属性)。&lt;/p>
&lt;p>这样，就形成了一个属性树。&lt;/p>
&lt;h2 id="15属性">1.5.属性&lt;/h2>
&lt;blockquote>
&lt;p>JVM：&lt;em>Attributes&lt;/em> are used in the &lt;code>ClassFile&lt;/code>, &lt;code>field_info&lt;/code>, &lt;code>method_info&lt;/code>, and &lt;code>Code_attribute&lt;/code> structures of the &lt;code>class&lt;/code> file format&lt;/p>
&lt;/blockquote>
&lt;p>JVM将Code抽象的称为&lt;strong>属性&lt;/strong>，将&lt;strong>行号表&lt;/strong>也抽象为&lt;strong>属性&lt;/strong>，将&lt;strong>局部变量表&lt;/strong>也抽象地称为&lt;strong>属性&lt;/strong>。在JVM中，还有其它更多的&lt;strong>属性&lt;/strong>。&lt;/p>
&lt;p>但无论哪种属性，JVM都采用了如下数据结构表示&lt;strong>属性的共性&lt;/strong>：&lt;/p>
&lt;p>2个字节是属性名在常量池中的索引。&lt;/p>
&lt;p>4个字节表示这个属性的字节码长度N。&lt;/p>
&lt;p>紧接着N个字节表示这个属性具体的字节码。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/5.png" alt="image-20201213230831717">&lt;/p>
&lt;p>深一步思考，又有一个问题：不同的属性应该有不同的数据结构，&lt;strong>JVM怎么区分表达属性的特有信息&lt;/strong>呢？&lt;/p>
&lt;p>JVM就是根据属性名来区分的不同类型的属性，&lt;strong>每种属性又有自己独有的数据结构&lt;/strong>，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/6.png" alt="image-20201213232241686">&lt;/p>
&lt;p>好，有了这些前置知识，我们接下来详细解读Code、LineNumberTable、LocalVariableTable属性。&lt;/p>
&lt;h1 id="2code属性">2.Code属性&lt;/h1>
&lt;h2 id="21code属性名">2.1.Code属性名&lt;/h2>
&lt;p>hello方法下挂的属性名索引=&lt;strong>00 0C&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/7.png" alt="image-20201213230043475">&lt;/p>
&lt;p>&lt;strong>00 0C=12&lt;/strong>，对应&lt;strong>第12个常量&lt;/strong>，即&lt;strong>Code属性&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/8.png" alt="image-20201214002838199">&lt;/p>
&lt;h2 id="22code属性字节码长度">2.2.Code属性字节码长度&lt;/h2>
&lt;p>hello方法下挂的Code属性长度=&lt;strong>00 00 00 47&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/9.png" alt="image-20201214002946890">&lt;/p>
&lt;p>说明Code属性占据的字节码长度为&lt;strong>00 00 00 47=71&lt;/strong>，如下图红框：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/10.png" alt="image-20201214003317799">&lt;/p>
&lt;h2 id="23code属性操作数栈最大长度">2.3.Code属性.操作数栈最大长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>Code&lt;/code> attribute is a variable-length attribute in the &lt;code>attributes&lt;/code> table of a &lt;code>method_info&lt;/code> structure . A &lt;code>Code&lt;/code> attribute contains the Java Virtual Machine instructions and auxiliary information for a method, including an instance initialization method or a class or interface initialization method&lt;/p>
&lt;/blockquote>
&lt;p>进一步，查阅JVM规范，Code属性的数据结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/11.png" alt="image-20201214090813324">&lt;/p>
&lt;p>从max_stack开始，2个字节表示操作数栈最大深度。&lt;/p>
&lt;p>&lt;strong>00 02 = 2&lt;/strong>，表示针对Demo2代码，&lt;strong>操作数栈的最大深度为2&lt;/strong>。&lt;/p>
&lt;p>另外，这里涉及到对虚拟机栈的理解，笔者将会在后续文章中展开。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/12.png" alt="image-20201214071931530">&lt;/p>
&lt;h2 id="24code属性局部变量表长度">2.4.Code属性.局部变量表长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>max_locals&lt;/code> item gives the number of local variables in the local variable array allocated upon invocation of this method&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/13.png" alt="image-20201214072317654">&lt;/p>
&lt;p>00 02 = 2，&lt;strong>局部变量表最大长度为2&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/14.png" alt="image-20201214072400159">&lt;/p>
&lt;h2 id="25code属性指令序列长度">2.5.Code属性.指令序列长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>code_length&lt;/code> item gives the number of bytes in the &lt;code>code&lt;/code> array for this method.&lt;/p>
&lt;/blockquote>
&lt;p>4个字节表示紧接着的有多少个字节存储JVM指令序列。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/15.png" alt="image-20201214072528544">&lt;/p>
&lt;p>&lt;strong>00 00 00 0B=11&lt;/strong>，表示Demo2的hello方法转化的JVM指令序列，需要11个字节存储。&lt;/p>
&lt;p>这就很神奇了，一段这样的代码，竟然被转换成了11个字节：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/16.png" alt="image-20201214073202146">&lt;/p>
&lt;h2 id="26code属性指令序列">2.6.Code属性.指令序列&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>code&lt;/code> array gives the actual bytes of Java Virtual Machine code that implement the method.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/17.png" alt="image-20201214073245663">&lt;/p>
&lt;p>下图是Demo2的hello方法转换后的JVM指令序列：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/18.png" alt="image-20201214073409407">&lt;/p>
&lt;p>根据JVM规范，笔者将16进制字节码人工翻译成JVM指令序列：&lt;/p>
&lt;p>&lt;strong>04 =&amp;gt; iconst_1&lt;/strong>，表示将1加载到虚拟机栈中。&lt;/p>
&lt;p>&lt;strong>3C =&amp;gt; istore_1&lt;/strong>，表示将上一步的数据存储到局部变量表的第1位。&lt;/p>
&lt;p>&lt;strong>B2 00 03 =&amp;gt; getstatic 3&lt;/strong>，表示调用第3个常量映射的&lt;strong>java.io.PrintStream&lt;/strong>类。&lt;/p>
&lt;p>&lt;strong>12 04 =&amp;gt; Idc 4&lt;/strong>，表示将第4个常量映射的**&amp;ldquo;hello world&amp;quot;字符串**加载到虚拟机栈中。&lt;/p>
&lt;p>&lt;strong>B6 00 05=&amp;gt;invokevirtual 5&lt;/strong>，表示调用第5个常量映射的&lt;strong>println&lt;/strong>方法。&lt;/p>
&lt;p>&lt;strong>B1=&amp;gt;return&lt;/strong>，表示此函数&lt;strong>执行完成后返回&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/19.png" alt="image-20201214095755437">&lt;/p>
&lt;p>我们对比一下Demo2的源代码：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/20.png" alt="image-20201214100012611">&lt;/p>
&lt;h1 id="3linenumbertable属性">3.LineNumberTable属性&lt;/h1>
&lt;h2 id="31linenumbertable属性名">3.1.LineNumberTable属性名&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节表示属性名。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/21.png" alt="image-20201214101143092">&lt;/p>
&lt;p>&lt;strong>00 0D=13&lt;/strong>，表示第13个常量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/22.png" alt="image-20201214103511715">&lt;/p>
&lt;p>根据常量池映射关系，&lt;strong>第13个常量&lt;/strong>表示&lt;strong>LineNumberTable&lt;/strong>字符串&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/23.png" alt="image-20201214103741137">&lt;/p>
&lt;h2 id="32linenumbertable属性字节码长度">3.2.LineNumberTable属性字节码长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_length&lt;/code> item indicates the length of the attribute, excluding the initial six bytes.&lt;/p>
&lt;/blockquote>
&lt;p>4个字节表示属性占用的字节码长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/24.png" alt="image-20201214101226009">&lt;/p>
&lt;p>&lt;strong>00 00 00 0E&lt;/strong>=14，表示行号表占据字节码14个字节长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/25.png" alt="image-20201214103837705">&lt;/p>
&lt;p>因此，行号表的字节码如下图红框所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/26.png" alt="image-20201214104013281">&lt;/p>
&lt;h2 id="33linenumbertable属性的行数据">3.3.LineNumberTable属性的行数据&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each entry in the &lt;code>line_number_table&lt;/code> array indicates that the line number in the original source file changes at a given point in the &lt;code>code&lt;/code> array. Each &lt;code>line_number_table&lt;/code> entry must contain the following two items:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>start_pc&lt;/p>
&lt;p>The value of the &lt;code>start_pc&lt;/code> item must indicate the index into the &lt;code>code&lt;/code> array at which the code for a new line in the original source file begins.The value of &lt;code>start_pc&lt;/code> must be less than the value of the &lt;code>code_length&lt;/code> item of the &lt;code>Code&lt;/code> attribute of which this &lt;code>LineNumberTable&lt;/code> is an attribute.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>line_number&lt;/p>
&lt;p>The value of the &lt;code>line_number&lt;/code> item must give the corresponding line number in the original source file.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>行号表分为两列，一列是&lt;strong>在JVM指令序列的索引(start_pc)&lt;/strong>，一列是&lt;strong>源代码的行号(line_number)&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/27.png" alt="image-20201214101431970">&lt;/p>
&lt;p>我们将前文解读的JVM指令序列、Demo2的hello方法的源代码，与行号表的字节码对比，可以看到：&lt;/p>
&lt;p>行号表第1行数据：表示JVM指令序列第0行与源代码第7行对应。&lt;/p>
&lt;p>行号表第2行数据：表示JVM指令序列第2行与源代码第8行对应。&lt;/p>
&lt;p>行号表第3行数据：表示JVM指令序列第10行与源代码第9行对应。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/28.png" alt="image-20201214102952547">&lt;/p>
&lt;h1 id="4localvariabletable属性">4.LocalVariableTable属性&lt;/h1>
&lt;h2 id="41localvariabletable属性名">4.1.LocalVariableTable属性名&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节表示属性名。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/29.png" alt="image-20201214105409665">&lt;/p>
&lt;p>&lt;strong>00 0E=14&lt;/strong>，表示第14个常量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/30.png" alt="image-20201214105753233">&lt;/p>
&lt;p>根据常量池映射关系，&lt;strong>第14个常量&lt;/strong>表示&lt;strong>LocalVariableTable&lt;/strong>字符串。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/31.png" alt="image-20201214110018137">&lt;/p>
&lt;h2 id="42localvariabletable属性字节码长度">4.2.LocalVariableTable属性字节码长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_length&lt;/code> item indicates the length of the attribute, excluding the initial six bytes.&lt;/p>
&lt;/blockquote>
&lt;p>4个字节表示属性占用的字节码长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/32.png" alt="image-20201214105443811">&lt;/p>
&lt;p>&lt;strong>00 00 00 16&lt;/strong>=22，表示局部变量表占据字节码22个字节长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/33.png" alt="image-20201214110048114">&lt;/p>
&lt;p>因此，行号表的字节码如下图红框所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/34.png" alt="image-20201214111222724">&lt;/p>
&lt;h2 id="43localvariabletable属性的行数据">4.3.LocalVariableTable属性的行数据&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each entry in the &lt;code>local_variable_table&lt;/code> array indicates a range of &lt;code>code&lt;/code> array offsets within which a local variable has a value. It also indicates the index into the local variable array of the current frame at which that local variable can be found. Each entry must contain the following five items:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>start_pc, length&lt;/p>
&lt;p>The given local variable must have a value at indices into the &lt;code>code&lt;/code> array in the interval [&lt;code>start_pc&lt;/code>, &lt;code>start_pc + length&lt;/code>), that is, between &lt;code>start_pc&lt;/code> inclusive and &lt;code>start_pc + length&lt;/code> exclusive.The value of &lt;code>start_pc&lt;/code> must be a valid index into the &lt;code>code&lt;/code> array of this &lt;code>Code&lt;/code> attribute and must be the index of the opcode of an instruction.The value of &lt;code>start_pc + length&lt;/code> must either be a valid index into the &lt;code>code&lt;/code> array of this &lt;code>Code&lt;/code> attribute and be the index of the opcode of an instruction, or it must be the first index beyond the end of that &lt;code>code&lt;/code> array.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>name_index&lt;/p>
&lt;p>The value of the &lt;code>name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table. The &lt;code>constant_pool&lt;/code> entry at that index must contain a &lt;code>CONSTANT_Utf8_info&lt;/code> structure (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7">§4.4.7&lt;/a>) representing a valid unqualified name denoting a local variable (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.2">§4.2.2&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>descriptor_index&lt;/p>
&lt;p>The value of the &lt;code>descriptor_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table. The &lt;code>constant_pool&lt;/code> entry at that index must contain a &lt;code>CONSTANT_Utf8_info&lt;/code> structure (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7">§4.4.7&lt;/a>) representing a field descriptor which encodes the type of a local variable in the source program (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">§4.3.2&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>index&lt;/p>
&lt;p>The given local variable must be at &lt;code>index&lt;/code> in the local variable array of the current frame.If the local variable at &lt;code>index&lt;/code> is of type &lt;code>double&lt;/code> or &lt;code>long&lt;/code>, it occupies both &lt;code>index&lt;/code> and &lt;code>index + 1&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>行号表分为X列：&lt;/p>
&lt;p>列1是&lt;strong>局部变量在JVM指令序列的索引(start_pc)&lt;/strong>&lt;/p>
&lt;p>列2是&lt;strong>局部变量在JVM指令序列偏移量(length)&lt;/strong>&lt;/p>
&lt;p>列3是&lt;strong>局部变量名在常量池中的索引&lt;/strong>&lt;/p>
&lt;p>列4是&lt;strong>局部变量类型&lt;/strong>&lt;/p>
&lt;p>列5是&lt;strong>局部变量槽位&lt;/strong>——这里涉及到槽位重用问题，笔者将在讲解虚拟机栈的后续章节展开。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/35.png" alt="image-20201214105609730">&lt;/p>
&lt;p>我们将前文解读的JVM指令序列、Demo2的hello方法的源代码，与行号表的字节码对比，可以看到：&lt;/p>
&lt;p>局部变量表第1行数据：表示局部变量this，类型为Demo2，作用域hello整个函数。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/36.png" alt="image-20201214112254032">&lt;/p>
&lt;p>局部变量表第2行数据：表示局部变量i，类型为int，作用域hello函数的**&amp;ldquo;int i =1&amp;quot;语句后**，**“return”语句前**。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/37.png" alt="image-20201214112737327">&lt;/p>
&lt;h1 id="5总结jvm如何描述一个方法的内部实现">5.总结：JVM如何描述一个方法的内部实现?&lt;/h1>
&lt;p>根据Demo2演练代码，JVM描述了如下信息：&lt;/p>
&lt;h2 id="51三大重要信息的转换与存储">5.1.三大重要信息的转换与存储&lt;/h2>
&lt;ul>
&lt;li>在&lt;strong>虚拟机栈&lt;/strong>中，为hello方法开辟了一个&lt;strong>栈帧&lt;/strong>&lt;/li>
&lt;li>将源代码转换为&lt;strong>JVM指令序列&lt;/strong>，存储在&lt;strong>栈帧的Code属性&lt;/strong>中&lt;/li>
&lt;li>将局部变量存储在&lt;strong>栈帧的局部变量表&lt;/strong>中&lt;/li>
&lt;li>将源代码和JVM指令序列&lt;strong>位置映射关系&lt;/strong>，&lt;strong>存储在栈帧的行号表&lt;/strong>中&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/38.png" alt="image-20201214120538585">&lt;/p>
&lt;h2 id="52随着jvm指令序列执行动态刷新内存栈帧">5.2.随着JVM指令序列执行，动态刷新内存(栈帧)&lt;/h2>
&lt;ul>
&lt;li>当逻辑代码&lt;strong>int i =1&lt;/strong>执行时，栈帧中JVM指令序列执行到3C处，局部变量i被赋值为1；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/39.png" alt="image-20201214121148759">&lt;/p>
&lt;ul>
&lt;li>当逻辑代码&lt;strong>System.out.println(&amp;ldquo;hello world&amp;rdquo;)&lt;strong>语句执行时，栈帧中JVM指令序列执行到&lt;/strong>05&lt;/strong>处，打印了常量池中&amp;quot;hello world&amp;quot;字符串；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/40.png" alt="image-20201214121349494">&lt;/p>
&lt;p>上述过程，引出了JVM运行时数据区中的栈区以及内存结构。读者可以参考笔者这篇文章《【运行时数据区】用仓库管理员的视角理解运行时数据区》&lt;/p>
&lt;h1 id="6再看阅读字节码">6.再看阅读字节码&lt;/h1>
&lt;p>笔者在文章开头写了那个&amp;quot;牛逼程序猿看着一堆16进制致敬女神&amp;quot;的段子，但是头条不让开车就删掉了O(∩_∩)O~&lt;/p>
&lt;p>虽然我们不追求段子中的效果，但阅读字节码，的确是程序猿技术深度的重要体现。&lt;/p>
&lt;p>如果您耐心的将笔者的4篇文章阅读完，&lt;/p>
&lt;ul>
&lt;li>《【编译引擎】学习阅读Class文件结构的意义》&lt;/li>
&lt;li>《【编译引擎】学习阅读Class文件结构(16进制版)-上》&lt;/li>
&lt;li>《【编译引擎】学习阅读Class文件结构(16进制版)-中》&lt;/li>
&lt;li>《【编译引擎】学习阅读Class文件结构(16进制版)-下》&lt;/li>
&lt;/ul>
&lt;p>我们可以再来看看能够阅读字节码的Java程序猿，将具备哪些&amp;quot;一般码农&amp;quot;缺乏的能力：&lt;/p>
&lt;h2 id="61能够从更深的深度理解java的语言语法特性">6.1.能够从更深的深度，理解Java的语言语法特性&lt;/h2>
&lt;p>当您看到《Effective Java》、《阿里编程规范》等编程规范、高效编程实践的时候，&lt;/p>
&lt;p>不了解Java字节码的码农，是这样的思维：&lt;/p>
&lt;blockquote>
&lt;p>因为规范禁止我们这样做，所以我在实战中的代码一定不会这样写。&lt;/p>
&lt;/blockquote>
&lt;p>而了解Java字节码的程序猿，是这样的思维：&lt;/p>
&lt;blockquote>
&lt;p>为什么规范要禁止我们这样做，我要看看JVM指令序列，看看JVM是如何处理的。&lt;/p>
&lt;/blockquote>
&lt;p>例如：规范中禁止&lt;strong>count=count++这种语句&lt;/strong>，&lt;/p>
&lt;p>不了解Java字节码的码农，只能死记硬背；&lt;/p>
&lt;p>而了解Java字节码的程序猿，就可以查看JVM指令序列。&lt;/p>
&lt;h2 id="62能够提供性能优化的高维打击手段">6.2.能够提供性能优化的高维打击手段&lt;/h2>
&lt;p>在Spring源码中，有很多细节代码，下图摘自知乎的一个帖子：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/41.png" alt="image-20201214123137927">&lt;/p>
&lt;p>如果不了解字节码，您肯定想不到第2行的代码，居然会对性能优化产生一定的帮助。&lt;/p>
&lt;p>谢谢各位读者！&lt;/p></description></item><item><title>【编译引擎】-2-学习阅读Class文件结构(16进制版)-中</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%AD/</link><pubDate>Thu, 05 Aug 2021 14:55:01 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%AD/</guid><description>&lt;p>在《【编译引擎】学习阅读Class文件结构(16进制版)-上》中，笔者讲解了如何以16进制的方式，解读Demo2.java对应字节码的常量池。&lt;/p>
&lt;p>我们继续解读Demo2.class字节码的属性表、方法表等重要的片段。&lt;/p>
&lt;h1 id="1对类的描述访问标识">1.对类的描述：访问标识&lt;/h1>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>access_flags&lt;/code> item is a mask of flags used to denote access permissions to and properties of this class or interface.&lt;/p>
&lt;/blockquote>
&lt;p>在字节码文件中，紧接着常量池之后，2个字节表示了当前类或者接口访问标识。&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/1.png" alt="image-20201210103634981">&lt;/p>
&lt;p>我们看一下第35个常量之后紧接着的2个字节：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/2.png" alt="image-20201210104039071">&lt;/p>
&lt;p>这个值=&lt;strong>00 21&lt;/strong>，对照JVM规范可知，&lt;strong>0x0021 = 0x0001 | 0x0020&lt;/strong>，表示当前类是public类型的，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/3.png" alt="image-20201210104405014">&lt;/p>
&lt;p>这两个字节，表示的就是演练代码中红框处内容：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/4.png" alt="image-20201210105237723">&lt;/p>
&lt;h1 id="2继承结构类索引父类索引接口列表">2.继承结构：类索引/父类索引/接口列表&lt;/h1>
&lt;blockquote>
&lt;p>JVM规范：&lt;/p>
&lt;p>The value of the &lt;code>this_class&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;p>For a class, the value of the &lt;code>super_class&lt;/code> item either must be zero or must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;p>The value of the &lt;code>interfaces_count&lt;/code> item gives the number of direct superinterfaces of this class or interface type.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节表示当前&lt;strong>类索引&lt;/strong>&lt;/p>
&lt;p>2个字节表示&lt;strong>父类索引&lt;/strong>&lt;/p>
&lt;p>2个字节表示&lt;strong>接口计数器&lt;/strong>、N个字节(N=接口计数器的值)表示&lt;strong>接口索引列表&lt;/strong>(每个接口索引占2个字节)。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/5.png" alt="image-20201210105451548">&lt;/p>
&lt;p>我们看一下下图红框处的6个字节：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/6.png" alt="image-20201210110411942">&lt;/p>
&lt;p>&lt;strong>00 06&lt;/strong>表示常量池中第6个常量(CONSTANT_Class类型)，进而指向了第28个常量(CONSTANT_Utf8类型)，表示的就是Demo2类。&lt;/p>
&lt;p>&lt;strong>00 07&lt;/strong>表示常量池中第6个常量(CONSTANT_Class类型)，进而指向了第28个常量(CONSTANT_Utf8类型)，表示的就是Demo2的父类——Object类。&lt;/p>
&lt;p>&lt;strong>00 00&lt;/strong>表示接口计数器为0，表示Demo2类没有实现任何接口。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/7.png" alt="image-20201210142241019">&lt;/p>
&lt;p>这些字节码表达了红框处代码的信息：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/8.png" alt="image-20201210143458209">&lt;/p>
&lt;h1 id="3类的成员们字段表">3.类的成员们：字段表&lt;/h1>
&lt;h2 id="31字段计数器">3.1.字段计数器&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>fields_count&lt;/code> item gives the number of &lt;code>field_info&lt;/code> structures in the &lt;code>fields&lt;/code> table&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/9.png" alt="image-20201210143849778">&lt;/p>
&lt;p>红框处的2个字节&lt;strong>00 01&lt;/strong>，表示Demo2类中有1个字段&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/10.png" alt="image-20201210144133507">&lt;/p>
&lt;h2 id="32jvm如何表示一个字段">3.2.JVM如何表示一个字段&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each field is described by a &lt;code>field_info&lt;/code> structure.&lt;/p>
&lt;p>No two fields in one &lt;code>class&lt;/code> file may have the same name and descriptor&lt;/p>
&lt;/blockquote>
&lt;p>JVM为了表示类中的一个字段(例如：一个实例变量)，用如下数据结构表示：&lt;/p>
&lt;p>访问标志：2个字节，就是这个字段的访问权限，例如：private、public等。&lt;/p>
&lt;p>字段名索引：2个字节，就是这个字段的在常量池中的索引。&lt;/p>
&lt;p>字段描述符：2个字节，就是这个字段的类型。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/11.png" alt="image-20201210145124123">&lt;/p>
&lt;h2 id="33字段访问标志">3.3.字段访问标志&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>access_flags&lt;/code> item is a mask of flags used to denote access permission to and properties of this field.&lt;/p>
&lt;/blockquote>
&lt;p>JVM认为字段访问标志包括：public、private、protected，也包括static、final、volatile、transient，还包括enum修饰符&lt;/p>
&lt;p>具体如下表：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/12.png" alt="image-20201210144454329">&lt;/p>
&lt;p>在Demo2类的字节码中，显示值为&lt;strong>00 02&lt;/strong>，说明Demo2有1个字段，字段为private。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/13.png" alt="image-20201210144522844">&lt;/p>
&lt;p>对应Demo2的代码如下图红框：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/14.png" alt="image-20201210145650738">&lt;/p>
&lt;h2 id="33字段名索引">3.3.字段名索引&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>如同其它&amp;quot;索引&amp;quot;类型的信息片段，JVM也是用在常量池的索引表示字段名。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/15.png" alt="image-20201210150016307">&lt;/p>
&lt;p>在Demo2的字节码中，字段名索引值=&lt;strong>00 08&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/16.png" alt="image-20201210150106811">&lt;/p>
&lt;p>&lt;strong>00 08&lt;/strong>表示了常量池&lt;strong>第8个常量&lt;/strong>，第8个常量为CONSTANT_Utf8类型，就是&lt;strong>字面量&amp;quot;field1&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/17.png" alt="image-20201210150325539">&lt;/p>
&lt;p>Demo2源码中，也说明，&lt;strong>Demo2类中实例变量名就是field1&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/18.png" alt="image-20201210150529362">&lt;/p>
&lt;h2 id="34字段描述符">3.4.字段描述符&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>descriptor_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节的字段描述符，就是表示字段的数据类型，例如：int、byte、char、double或者对象引用等。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/19.png" alt="image-20201210150830424">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 09&lt;/strong>就是字段field1的描述符：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/20.png" alt="image-20201210151009853">&lt;/p>
&lt;p>&lt;strong>00 09&lt;/strong>表示field1的类型可以去查常量池的&lt;strong>第9个常量&lt;/strong>，第9个常量是CONSTANT_Utf8类型，&lt;strong>值为I，I表示的就是int&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/21.png" alt="image-20201210151218499">&lt;/p>
&lt;p>看到Demo2的源码中，&lt;strong>field1的数据类型就是int&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/22.png" alt="image-20201210151241013">&lt;/p>
&lt;h1 id="4类的行为集合方法表">4.类的行为集合：方法表&lt;/h1>
&lt;h2 id="41方法计数器">4.1.方法计数器&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>methods_count&lt;/code> item gives the number of &lt;code>method_info&lt;/code> structures in the &lt;code>methods&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>JVM用2个字节，表示类中具有多少个方法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/23.png" alt="image-20201210152620970">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 02&lt;/strong>说明有2个方法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/24.png" alt="image-20201210152702983">&lt;/p>
&lt;p>可是Demo2的源码中，不是只有一个方法hello吗？&lt;/p>
&lt;p>那是因为Demo2还有一个构造函数，JVM将构造函数命名为&lt;init>方法。&lt;/p>
&lt;p>JVM还会在某些场景下生成&lt;clinit>方法，笔者将在后续文章中阐述。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/25.png" alt="image-20201210152848314">&lt;/p>
&lt;h2 id="42jvm如何表示一个方法">4.2.JVM如何表示一个方法&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each method, including each instance initialization method and the class or interface initialization method, is described by a &lt;code>method_info&lt;/code> structure.&lt;/p>
&lt;/blockquote>
&lt;p>要用一种数据结构表达方法，最基本的有3个要素：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>方法的访问权限&lt;/strong>&lt;/li>
&lt;li>&lt;strong>方法名&lt;/strong>&lt;/li>
&lt;li>&lt;strong>方法返回值类型&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>进一步，方法体、方法内的局部变量等等怎么表达呢？&lt;/p>
&lt;p>JVM采用了属性表来表示它们，这一部分，也是笔者认为&amp;quot;广义的编译器&amp;quot;非常聪明、非常巧妙的信息表示方法。&lt;/p>
&lt;p>下图摘自JVM规范，方法内部的信息采用属性表表示，属性表中每一个属性又可以嵌套一个子属性表。&lt;/p>
&lt;p>这样就形成了一个多级的属性树。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/26.png" alt="image-20201210155258368">&lt;/p>
&lt;p>这里表述的很抽象，我们接下来以Demo2中的hello方法为例，具象化地理解JVM表达方法的method_info以及下属的属性树。&lt;/p>
&lt;p>下图红框，就是hello方法，在字节码中的信息片段。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/27.png" alt="image-20201210152525140">&lt;/p>
&lt;h2 id="43hello方法的访问标识符">4.3.hello方法的访问标识符&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>access_flags&lt;/code> item is a mask of flags used to denote access permission to and properties of this method.&lt;/p>
&lt;/blockquote>
&lt;p>方法访问标识符包括：public/private/protected，也包括static/final，还包括synchronized/native，以及abstract等等。&lt;/p>
&lt;p>可以看到方法的访问标识符就是Java代码中，在方法名前面，对方法的各种访问限定，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/28.png" alt="image-20201210163636030">&lt;/p>
&lt;p>Demo2的字节码中，访问标识符=&lt;strong>00 01&lt;/strong>，根据上表，说明hello方法是public类型的：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/29.png" alt="image-20201210163418660">&lt;/p>
&lt;p>对照Demo2的源代码，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/30.png" alt="image-20201210163938998">&lt;/p>
&lt;h2 id="44hello方法名">4.4.hello方法名&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>这2个字节也是索引类型，指向了常量池中的常量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/31.png" alt="image-20201210164225563">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 11&lt;/strong>指向了&lt;strong>第17个常量&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/32.png" alt="image-20201210164206078">&lt;/p>
&lt;p>根据常量池中的第17个常量，进而可以&lt;strong>得到方法名为&amp;quot;hello&amp;rdquo;&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/33.png" alt="image-20201210164338588">&lt;/p>
&lt;p>对照Demo2的源码，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/34.png" alt="image-20201210164353158">&lt;/p>
&lt;h2 id="45hello方法的描述符">4.5.hello方法的描述符&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>descriptor_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>方法描述符，可以理解为方法的输入参数类型列表和返回值类型&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/35.png" alt="image-20201210164948299">&lt;/p>
&lt;p>Demo2字节码的方法描述为&lt;strong>00 08&lt;/strong>，指向了常量池中&lt;strong>第11个常量&lt;/strong>，第11个常量的值=**&amp;quot;()V&amp;rdquo;**。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/36.png" alt="image-20201210164907934">&lt;/p>
&lt;p>&lt;strong>()&lt;strong>表示没有输入参数，&lt;strong>V&lt;/strong>表示&lt;/strong>void&lt;/strong>类型的返回值：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/37.png" alt="image-20201210165507268">&lt;/p>
&lt;p>对应Demo2的源代码：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/38.png" alt="image-20201210165604070">&lt;/p>
&lt;h2 id="46hello方法的属性计数器">4.6.hello方法的属性计数器&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attributes_count&lt;/code> item indicates the number of additional attributes of this method.&lt;/p>
&lt;/blockquote>
&lt;p>方法下，下挂了属性树，这2个字节就表示了属性个数。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/39.png" alt="image-20201210171021692">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 01&lt;/strong>表示hello方法下挂了&lt;strong>1个属性&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/40.png" alt="image-20201210170911839">&lt;/p>
&lt;p>在此，我们先剧透一下hello方法下挂的属性树结构：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/41.png" alt="image-20201210170336772">&lt;/p>
&lt;p>从上图，我们可以得到2个信息：&lt;/p>
&lt;ul>
&lt;li>JVM对于类中的方法，都会下挂一个&lt;strong>Code属性&lt;/strong>，Code属性&lt;strong>像一个容器&lt;/strong>，下面&lt;strong>可以挂更多的子属性&lt;/strong>&lt;/li>
&lt;li>&lt;strong>LineNumberTable&lt;/strong>属性、&lt;strong>LocalVariableTable&lt;/strong>属性，都是一种&lt;strong>表结构类型的属性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="5总结jvm如何描述一个类">5.总结：JVM如何描述一个类?&lt;/h1>
&lt;p>根据Demo2演练代码，JVM描述了如下信息：&lt;/p>
&lt;h2 id="51类的信息">5.1.类的信息&lt;/h2>
&lt;p>JVM字节码中构建了这样一颗与类有关的信息树&lt;/p>
&lt;blockquote>
&lt;p>有一个叫Demo2的类，是public类型的，继承于Object类&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/42.png" alt="image-20201210174253160">&lt;/p>
&lt;h2 id="52类中字段相关的信息">5.2.类中字段相关的信息&lt;/h2>
&lt;p>JVM构建了字节相关的信息树，遍历可知：&lt;/p>
&lt;blockquote>
&lt;p>Demo2类中有一个字段field1，是private的，是int类型的&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/43.png" alt="image-20201210174530083">&lt;/p>
&lt;h2 id="53类中方法相关的信息">5.3.类中方法相关的信息&lt;/h2>
&lt;p>JVM构建了方法相关的信息树，遍历可知：&lt;/p>
&lt;blockquote>
&lt;p>Demo2类中有一个方法叫做hello，是public的，没有输入也没有返回&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/44.png" alt="image-20201210174755908">&lt;/p>
&lt;h1 id="6下一步">6.下一步&lt;/h1>
&lt;p>笔者下篇会继续阅读本演练代码对应的Class文件剩余部分，包括&lt;/p>
&lt;blockquote>
&lt;p>方法内部相关的信息&lt;/p>
&lt;/blockquote>
&lt;p>如果您能耐心地看到这句话，恭喜您，距离&amp;rdquo;&lt;strong>看着16进制享受而诡魅的微笑&lt;/strong>&amp;ldquo;又近了一步，加油！&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/45.png" alt="image-20201210174921805">&lt;/p></description></item><item><title>【编译引擎】-2-学习阅读Class文件结构(16进制版)-上</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8A/</link><pubDate>Thu, 05 Aug 2021 14:55:00 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8A/</guid><description>&lt;p>大学时有个段子：什么是最牛逼的程序猿？&lt;/p>
&lt;p>最牛程序猿深情地注视着屏幕上一堆16进制，露出满足而诡魅的微笑。&lt;/p>
&lt;p>同学问他在看啥，他小声说：蒼井そら。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/1.png" alt="image-20201203084643095">&lt;/p>
&lt;p>好，下面，我们也来学习阅读一下16进制版的Class文件。&lt;/p>
&lt;h1 id="1源头class规范">1.源头：Class规范&lt;/h1>
&lt;p>每一个Java版本发布时，会公布两份规范文档(以Java8为例)：&lt;/p>
&lt;blockquote>
&lt;p>Java语言规范：《The Java Language Specification, Java SE 8 Edition》&lt;/p>
&lt;p>Java虚拟机规范：《The Java Virtual Machine Specification, Java SE 8 Edition》&lt;/p>
&lt;/blockquote>
&lt;p>Java虚拟机规范中有很大篇幅就是描述Class文件格式的规格，它也是帮助我们学习、理解Class文件最好的参考资料。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/2.png" alt="image-20201203090336783">&lt;/p>
&lt;h1 id="2验证演练代码">2.验证：演练代码&lt;/h1>
&lt;p>为了更好地覆盖JVM规范中描述的Class文件格式主脉络，笔者设计了如下示例代码：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/3.png" alt="image-20201203085719069">&lt;/p>
&lt;p>这段代码体现了5种Java的语法特征：&lt;/p>
&lt;blockquote>
&lt;p>类：Demo2&lt;/p>
&lt;p>成员变量：私有成员变量filed1，int类型，初始值为1&lt;/p>
&lt;p>方法：公有方法hello，无参数无返回值&lt;/p>
&lt;p>局部变量：局部变量i，int类型，初始值为1&lt;/p>
&lt;p>语句：打印语句println，打印内容为hello world&lt;/p>
&lt;/blockquote>
&lt;p>使用javac编译上述代码，我们会得到Demo2.class文件，用16进制编辑器打开如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/4.png" alt="image-20201203101943544">&lt;/p>
&lt;p>为了更清晰的查看，我们将上述数据复制到Excel表格中，着色&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/5.png" alt="image-20201203112942827">&lt;/p>
&lt;h1 id="3合法性检查依据魔数版本号">3.合法性检查依据：魔数、版本号&lt;/h1>
&lt;p>首先，通过阅读规范，我们获得如下知识：&lt;/p>
&lt;blockquote>
&lt;p>魔数：4个字节&lt;/p>
&lt;p>副版本号：2个字节&lt;/p>
&lt;p>主版本号：2个字节&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/6.png" alt="image-20201203102514844">&lt;/p>
&lt;p>然后，在IDE中将&lt;strong>魔数&lt;/strong>标记出来：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/7.png" alt="image-20201203113140375">&lt;/p>
&lt;p>然后，在IDE中将&lt;strong>版本号&lt;/strong>标记出来：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/8.png" alt="image-20201203113240887">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分析&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>魔数值和版本号是JVM加载Class文件时的合法性检查依据：&lt;/p>
&lt;blockquote>
&lt;p>如果16进制文件内容的开始不是&lt;strong>CA FE BA BE&lt;/strong>，则JVM就认为这个文件不是合法的Class文件；&lt;/p>
&lt;p>如果16进制文件内容的版本号与JVM版本号不匹配，则JVM就拒绝加载。&lt;strong>00 00 00 34&lt;/strong>，表示Java8对应的JVM可以加载。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>技术直男的浪漫&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>这里值得提到一个趣闻：魔数值&lt;strong>CA FE BA BE&lt;/strong>，应该这样断句：&lt;strong>CAFE BABE&lt;/strong>。&lt;/p>
&lt;p>Gosling，这位资深技术直男，就是这样温情地形容，他发明的这个编程语言——&lt;strong>咖啡宝贝&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/9.png" alt="image-20201203105231554">&lt;/p>
&lt;h1 id="4信息仓库常量池">4.信息仓库：常量池&lt;/h1>
&lt;h2 id="41常量池计数器">4.1.常量池计数器&lt;/h2>
&lt;p>在笔者前一篇文章《【编译引擎】学习阅读Class文件结构的意义》中提到：&lt;/p>
&lt;blockquote>
&lt;p>常量池：本质是一张表格。&lt;/p>
&lt;p>常量：是站在JVM角度看，公用的一些常量值，为了压缩Class文件的大小而存在。&lt;/p>
&lt;/blockquote>
&lt;p>因此，JVM规范才规定Class文件中，有2个字节的&lt;strong>常量池计数器&lt;/strong>(表示常量表格的长度)，紧接着的&lt;strong>N个字节&lt;/strong>存储&lt;strong>M个常量&lt;/strong>的具体内容&lt;/p>
&lt;blockquote>
&lt;p>M个常量：M=常量池计数器的值 - 1&lt;/p>
&lt;p>N个字节：N是变长的，因为每个常量类型不同，有的常量需要4个字节存储，有的常量需要很多字节存储。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/10.png" alt="image-20201203110434464">&lt;/p>
&lt;ul>
&lt;li>首先，找到&lt;strong>常量池计数器&lt;/strong>=&lt;strong>00 24&lt;/strong>，转换为10进制是36，说明&lt;strong>常量池中存储了35个常量&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>一个规范中的细节：The &lt;code>constant_pool&lt;/code> table is indexed from 1 to &lt;code>constant_pool_count&lt;/code> - 1.&lt;/p>
&lt;p>这段话的意思是，常量池计数器值-1就是常量个数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/11.png" alt="image-20201203114851834">&lt;/p>
&lt;h2 id="42n种常量类型">4.2.N种常量类型&lt;/h2>
&lt;p>接下来，我们解读具体的常量，前文讲过，常量有不同的类型，那么Class文件如何表达常量类型呢？&lt;/p>
&lt;p>规范中，采用了如下结构表示不同类型的常量：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/12.png" alt="image-20201203115414837">&lt;/p>
&lt;p>那么，JVM支持多少种类型的常量呢？&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/13.png" alt="image-20201203115520340">&lt;/p>
&lt;p>本文的演练代码中，涉及到了种类型的常量：&lt;/p>
&lt;blockquote>
&lt;p>CONSTANT_Utf8：1&lt;/p>
&lt;p>CONSTANT_String：8&lt;/p>
&lt;p>CONSTANT_Class：7&lt;/p>
&lt;p>CONSTANT_Fieldref：9&lt;/p>
&lt;p>CONSTANT_NameAndType：12&lt;/p>
&lt;p>CONSTANT_Methodref：10&lt;/p>
&lt;/blockquote>
&lt;h2 id="43constant_utf8类型的常量">4.3.CONSTANT_Utf8类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_Utf8_info&lt;/code> structure is used to represent constant string values&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，就是表达字符串字面量。&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/14.png" alt="image-20201203120726026">&lt;/p>
&lt;p>我们以第25个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/15.png" alt="image-20201203120926294">&lt;/p>
&lt;p>这个常量值=&lt;strong>01 00 0B 68 65 6C 6C 6F 20 77 6F 72 6C 64&lt;/strong>，如下图所示的含义&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/16.png" alt="image-20201203121756603">&lt;/p>
&lt;p>第25个常量，表示的就是演练代码中的打印的字符串内容：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/17.png" alt="image-20201203122016513">&lt;/p>
&lt;h2 id="44constant_string类型的常量">4.4.CONSTANT_String类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_String_info&lt;/code> structure is used to represent constant objects of the type &lt;code>String&lt;/code>:&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，是字符串对象类型的，它的值指向4.3中描述的字符串字面量。&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/18.png" alt="image-20201203122939616">&lt;/p>
&lt;p>我们以第5个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/19.png" alt="image-20201203122644594">&lt;/p>
&lt;p>这个常量的值= &lt;strong>08 00 19&lt;/strong>，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/20.png" alt="image-20201203123306833">&lt;/p>
&lt;p>结合第5个常量和第25个常量，再看演练代码，我们窥见&lt;strong>JVM处理字符串的原理&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/21.png" alt="image-20201203123552479">&lt;/p>
&lt;h2 id="45constant_class类型的常量">4.5.CONSTANT_Class类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_Class_info&lt;/code> structure is used to represent a class or an interface&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示类或者接口&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/22.png" alt="image-20201203124237102">&lt;/p>
&lt;p>我们以第6个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/23.png" alt="image-20201203124334512">&lt;/p>
&lt;p>这个常量的值= &lt;strong>07 00 1C&lt;/strong>，结合第28个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/24.png" alt="image-20201203124818815">&lt;/p>
&lt;p>再看演练代码，CONSTANT_Class类型的常量表达了演练代码中定义的Demo2类：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/25.png" alt="image-20201203124958357">&lt;/p>
&lt;h2 id="46constant_fieldref类型的常量">4.6.CONSTANT_Fieldref类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Fields, methods, and interface methods are represented by similar structures:&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示字段(例如：一个类中的成员变量)。JVM规范还告诉我们，实例方法、接口方法都是同样的Class格式。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/26.png" alt="image-20201203125455813">&lt;/p>
&lt;p>我们以第2个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/27.png" alt="image-20201203125918470">&lt;/p>
&lt;p>这个常量的值= &lt;strong>09 00 06 00 16&lt;/strong>，结合第6个常量和第22个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/28.png" alt="image-20201203130857438">&lt;/p>
&lt;p>但是第22个常量=&lt;strong>0C 00 08 00 09&lt;/strong>表示了什么呢？我们看下一章节的解读&lt;/p>
&lt;h2 id="47constant_nameandtype类型的常量">4.7.CONSTANT_NameAndType类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_NameAndType_info&lt;/code> structure is used to represent a field or method, without indicating which class or interface type it belongs to&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示一个字段的类型信息&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/29.png" alt="image-20201203131307059">&lt;/p>
&lt;p>我们以第22个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/30.png" alt="image-20201203131134360">&lt;/p>
&lt;p>这个常量的值= &lt;strong>0C 00 08 00 09&lt;/strong>，结合第8个常量和第9个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/31.png" alt="image-20201203131856257">&lt;/p>
&lt;p>至此，我们就看到了演练代码中在JVM中如何表达&lt;code>int field1&lt;/code>信息了：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/32.png" alt="image-20201203132039284">&lt;/p>
&lt;h2 id="48constant_methodref类型的常量">4.8.CONSTANT_Methodref类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Fields, methods, and interface methods are represented by similar structures:&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示方法。JVM规范还告诉我们，它的结构和字段类型常量都是同样的Class格式。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/33.png" alt="image-20201203132452923">&lt;/p>
&lt;p>我们以第5个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/34.png" alt="image-20201203132633860">&lt;/p>
&lt;p>这个常量的值= &lt;strong>0A 00 1A 00 1B&lt;/strong>，结合第26、27个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/35.png" alt="image-20201203134131024">&lt;/p>
&lt;h1 id="5总结常量池构建的静态全局观">5.总结：常量池构建的静态全局观&lt;/h1>
&lt;p>根据演练代码产生的Class文件，JVM构建了35个常量：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/36.png" alt="image-20201203134423990">&lt;/p>
&lt;p>我们以图形化的方式进一步看看，Class文件的常量池到底为JVM构建了怎样的&lt;strong>信息树&lt;/strong>？&lt;/p>
&lt;h2 id="51源代码中有哪些方法引用">5.1.源代码中有哪些方法引用&lt;/h2>
&lt;p>常量池构建了方法引用的信息树，我们可以看到&lt;strong>两颗方法引用树&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/37.png" alt="image-20201203143257328">&lt;/p>
&lt;p>以其中一棵树为例，遍历这棵树，我们可以得到如图的信息：&lt;/p>
&lt;blockquote>
&lt;p>源代码中有一个方法，此方法属于Object类，方法名为&lt;init>，方法无输入参数，无返回&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/38.png" alt="image-20201203143352283">&lt;/p>
&lt;h2 id="52源代码中有哪些字段引用">5.2.源代码中有哪些字段引用&lt;/h2>
&lt;p>常量池构建了字段引用的信息树，我们可以看到&lt;strong>两颗字段引用树&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/39.png" alt="image-20201203143527781">&lt;/p>
&lt;p>以其中一棵树为例，遍历这棵树，我们可以得到如图的信息：&lt;/p>
&lt;blockquote>
&lt;p>源代码中有一个字段，此字段属于Demo2类，字段名为field1，字段数据类型为int&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/40.png" alt="image-20201203143719972">&lt;/p>
&lt;h2 id="53源代码中有哪些字符串对象">5.3.源代码中有哪些字符串对象&lt;/h2>
&lt;p>常量池构建了字符串类型对象的信息树，我们可以看到&lt;strong>一颗字符串对象树&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/41.png" alt="image-20201203143839084">&lt;/p>
&lt;p>以这棵树为例，遍历这棵树，我们可以得到如图的信息：&lt;/p>
&lt;blockquote>
&lt;p>源代码中有一个字符串对象，此字符串对象的值是hello world&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/42.png" alt="image-20201203143944970">&lt;/p>
&lt;h2 id="54源代码中其它的字符串字面量">5.4.源代码中其它的字符串字面量&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/43.png" alt="image-20201203144014111">&lt;/p>
&lt;h2 id="55静态的全局观">5.5.静态的全局观&lt;/h2>
&lt;p>至此，我们已经看到了常量池为JVM诠释了Java源代码中的信息树。&lt;/p>
&lt;p>&lt;strong>常量池中的这些信息树，为JVM构建出了一个静态的全局观&lt;/strong>。&lt;/p>
&lt;p>通过这些信息树，我们已经能&lt;strong>反演出Java源代码中的静态结构&lt;/strong>：&lt;/p>
&lt;blockquote>
&lt;p>有几个类？&lt;/p>
&lt;p>类中有几个成员变量？&lt;/p>
&lt;p>类中有几个方法？&lt;/p>
&lt;p>每个成员变量的名称、数据类型&lt;/p>
&lt;p>每个方法的名称、输入参数列表、返回值类型&lt;/p>
&lt;/blockquote>
&lt;p>但常量池中还有一些信息孤点，我们无法反演出一些&lt;strong>动态结构&lt;/strong>：&lt;/p>
&lt;blockquote>
&lt;p>成员变量的状态变化过程&lt;/p>
&lt;p>方法体内的运行过程&lt;/p>
&lt;p>方法内局部变量的变化过程&lt;/p>
&lt;/blockquote>
&lt;h1 id="6下一步">6.下一步&lt;/h1>
&lt;p>笔者下篇会继续阅读本演练代码对应的Class文件剩余部分，包括&lt;/p>
&lt;blockquote>
&lt;p>访问标识&lt;/p>
&lt;p>类索引&lt;/p>
&lt;p>字段表&lt;/p>
&lt;p>方法表&lt;/p>
&lt;p>属性表&lt;/p>
&lt;/blockquote>
&lt;p>进一步理解Class字节码如何为JVM&lt;strong>构建动态全局观&lt;/strong>。&lt;/p>
&lt;p>**高能预警：**如果您能耐心地看到这句话，恭喜您，距离&amp;rdquo;&lt;strong>看着16进制享受而诡魅的微笑&lt;/strong>&amp;ldquo;又近了一步，加油！&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/44.png" alt="image-20201203144947702">&lt;/p></description></item><item><title>【编译引擎】 1 学习阅读Class文件结构的意义</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/</link><pubDate>Thu, 05 Aug 2021 14:54:59 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/</guid><description>&lt;h1 id="1起于累土为什么要阅读字节码">1.起于累土：为什么要阅读字节码&lt;/h1>
&lt;p>笔者最近的一项工作是设计一套课程，用于辅导新员工如何做好性能优化。&lt;/p>
&lt;p>这项工作很快遇到了问题：&lt;/p>
&lt;blockquote>
&lt;p>讲内存泄露/溢出的定位工具，就要求听众先对JVM的运行时数据区有基本理解。&lt;/p>
&lt;p>讲运行时数据区，又要求听众先大致理解类加载子系统如何一步步地将字节码加载到内存中。&lt;/p>
&lt;p>讲类加载子系统，又要求听众先理解字节码表示了哪些&amp;quot;静态信息&amp;rdquo;。&lt;/p>
&lt;p>&amp;hellip;.&lt;/p>
&lt;/blockquote>
&lt;p>性能优化是一个复杂的系统化话题，性能优化的手段分为3个级别：&lt;/p>
&lt;p>&lt;strong>倔强青铜级：时空转移&lt;/strong>&lt;/p>
&lt;p>当计算效率不足时，用空间换时间。例如：将需要频繁使用的数据，提前缓存在内存中。&lt;/p>
&lt;p>当内存空间不足时，用时间换空间。例如：将不需要的缓存数据去掉，动态计算。&lt;/p>
&lt;p>在这个层次上解决问题，&lt;strong>优点是朴实&lt;/strong>，&lt;strong>缺点是此消彼长、绵绵无期&lt;/strong>：&lt;/p>
&lt;p>因为&lt;strong>时间换空间&lt;/strong>与&lt;strong>空间换时间&lt;/strong>本质是互逆的手段。&lt;/p>
&lt;p>一个软件产品可能在迭代1暴露出了计算效率不足，采用了空间换时间。&lt;/p>
&lt;p>到了迭代2又因为迭代1的性能优化导致空间不足，又要将大量的缓存替换为实时计算。&lt;/p>
&lt;p>……&lt;/p>
&lt;p>笔者的一位程序猿朋友，在多次时间换空间、空间换时间的性能优化工作之后，发出了一句颇有哲理的感慨：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>时间是不可能被消灭的，只能被转移&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/1-2-1.png" alt="image-20201128154031535">&lt;/p>
&lt;p>&lt;strong>永恒钻石级：业务裁剪&lt;/strong>&lt;/p>
&lt;p>能用这个级别手法的，一般是老程序猿。&lt;/p>
&lt;p>凭借多年的业务领域经验，深刻理解了业务流程中哪些步骤是冗余的。&lt;/p>
&lt;p>无论是时间瓶颈或者空间瓶颈，删掉冗余代码，一招搞定。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/1-2-2.png" alt="image-20201128155657776">&lt;/p>
&lt;p>在这个层次上解决问题，&lt;strong>优点还是朴实，缺点是比较依赖业务专家，无法批量复制与推广&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>最强王者级：底层优化&lt;/strong>&lt;/p>
&lt;p>使用这种手法，就要求程序猿对于JVM、操作系统、网络有比较深刻的认识，大部分程序猿都止步此。&lt;/p>
&lt;p>通过对静态逻辑(字节码)的理解和动态逻辑(运行时)的理解，精确找到空间瓶颈和时间瓶颈，进而采用更加具有通用性的手段开展优化工作。&lt;/p>
&lt;p>如果说&lt;strong>性能优化是九层之塔&lt;/strong>，那么&lt;strong>阅读字节码&lt;/strong>就是累土中的重要基石之一。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/1-2-3.png" alt="image-20201128160013429">&lt;/p>
&lt;h1 id="2编程界的通天塔字节码的宏观意义">2.编程界的通天塔：字节码的宏观意义&lt;/h1>
&lt;p>知乎上有一个趣帖&lt;code>全世界为什么不能统一语言？&lt;/code>(&lt;a href="https://www.zhihu.com/question/22133387">https://www.zhihu.com/question/22133387&lt;/a>)&lt;/p>
&lt;p>有一个有趣的回答：&amp;ldquo;你想造通天塔就直说&amp;rdquo;。&lt;/p>
&lt;p>通天塔，也叫巴别塔，传说人类想建造一个通往天堂的天梯而触怒了神灵，于是神灵将人类的语言隔绝，导致人类种族语言不通。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-1.png" alt="image-20201128163114423">&lt;/p>
&lt;p>编程界也存在多种编程语言，任何VM类型的语言(含编译、执行)都存在如下流程：&lt;/p>
&lt;blockquote>
&lt;p>前端编译器：将源代码转换为字节码&lt;/p>
&lt;p>字节码加载模块：将字节码加载到运行时数据区(就是内存)&lt;/p>
&lt;p>解释执行器：根据内存中的VM栈，执行字节码&lt;/p>
&lt;p>后端编译器：将频繁执行的字节码直接生成为机器码缓存下来，提升执行效率&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-2.png" alt="image-20201126100836623">&lt;/p>
&lt;p>我们会发现，字节码加载、运行时数据区似乎大同小异，于是进一步简化上述流程：&lt;/p>
&lt;blockquote>
&lt;p>字节码加载取决于运行时数据区&lt;/p>
&lt;p>运行时数据区的理论主要是分代理论、回收理论等&lt;/p>
&lt;/blockquote>
&lt;p>从简化的流程中，我们可以看到，一种编程语言的&lt;strong>源代码语法无论多么&amp;quot;花哨&amp;rdquo;&lt;/strong>(满足不同领域的程序猿不同的编程风格)，&lt;strong>最终都要回归到朴实的字节码&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-3.png" alt="image-20201126105406046">&lt;/p>
&lt;p>在Java这种语言中，JVM提供了&lt;strong>javac和javap&lt;/strong>两种工具实现前端编译和前端反编译的互逆操作：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-4.png" alt="image-20201126105515858">&lt;/p>
&lt;p>试想一下，&lt;strong>如果字节码是一种规范&lt;/strong>，&amp;ldquo;类加载子系统、运行时数据区、解释执行器、后端编译器&amp;quot;就有可能做成&lt;strong>VM内置的标准件&lt;/strong>，那么开发一种新的编程语言只需要关注2点：&lt;/p>
&lt;blockquote>
&lt;p>1.如何设计一种新的语法，满足新编程领域的特征、风格？&lt;/p>
&lt;p>2.如何将新的语法源代码，转换为标准的字节码？&lt;/p>
&lt;/blockquote>
&lt;p>设计一种新的编程语言，上述2点并不是很困难，而真正的技术门槛、技术成本是那些VM内置的标准件。&lt;/p>
&lt;p>这将是一种可怕的效率提升革命，于是Java之父Gosling强调：&lt;/p>
&lt;blockquote>
&lt;p>JVM能支持各种符合字节码规范的新兴编程语言，Java只是JVM上能运行的编程语言之一。&lt;/p>
&lt;p>Java并不牛逼，JVM才是最牛逼的。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-5.png" alt="image-20201126110532663">&lt;/p>
&lt;p>&lt;strong>字节码就是统一的机器语言：&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>从程序猿的视角看，无论使用怎样不同的编程语言，都能被前端编译器转换为标准的JVM字节码；&lt;/p>
&lt;p>从CPU的视角看，无论是怎样不同的CPU架构，后端编译器都能将标准的JVM字节码转换为不同的机器码；&lt;/p>
&lt;/blockquote>
&lt;p>目前，JVM支持了很多编程语言，其中包含了注入Kotlin这种热度很高的新型语言：&lt;/p>
&lt;blockquote>
&lt;p>数据来源：https://www.slant.co/topics/397/~best-languages-that-run-on-the-jvm&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-6.png" alt="1.png">&lt;/p>
&lt;h1 id="3引用地图字节码的微观逻辑">3.引用地图：字节码的微观逻辑&lt;/h1>
&lt;p>JVM字节码的规范很复杂，在深入细节之前，最好先理解字节码的微观逻辑。&lt;/p>
&lt;p>首先写一段简单的代码Demo4.java：&lt;/p>
&lt;blockquote>
&lt;p>这个类只有一个无参构造函数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-1.png" alt="image-20201128171824843">&lt;/p>
&lt;p>再通过前端编译器，从Demo4.java生成Demo4.class:&lt;/p>
&lt;blockquote>
&lt;p>用16进制编辑器打开&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-2.png" alt="image-20201128172301948">&lt;/p>
&lt;p>Class文件分为2个部分：常量池和方法区&lt;/p>
&lt;blockquote>
&lt;p>红色框：常量池区域&lt;/p>
&lt;p>橙色框：方法区区域&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-3.png" alt="image-20201128174147100">&lt;/p>
&lt;p>这里的常量、方法，不是Java语法中的常量、方法，而是&lt;strong>站在VM的角度看到的常量和方法&lt;/strong>。&lt;/p>
&lt;p>例如：&amp;ldquo;Demo4&amp;quot;这个字符串，在Java源代码中出现了2次：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-4.png" alt="image-20201128175010006">&lt;/p>
&lt;p>JVM将&amp;quot;Demo4&amp;quot;这个字符串放在了常量池中：&lt;/p>
&lt;blockquote>
&lt;p>蓝色框：Demo4字面量&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-5.png" alt="image-20201128175430731">&lt;/p>
&lt;p>在Java源代码中第一处表达类名时，JVM只需要用1个字节，&lt;strong>最终指向&lt;/strong>常量池中&amp;quot;Demo4&amp;quot;的位置：&lt;/p>
&lt;blockquote>
&lt;p>最终指向：此处简化了从ClassInfo常量逐级指向Utf8_info常量的过程&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-6.png" alt="image-20201128175906442">&lt;/p>
&lt;p>从上述例子可以看到，JVM字节码的微观逻辑就是&lt;strong>引用&lt;/strong>，引用的目的就是复用，复用的目的就是用&lt;strong>最小的字节数表达信息&lt;/strong>。&lt;/p>
&lt;h1 id="4总结">4.总结&lt;/h1>
&lt;p>本文主要内容：&lt;/p>
&lt;ul>
&lt;li>论述阅读字节码对于深入理解编程语言特性的意义&lt;/li>
&lt;li>JVM字节码规范对于设计新的编程语言的价值&lt;/li>
&lt;li>JVM字节码如何通过引用地图，实现最小字节数表示最大的信息量。&lt;/li>
&lt;/ul>
&lt;p>下一步，笔者将通过一段代码实例，深入Class文件结构的细节。&lt;/p>
&lt;h1 id="5参考文献">5.参考文献&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://www2.slideshare.net/RednaxelaFX/jvm-a-platform-for-multiple-languages">https://www2.slideshare.net/RednaxelaFX/jvm-a-platform-for-multiple-languages&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.slant.co/topics/397/~best-languages-that-run-on-the-jvm">https://www.slant.co/topics/397/~best-languages-that-run-on-the-jvm&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/20003582">https://www.zhihu.com/question/20003582&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.imooc.com/article/296373">https://www.imooc.com/article/296373&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>【工具】-0-一文搞懂JDK命令行工具</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E5%B7%A5%E5%85%B7-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82jdk%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</link><pubDate>Thu, 05 Aug 2021 08:10:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E5%B7%A5%E5%85%B7-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82jdk%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</guid><description>&lt;h1 id="1工欲善其事jdk提供的工具">1.工欲善其事：JDK提供的工具&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>Java试题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>JVM调优的常见命令行工具描述正确的有：&lt;/p>
&lt;p>A.jstat可以实时显示本地或远程JVM进程中类加载、内存、垃圾收集、JIT编译等数据&lt;/p>
&lt;p>B.jmap用于查询当前运行的JVM属性和参数的值&lt;/p>
&lt;p>C.jstack用于生成当前JVM的所有线程快照&lt;/p>
&lt;p>D.jps命令用于查询正在运行的JVM进程&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>试题解读&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>这道题考察JDK自带命令行工具的理解，这些工具用于性能调优、疑难问题定位。&lt;/p>
&lt;p>在生产环境定位时，要求定位/调优工具自身具备极高的性能，否则会对本来就有问题的生产环境产生干扰。&lt;/p>
&lt;p>JDK自带的命令行工具以其的高性能、实用性，成为实战中必须掌握的工具，是Java程序猿的调优武器库。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/1.png" alt="image-20210521073310456">&lt;/p>
&lt;h1 id="2总览">2.总览&lt;/h1>
&lt;h2 id="21主流工具概览">2.1.主流工具概览&lt;/h2>
&lt;p>目前，主流的Java性能监控与调优工具如下图所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/2.png" alt="image-20210521094038209">&lt;/p>
&lt;p>这些工具主要分为两个流派：&amp;ldquo;&lt;code>命令行流派&lt;/code>&amp;quot;与&amp;quot;&lt;code>可视化流派&lt;/code>&amp;rdquo;&lt;/p>
&lt;ul>
&lt;li>**命令行流派：**强调实用性。体积小、资源消耗小，适用于生产环境的问题定位与调优。&lt;/li>
&lt;li>**可视化流派：**强调颜值即正义。可视化图表、一目了然，适用于开发环境上复现、定位问题。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/3.png" alt="image-20210521100601641">&lt;/p>
&lt;p>这两种流派各有适用的场景，辩证统一，所以还是那句话：&amp;ldquo;成年人不做选择，两样我都要&amp;rdquo;。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/4.png" alt="image-20210521104216938">&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">说明1：本文仅讲解命令行流派的工具，笔者在后续文章中再探讨可视化流派工具。
说明2：不能简单地将Arthas看作工具，后续开专题探讨。
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="22理解命令行工具的内在逻辑">2.2.理解命令行工具的内在逻辑&lt;/h2>
&lt;p>对于这些命令行工具，有一种观点：&lt;code>没有必要记下来，用到的时候再查资料&lt;/code>。&lt;/p>
&lt;p>因为这些命令行工具比较多，每个命令行也有很多参数，记下来是一件枯燥的事。&lt;/p>
&lt;p>但，这个观点成立有一个前提：我们必须理解这些命令行工具的&lt;code>内在逻辑&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>**逻辑1：**这些命令行工具的关系是什么？&lt;/li>
&lt;li>**逻辑2：**每个工具解决什么问题？&lt;/li>
&lt;li>**逻辑3：**每个工具的参数集合分哪几类？&lt;/li>
&lt;/ul>
&lt;p>如果没有理解上述&lt;code>内在逻辑&lt;/code>，需要用的时候再查资料也很难入手。&lt;/p>
&lt;p>对于&lt;code>逻辑1：这些命令行工具的关系&lt;/code>，笔者提供一种&lt;code>基于实战问题定位的场景&lt;/code>的理解方式：&lt;/p>
&lt;ul>
&lt;li>**STEP1.进程监控：**首先，找到生产环境中待定位的Java进程。&lt;/li>
&lt;li>**STEP2.配置查询：**进一步，查看此Java进程的JVM配置。&lt;/li>
&lt;li>**STEP3.JVM状态监控与初步分析：**再进一步，查看此Java进程的内存、线程、JIT的整体情况。&lt;/li>
&lt;li>&lt;strong>STEP4.内存监控与分析&lt;/strong>：如果STEP3发现了可能的内存问题，就深入分析内存。&lt;/li>
&lt;li>**STEP5.线程监控与分析：**如果STEP3发现了可能的线程问题，就深入分析线程。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/5.png" alt="image-20210521111701312">&lt;/p>
&lt;h2 id="23进阶的方法">2.3.进阶的方法&lt;/h2>
&lt;ul>
&lt;li>**命令行手册：**我们可以通过官方的命令行手册，深入学习它们。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/6.png" alt="image-20210521112755277">&lt;/p>
&lt;ul>
&lt;li>**工具源码：**通过这些命令行工具的源码，可以更深入地理解JVM状态监控的原理和API。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">https://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/7.png" alt="image-20210521112939223">&lt;/p>
&lt;h1 id="3进程监控-jps">3.进程监控-jps&lt;/h1>
&lt;h2 id="31解决什么问题">3.1.解决什么问题&lt;/h2>
&lt;p>jps用来显示指定系统内所有正在运行的HotSpot虚拟机进程信息。&lt;/p>
&lt;h2 id="32参数">3.2.参数&lt;/h2>
&lt;ul>
&lt;li>jps的参数格式如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">jps [options] [hostid]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以通过几个实际的例子，快速理解&lt;code>[options]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**例子：**&lt;code>jps&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**例子：**&lt;code>jps -q&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**例子：**&lt;code>jps -lmv&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/8.png" alt="image-20210521113905035">&lt;/p>
&lt;p>我们可以发现，无论怎样的options，一定会显示&lt;code>JVM identifiers&lt;/code>，不同的options只是在&lt;code>JVM identifiers&lt;/code>的基础上显示更多的额外信息。&lt;/p>
&lt;p>了解到这个程度，实战中如有需要，可以再进一步查看命令行手册：&lt;/p>
&lt;p>&lt;code>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jps.html#CHDCGECD&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/9.png" alt="image-20210521114215905">&lt;/p>
&lt;h1 id="4配置查询-jinfo">4.配置查询-jinfo&lt;/h1>
&lt;h2 id="41解决什么问题">4.1.解决什么问题&lt;/h2>
&lt;p>jinfo用来查看JVM虚拟机参数，同时可以修改部分JVM虚拟机参数。&lt;/p>
&lt;h2 id="42参数">4.2.参数&lt;/h2>
&lt;ul>
&lt;li>jinfo的参数格式如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">jinfo [ option ] pid
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们可以通过几个实际的例子，快速理解&lt;code>[options]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>**例子：**&lt;code>jinfo &amp;lt;pid&amp;gt;&lt;/code>——查看此JVM进程所有的配置&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/10.png" alt="image-20210521115021019">&lt;/p>
&lt;ul>
&lt;li>**例子：**&lt;code>jinfo -sysprops &amp;lt;pid&amp;gt;&lt;/code>——等价于查看&lt;code>System.getProperties()&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/11.png" alt="image-20210521115146579">&lt;/p>
&lt;ul>
&lt;li>**例子：**&lt;code>jinfo -flags &amp;lt;pid&amp;gt;&lt;/code>——查看所有参数&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/12.png" alt="image-20210521115222055">&lt;/p>
&lt;ul>
&lt;li>**例子：**&lt;code>jinfo -flags &amp;lt;参数名&amp;gt; &amp;lt;pid&amp;gt;&lt;/code>——查看某个参数的值&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/13.png" alt="image-20210521115244080">&lt;/p>
&lt;p>我们可以发现：&lt;/p>
&lt;ul>
&lt;li>JVM进程的配置分为两类：&lt;code>系统环境变量&lt;/code>和&lt;code>JVM参数&lt;/code>，jinfo的参数用来输出上述两类配置。&lt;/li>
&lt;li>jinfo支持输出所有的配置值，也可以输出某一个指定参数的值。&lt;/li>
&lt;/ul>
&lt;p>了解到这个程度，实战中如有需要，可以再进一步查看命令行手册：&lt;/p>
&lt;p>&lt;code>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jinfo.html#BCGEBFDD&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/14.png" alt="image-20210521115706311">&lt;/p>
&lt;h1 id="5jvm状态监控与初步分析-jstat">5.JVM状态监控与初步分析-jstat&lt;/h1>
&lt;h2 id="51解决什么问题">5.1.解决什么问题&lt;/h2>
&lt;p>jstat可以输出JVM的各类状态(类加载、内存、GC、JIT)。&lt;/p>
&lt;p>初步定位的时候，就是通过上述状态，找到诸如内存泄露、线程死锁等问题的蛛丝马迹。&lt;/p>
&lt;h2 id="52参数">5.2.参数&lt;/h2>
&lt;ul>
&lt;li>jstat的参数格式如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">jstat [ generalOption | outputOptions vmid [ interval[s|ms] [ count ] ]
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>**例子：**jstat -class -t -h3 &lt;pid> 1000 5——采集类加载信息(每1000ms采样一次，采集5次，每3行打印1次表头)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/15.png" alt="image-20210521132054749">&lt;/p>
&lt;ul>
&lt;li>**例子：**jstat -compiler -t -h3 &lt;pid> 1000 5——采集JIT信息(每1000ms采样一次，采集5次，每3行打印1次表头)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/16.png" alt="image-20210521132151306">&lt;/p>
&lt;ul>
&lt;li>**例子：**jstat -printcompilation -t -h3 &lt;pid> 1000 5——采集已经被JIT编译过的方法(每1000ms采样一次，采集5次，每3行打印1次表头)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/17.png" alt="image-20210521132611139">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>**例子：**jstat -gc -t -h3 &lt;pid> 1000 5——采集GC的情况(每1000ms采样一次，采集5次，每3行打印1次表头)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**例子：**jstat -gccapacity -t -h3 &lt;pid> 1000 5&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**例子：**jstat -gcutil -t -h3 &lt;pid> 1000 5&lt;/p>
&lt;/li>
&lt;li>
&lt;p>**例子：**jstat -gccause -t -h3 &lt;pid> 1000 5&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/18.png" alt="image-20210521133656978">&lt;/p>
&lt;p>我们可以发现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>采样相关的参数：&lt;/strong>-t(Timestamp列，单位s) 、-h(周期性的增加表头)、interval(采样周期，单位ms)、count(采集次数)&lt;/li>
&lt;li>&lt;strong>类加载相关的参数：&lt;/strong>-class，显示ClassLoader信息，如：类加载数量、类卸载数量、总空间、类装载消耗的时间。&lt;/li>
&lt;li>&lt;strong>JIT相关的参数：&lt;/strong>-compiler(显示JIT编译过的方法、耗时)、-printcompilation(输出已经被JIT编译的方法)&lt;/li>
&lt;li>**垃圾回收相关的参数：**gcXxx，例如：-gc：显示GC相关的堆信息。包括Eden、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。&lt;/li>
&lt;/ul>
&lt;p>在此展开看一下垃圾回收相关参数输出的Gc信息，我们可以发现无论哪个gcXxx参数，都会输出如下信息：&lt;/p>
&lt;ul>
&lt;li>新生代相关&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">S0C：第1个幸存者区的大小(字节)
S1C：第2个幸存者区的大小(字节)
S0U：第1个幸存者区的已使用大小(字节)
S1U：第2个幸存者区的已使用大小(字节)
EC：Eden区的大小(字节)
EU：Eden区的已使用大小(字节)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>老年代相关&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">OC：老年代的大小(字节)
OU：老年代的已使用大小(字节)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>方法区相关&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">MC：方法区的大小
MU：方法区的已使用大小
CCSC：压缩类空间的大小
CCSU：压缩类空间的已使用大小
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>GC相关——如果发现两行之间的GC时间占总时间过长或者内存占用不断增加，说明可能有内存问题。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">YGC：从app启动到采样时，发生的YGC次数
YGCT：从app启动到采样时，发生的YGC的消耗时间(秒)
FGC：从app启动到采样时，发生的FullGC次数
FGTC：从app启动到采样时，发生的FullGC的消耗时间(秒)
GCT：从app启动到采样时，发生的GC的总时间(秒)
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/19.png" alt="image-20210521133405766">&lt;/p>
&lt;p>了解到这个程度，实战中如有需要，可以再进一步查看命令行手册：&lt;/p>
&lt;p>&lt;code>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jstat.html#BEHHGFAE&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/20.png" alt="image-20210521131317493">&lt;/p>
&lt;h1 id="6内存监控与分析-jmapjhat">6.内存监控与分析-jmap/jhat&lt;/h1>
&lt;h2 id="61解决什么问题">6.1.解决什么问题&lt;/h2>
&lt;ul>
&lt;li>jmap可以将内存信息导出为dump文件(也叫做堆转储快照文件)。
&lt;ul>
&lt;li>当用jstat初步定位发现疑似内存泄露时，就可以通过jmap将内存快照导出出来，进一步定位。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>jhat可以导入jmap导出的内存快照文件，进行相对可视化的查看。
&lt;ul>
&lt;li>jhat内置了一个微型的http服务器，用于查看dump文件的分析结果。&lt;/li>
&lt;li>JDK11已经删除了jhat，官方推荐用VisualVM替代。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="62参数">6.2.参数&lt;/h2>
&lt;ul>
&lt;li>jmap的参数格式如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">jmap [option] &amp;lt;pid&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>**例子：**jmap -dump:format=b,file=&amp;lt;filepath.hprof&amp;gt; &lt;pid>——手动导出某个时间点的内存快照，会触发1次FullGC，dump文件中会保存FullGC后留下的对象信息，对于大内存镜像会比较耗时。&lt;/li>
&lt;li>**例子：**java -jar xxx.jar -Xmx100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=&amp;lt;filepath.hprof&amp;gt;——当待定位的系统发生OOM的时候出现闪退时，此时会自动导出dump文件。&lt;/li>
&lt;/ul>
&lt;p>当然，如何分析dump文件是一个更大的话题，后续再展开。仅针对jmap命令行了解到这个程度，实战中如有需要，可以再进一步查看命令行手册：&lt;/p>
&lt;p>&lt;code>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jmap.html#CEGCECJB&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/21.png" alt="image-20210521135354519">&lt;/p>
&lt;h1 id="7线程监控与分析-jstack">7.线程监控与分析-jstack&lt;/h1>
&lt;h2 id="71解决什么问题">7.1.解决什么问题&lt;/h2>
&lt;p>jstack可以生成虚拟机指定进程当前时刻的线程快照，用于定位线程长时间停顿的原因。&lt;/p>
&lt;h2 id="72参数">7.2.参数&lt;/h2>
&lt;ul>
&lt;li>jstack的参数格式如下：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">jstack &amp;lt;pid&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>**例子：**jstack &lt;pid>——如果程序中有线程死锁，会在dump文件中体现出来。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/22.png" alt="image-20210521140136121">&lt;/p>
&lt;p>了解到这个程度，实战中如有需要，可以再进一步查看命令行手册：&lt;/p>
&lt;p>&lt;code>https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jstack.html#BABGJDIF&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%B7%A5%E5%85%B7%E3%80%91-0-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82JDK%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/23.png" alt="image-20210521135529140">&lt;/p>
&lt;h1 id="8总结">8.总结&lt;/h1>
&lt;p>本文主要内容：&lt;/p>
&lt;ul>
&lt;li>JVM性能监控与调优的工具有两种流派：命令行工具、可视化工具。&lt;/li>
&lt;li>学习命令行工具集的内在逻辑：工具间的关系、每个工具解决的问题、每个工具的参数分类。&lt;/li>
&lt;li>进程监控工具：jps&lt;/li>
&lt;li>配置查询工具：jinfo&lt;/li>
&lt;li>JVM状态监控工具：jstat&lt;/li>
&lt;li>内存监控与分析工具：jmap、jhat(jdk11用VisualVM替代)&lt;/li>
&lt;li>线程监控与分析工具：jstack&lt;/li>
&lt;/ul>
&lt;h1 id="9参考文献">9.参考文献&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>【执行引擎】-0-随机应变+有备而来</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/</link><pubDate>Thu, 05 Aug 2021 08:09:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/</guid><description>&lt;p>2017年，JEP317中提到了Graal编译器。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/1.png" alt="1">&lt;/p>
&lt;p>Graal编译器来自Oracle Labs更早的实验项目，随后并入GraalVM。&lt;/p>
&lt;p>Graal的商业目标是啥呢？Oracle借助Stack Overflow委婉地做了表达：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/2.png" alt="2">&lt;/p>
&lt;p>虽然Stack Overflow随后无情删帖，我们依然记住了关键词——&lt;strong>ultimate programming language&lt;/strong>&lt;/p>
&lt;p>什么语言有勇气宣称自己是&amp;quot;宇宙无敌终极编程语言&amp;rdquo;？&amp;ldquo;宇宙无敌终极编程语言&amp;quot;又是如何实现的呢？&lt;/p>
&lt;p>如果想深入探讨上述问题，我们必须先理解一个重要的知识——JVM的&lt;strong>执行引擎&lt;/strong>。&lt;/p>
&lt;h1 id="0x01执行引擎的3大流派">0x01.执行引擎的3大流派&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>解释型流派：随机应变&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Java的早期版本就属于解释型流派，从此也就留下了&amp;quot;Java性能不如C++&amp;quot;的口实。&lt;/p>
&lt;p>如下图红线所示，源代码通过前端编译器转换成字节码。在运行态，&lt;strong>解释器实时理解字节码&lt;/strong>，将字节码翻译成CPU可以执行的机器码。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/3_1.png" alt="3_1">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>提前编译流派：有备而来&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>如下图蓝线所示，如果我们暂不纠结&amp;quot;dll/so不等于机器码&amp;quot;的细节，提前编译器直接将源代码转换为抽象的机器码。&lt;/p>
&lt;p>接受这个流派，就意味着要承认**&amp;ldquo;Compile Once, Run Anywhere&amp;rdquo;(一次编译，到处去浪)**只是个美好的愿望。&lt;/p>
&lt;p>因此，IBM于1996年发布了提前编译器(IBM High Performance Compiler for Java)之后很长一段时间，提前编译流派就没有太多的故事和发展。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/3_2.png" alt="3_2">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>即时编译流派：随机应变+有备而来&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>即时编译流派(JIT)的思路是&lt;strong>解释器&lt;/strong>和&lt;strong>编译器&lt;/strong>协同工作。&lt;/p>
&lt;p>如下图红色线和紫色线所示，解释器先工作，过程中会发现某些字节码被频繁解释，于是&lt;strong>即时编译器&lt;/strong>开始工作，即时编译器将这些&lt;strong>热点代码&lt;/strong>转换为机器码，当热点代码需要再次执行时就不用解释了。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/3_3.png" alt="3_3">&lt;/p>
&lt;h1 id="0x02为什么历史选择了即时编译流派">0x02.为什么历史选择了即时编译流派?&lt;/h1>
&lt;p>解释型流派有点像吃铁板烧，顾客根据当时的心情，跟厨师说：&amp;ldquo;来一份马粪胆搭配牡丹虾、北海道带子、鳕场蟹&amp;rdquo;，厨师理解了顾客意图，现场制作美味。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/4.png" alt="4">&lt;/p>
&lt;p>随机应变的执行过程，给我们带来一些好处：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>减少准备工作的等待时间&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>如果是订酒席，我们就需要提前点菜、厨师提前做好。现场的就餐过程，只是把做好的菜端上来。&lt;/p>
&lt;p>稍大型的C++项目，将源代码编译成机器码，就是个漫长的过程。这个过程就像提前点菜、厨师提前把菜做好。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>具备运行时修正的可能性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>吃铁板烧的顾客点完菜，可能随后改了主意：“北海道带子换黑毛和牛吧”。如果是订酒席，厨师已经把菜做好了，顾客显然不能修改了。&lt;/p>
&lt;p>边解释边执行，就具备了**&amp;ldquo;动态性&amp;rdquo;**，这也是Java、Python、Ruby等语言的动态性的理论基础。&lt;/p>
&lt;p>随机应变的执行过程，也带来了弊端：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>慢&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>现场点菜，厨师越慢逼格越高，因为吃铁板烧不是个赶时间的事。但程序执行截然相反，执行效率堪比压榨CPU的性能极限。&lt;/p>
&lt;p>从宏观上看，随机应变相较于有备而来，少了准备过程，应该会慢。&lt;/p>
&lt;p>从微观上看，为什么解释型相比于提前编译型慢呢？关键点在于编译优化。&lt;/p>
&lt;p>例如：源代码中有一段空循环，编译器会发现这段无用功，输出机器码时进行抹除，然而解释器只是无脑地循环10万次。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">for(int i=0;i&amp;lt;100000;i++){
;
}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>本文无法展开编译优化这个更大的课题，但至少我们可以获得如下认知：&lt;/p>
&lt;p>&lt;strong>解释型流派与提前编译流派是天平的两端&lt;/strong>&lt;/p>
&lt;p>&lt;strong>即时编译流派本质是，在&amp;quot;边解释边执行&amp;quot;的基础上，实现了动态编译&lt;/strong>&lt;/p>
&lt;h1 id="0x03为什么即时编译器不止一种">0x03.为什么即时编译器不止一种?&lt;/h1>
&lt;p>前文，我们提到了编译优化，优化手段有的很常规，有的却很激进。本文摘录了一些激进的优化：&lt;/p>
&lt;blockquote>
&lt;p>Dead Code Elimination：无用代码消除&lt;/p>
&lt;p>Loop Unrolling：循环展开&lt;/p>
&lt;p>Loop Expression Hoisting：循环表达式外提&lt;/p>
&lt;p>Common Subexpression Elimination：消除公共子表达式&lt;/p>
&lt;p>Constant Propagation：常量传播&lt;/p>
&lt;p>Basic Block Reordering：基本块重排序&lt;/p>
&lt;p>Range Check Elimination：范围检查消除&lt;/p>
&lt;p>Null Check Elimination：空值检查消除&lt;/p>
&lt;p>Guarding Inlining：守护内联&lt;/p>
&lt;p>Branch Frequency Prediction：分支频率预测&lt;/p>
&lt;/blockquote>
&lt;p>如下图所示，Hotspot虚拟机的即时编译器就包含了C1和C2，同时在Java10加入了C2的替代者Graal。&lt;/p>
&lt;p>C1的职责只是常规的编译优化，C2则承担了更多激进优化的任务。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/5.png" alt="5">&lt;/p>
&lt;h1 id="0x04解释器与多种即时编译器的配合关系">0x04.解释器与多种即时编译器的配合关系&lt;/h1>
&lt;p>即时编译流派，首先还是解释器工作，热点代码触发即时编译器，即时编译一旦出现激进优化失败，就把执行权还给解释器。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/6.png" alt="6">&lt;/p>
&lt;p>以Hotspot为例，我们进一步打开解释器与即时编译器的配合过程：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Java 6以前，1个解释器+1个即时编译器&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>通过JVM的参数配置，我们只有2种选择：要么用**&amp;ldquo;解释器+C1即时编译器&amp;rdquo;**，要么用**&amp;ldquo;解释器+C2即时编译器&amp;rdquo;**。&lt;/p>
&lt;p>这种做法的缺点就是把选择困难症留给了Java程序员——我怎么知道这段代码适合激进优化还是保守优化呢？&lt;/p>
&lt;p>实际上，大部分情况是适合激进优化和保守优化的代码是纠缠在一起的。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Java 7以后，1个解释器+动态选择即时编译器&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>Java7以后，引入了&amp;rdquo;&lt;strong>分层编译&lt;/strong>&amp;ldquo;的理念，进而支持了动态选择即时编译器。&lt;/p>
&lt;p>理解&amp;quot;分层编译&amp;rdquo;，先看&amp;quot;层&amp;rdquo;：&lt;/p>
&lt;blockquote>
&lt;p>第0层：程序解释运行。解释器不开启性能监控功能。&lt;/p>
&lt;p>第1层：C1编译。进行简单和可靠的优化，不开启性能监控。&lt;/p>
&lt;p>第2层：C1编译。仅开启方法及回边次数统计等有限的性能监控。&lt;/p>
&lt;p>第3层：C1编译。开启全部性能监控，进一步收集分支跳转、虚方法调用版本等信息。&lt;/p>
&lt;p>第4层：C2编译。启用更多耗时较长的优化，还会依据性能监控信息进行不可靠的激进优化。&lt;/p>
&lt;/blockquote>
&lt;p>再看&amp;quot;分&amp;rdquo;——分是指**&amp;ldquo;分场景&amp;rdquo;**：&lt;/p>
&lt;blockquote>
&lt;p>普通场景：此场景下，热点代码触发C1，C1逐步开启全量性能监控，就会触发C2。&lt;/p>
&lt;p>简单代码场景：此场景下，热点代码触发C1，C1逐步开启全量监控，发现没必要C2，则关闭全量监控。&lt;/p>
&lt;p>C1繁忙场景：此场景下，C1繁忙，热点代码直接触发了C2。&lt;/p>
&lt;p>C2繁忙场景：此场景下，C2繁忙，热点代码触发C1，先开启有限的监控，随后进行全量监控，最后进入C2。&lt;/p>
&lt;/blockquote>
&lt;p>分场景触发的过程，周全且精细化地逐级开启性能监控，充分体现了JVM设计的精巧。这种精巧的设计其实也可以移植到性能敏感的产品中。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/7.png" alt="7">&lt;/p>
&lt;blockquote>
&lt;p>参考：https://www.infoq.cn/article/java-10-jit-compiler-graal&lt;/p>
&lt;/blockquote>
&lt;h1 id="0x05总结">0x05.总结&lt;/h1>
&lt;p>本文的目标是宏观阐述JVM执行引擎的全貌：&lt;/p>
&lt;blockquote>
&lt;p>1.JVM执行引擎的3大流派&lt;/p>
&lt;p>2.如何看待即时编译流派的利与弊&lt;/p>
&lt;p>3.解释器与即时编译器的配合方式——分层编译&lt;/p>
&lt;/blockquote>
&lt;p>结合笔者另外两篇文章《【类加载机制】从一道面试题开始》、《【运行时数据区】用仓库管理员的视角理解运行时数据区》，我们已经从宏观上看到了&lt;strong>JVM的三大构成&lt;/strong>，笔者将在后续文章中，与读者们继续深入与探索个中细节。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E3%80%91-0-%E9%9A%8F%E6%9C%BA%E5%BA%94%E5%8F%98+%E6%9C%89%E5%A4%87%E8%80%8C%E6%9D%A5/9.png" alt="image-20200916175340096">&lt;/p></description></item><item><title>【垃圾回收】-0-垃圾回收体系的主脉络</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/</link><pubDate>Thu, 05 Aug 2021 08:08:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/</guid><description>&lt;h1 id="1前言">1.前言&lt;/h1>
&lt;p>如果您的女盆友非常喜欢&lt;strong>买买买&lt;/strong>，她将会面临一个严峻的问题——&lt;strong>储物空间不够&lt;/strong>。&lt;/p>
&lt;p>所以她需要定期**&amp;ldquo;断舍离&amp;rdquo;**：过一段时间将陈旧的包包、衣服移到不常用的储物柜，再过一段时间把这些不常用的衣物丢掉。&lt;/p>
&lt;p>Java代码也像女盆友一样，喜欢**&amp;ldquo;买买买&amp;rdquo;**——创建大量对象，所以也会面临**内存空间不足**。&lt;/p>
&lt;p>JVM的垃圾回收机制承担了**&amp;ldquo;断舍离&amp;rdquo;**的职责。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/image-20210122102351258.png" alt="image-20210122102351258">&lt;/p>
&lt;p>下面，我们来宏观地理解一下垃圾回收体系的主脉络。&lt;/p>
&lt;h1 id="2where垃圾收集的目标区域">2.Where：垃圾收集的目标区域&lt;/h1>
&lt;h2 id="目标区域">目标区域&lt;/h2>
&lt;p>垃圾回收，&lt;strong>首先要圈定范围&lt;/strong>。&lt;/p>
&lt;p>垃圾回收的目标区域主要发生在运行时数据区的&lt;strong>堆、方法区&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/2.png" alt="image-20210107141117798">&lt;/p>
&lt;p>稍微回顾一下运行时数据区的一些知识：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>堆(Heap)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>堆=年轻代+老年代&lt;/p>
&lt;p>年轻代=伊甸园区(Eden)+幸存者区0(S0)+幸存者区1(S1)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/3.png" alt="image-20210107143110413">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>方法区(Method Area)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>方法区是站在类加载子系统的角度的一种逻辑说法。&lt;/p>
&lt;p>方法区的具体实现是什么呢？&lt;/p>
&lt;p>JDK8之前，是永久代。&lt;/p>
&lt;p>JDK8以后，是采用堆外内存实现的元空间。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/4.png" alt="image-20210107143140440">&lt;/p>
&lt;p>所以，更准确地说，垃圾回收的目标区域主要发生在运行时数据区的&lt;strong>年轻代、老年代、元空间&lt;/strong>。&lt;/p>
&lt;h2 id="被回收区域的特征">被回收区域的特征&lt;/h2>
&lt;p>根据分代理论，运行时数据区的各个区域存放的对象有如下特点：&lt;/p>
&lt;ul>
&lt;li>伊甸园区存放的对象，可以简化理解为新对象，有点像&lt;strong>刚买回来的2021新款LV包包&lt;/strong>&lt;/li>
&lt;li>幸存者区存放的对象，可以简化理解为存活了一段时间的对象，有点像&lt;strong>去年买回来的LV包包&lt;/strong>&lt;/li>
&lt;li>老年代存放的对象，可以简化理解为存活很久的对象或者很大的对象，有点像&lt;strong>过气的LV包包&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/image-20210122135157426.png" alt="image-20210122135157426">&lt;/p>
&lt;h2 id="不同区域不同回收方式">不同区域，不同回收方式&lt;/h2>
&lt;p>每次收拾储物空间，可以根据当前的时间、当前的需要，分批收拾。&lt;/p>
&lt;p>垃圾收集也一样，面对不同区域的对象，也会采用不同的回收方式分批回收：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>部分收集法&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>YGC&lt;/strong>：也叫Minor GC，针对年轻代垃圾收集。&lt;/li>
&lt;li>&lt;strong>OGC&lt;/strong>：也叫Major GC，针对老年代垃圾收集。&lt;/li>
&lt;li>&lt;strong>混合GC&lt;/strong>：年轻代、老年代一起垃圾收集。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>全量收集法&lt;/strong>：年轻代、老年代、元空间一起垃圾收集。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/6.png" alt="image-20210107152239170">&lt;/p>
&lt;h1 id="3when何时会触发垃圾回收">3.When：何时会触发垃圾回收&lt;/h1>
&lt;p>明确了垃圾回收的范围，下一步就是明确回收时机。&lt;/p>
&lt;ul>
&lt;li>YGC：年轻代的伊甸园区满，就好像放新款包包的储物格满了，就会触发YGC。&lt;/li>
&lt;li>OGC：老年代满，就好像老款专属储物格满了，会触发OGC。&lt;/li>
&lt;li>FullGC：触发FullGC的条件很多(详见下图)，就好像整个储物柜一起收集。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/7.png" alt="image-20210107154209483">&lt;/p>
&lt;h1 id="4how垃圾回收算法">4.How：垃圾回收算法&lt;/h1>
&lt;p>&lt;em>说明：本文篇幅有限，不展开任何算法的细节，仅帮助读者建立宏观概念，笔者将在后续文章中详细阐述各种算法细节。&lt;/em>&lt;/p>
&lt;h2 id="41什么是垃圾">4.1.什么是垃圾？&lt;/h2>
&lt;p>断舍离的时候，什么样的包包算**&amp;ldquo;过时&amp;rdquo;**？一定是有个标准的。&lt;/p>
&lt;p>对于垃圾回收算法也一样，认定无用对象的经典算法有两种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>引用计数算法&lt;/strong>：此算法是在每个对象上增加一个计数器，表示这个对象被多少其它对象引用了。如果某个对象的引用计数器=0，则这个对象被定义为垃圾。&lt;/li>
&lt;li>&lt;strong>可达性分析算法&lt;/strong>：此算法规定了一组满足条件的对象作为根节点，从这些根节点出发，搜索对象的引用链条，最终形成一个有向图，图中孤立的对象节点，就被定义为垃圾。&lt;/li>
&lt;/ul>
&lt;p>上述垃圾评价算法，各有利弊，后续会展开讨论，在此仅需要有一个概念：这套算法，就是帮助JVM识别一个对象是否属于垃圾。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/8.png" alt="image-20210107172657461">&lt;/p>
&lt;h2 id="42如何回收垃圾">4.2.如何回收垃圾？&lt;/h2>
&lt;p>识别出了垃圾，就要&lt;strong>有节奏地&lt;/strong>、&lt;strong>高效&lt;/strong>地开展垃圾回收。&lt;/p>
&lt;p>好吧，问题来了：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>有节奏意味着慢慢来&lt;/strong>：肯定要给女盆友时间慢慢收拾，把稍微过时的包包放到不常用的储物格子，把非常过时的包包直接丢掉。&lt;/li>
&lt;li>&lt;strong>高效意味着快&lt;/strong>：如果女盆友收拾的太慢，就没有人给您做饭了。&lt;/li>
&lt;/ul>
&lt;p>这也是影响JVM性能优化最大的课题：&lt;/p>
&lt;ul>
&lt;li>如何快速垃圾回收&lt;/li>
&lt;li>如何避免STW问题：Stop The World问题，就是垃圾回收过程中，导致业务代码卡顿。&lt;/li>
&lt;/ul>
&lt;p>这些就是现存的这么多种垃圾回收算法要攻克的核心课题。&lt;/p>
&lt;p>我们接下来宏观地理解一下各类&lt;strong>垃圾回收算法&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/9.png" alt="image-20210107170509963">&lt;/p>
&lt;p>我们先看看3种最基础、最经典的&lt;strong>基础算法&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Mark-Sweep&lt;/strong>：标记-清除算法&lt;/li>
&lt;li>&lt;strong>Copying&lt;/strong>：复制算法&lt;/li>
&lt;li>&lt;strong>Mark-Compact&lt;/strong>：标记-压缩算法&lt;/li>
&lt;/ul>
&lt;p>从收集的区域看，有1种基于上述3种基础算法的&lt;strong>组合算法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分代收集算法&lt;/strong>：本质就是不同的区域，采用不同的上述3种基础算法。&lt;/li>
&lt;/ul>
&lt;p>从收集的方式看，有1种基于上述3种基础算法&lt;strong>组合算法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>增量收集算法&lt;/strong>：本质是业务代码运行和垃圾回收交替进行。&lt;/li>
&lt;/ul>
&lt;p>随着Java的不断发展，又发展出一种新的门派&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分区算法&lt;/strong>：本质是将内存区域划分为很多小方格，每个格子按需放对象，与分代理论最大的不同是，同一类型的对象不一定要放在逻辑连续的代。如下图，同样是伊甸园区的对象，并不需要占据逻辑连续的伊甸园区。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/10.png" alt="image-20210107161323691">&lt;/p>
&lt;h1 id="5垃圾回收器垃圾回收算法的具体实现">5.垃圾回收器：垃圾回收算法的具体实现&lt;/h1>
&lt;p>&lt;em>说明：本文篇幅有限，在后续文章中展开垃圾回收器的细节。&lt;/em>&lt;/p>
&lt;p>垃圾回收器是垃圾回收算法的具体实现，但是理解垃圾回收器对我们有两个难题：&lt;/p>
&lt;ul>
&lt;li>有多种垃圾回收器&lt;/li>
&lt;li>每种垃圾回收器都主攻某种场景，为了满足大部分业务场景，必须合理组合使用多种垃圾回收器&lt;/li>
&lt;/ul>
&lt;h2 id="51为什么会有多种垃圾回收器呢">5.1.为什么会有多种垃圾回收器呢？&lt;/h2>
&lt;p>除了业务软件对JVM垃圾回收性能的诉求，还有商业原因(例如：Sun认了Oracle当爸爸，例如：RedHat企图当干爹，但亲爹Oracle不让)。&lt;/p>
&lt;h2 id="52如何搭配使用多种垃圾回收器呢">5.2.如何搭配使用多种垃圾回收器呢？&lt;/h2>
&lt;p>本文仅以JDK8为例，列举出垃圾回收器的经典搭配方法：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Serial+Serial Old&lt;/strong>： Serial回收器处理年轻代，Serial Old回收器处理老年代。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/11.png" alt="image-20210107182038415">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ParNew+CMS+Serial Old&lt;/strong>： ParNew处理年轻代，CMS处理老年代，当CMS失效时，Serial Old回收器兜底老年代。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/12.png" alt="image-20210107182113952">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Parallel Scanvenge+Parallel Old&lt;/strong>： Parallel Scanvenge处理年轻代，Parallel Old处理老年代。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/13.png" alt="image-20210107182137752">&lt;/p>
&lt;ul>
&lt;li>**Parallel Scanvenge + Serial Old：**Parallel Scanvenge处理年轻代，Serial Old处理老年代。这种搭配关系在JDK14以后就开始废弃了。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/14.png" alt="image-20210107182201742">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>G1&lt;/strong>：G1是个神奇的存在，一个回收器通吃年轻代和老年代。这也是JVM目前主推的回收器。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/15.png" alt="image-20210107221548740">&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>本文讲解了垃圾回收体系的主脉络：&lt;/p>
&lt;ul>
&lt;li>垃圾回收发生在年轻代、老年代、方法区。&lt;/li>
&lt;li>垃圾回收的方式：YGC(Minor GC)、OGC(Major GC)、FullGC&lt;/li>
&lt;li>年轻代伊甸园区满时，触发YGC&lt;/li>
&lt;li>老年代满时，触发OGC&lt;/li>
&lt;li>有多种条件，触发FullGC(详见前文配图)&lt;/li>
&lt;li>引用计数算法和可达性分析算法，用来识别哪些对象是垃圾。&lt;/li>
&lt;li>垃圾回收的三种基础算法：标记-清除算法(Mark-Sweep)、复制算法(Copying)、标记-压缩算法(Mark-Compact)&lt;/li>
&lt;li>垃圾回收的两种组合算法：分代收集算法、增量收集算法&lt;/li>
&lt;li>垃圾回收的新门派组合算法：分区收集算法&lt;/li>
&lt;li>由于商业原因和业务需求，JVM提供7种经典垃圾回收器。&lt;/li>
&lt;li>实战时，搭配使用不通过垃圾回收器，满足回收年轻代和老年代的场景。&lt;/li>
&lt;li>G1是一种特殊的垃圾收集器，通吃年轻代和老年代的垃圾回收。&lt;/li>
&lt;/ul>
&lt;p>如果从宏观上理解了垃圾回收体系的全貌，相信聪明的读者不用死记硬背也能得到题目的答案，请您将答案写在下面的评论区吧！&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/image-20210122140538305.png" alt="image-20210122140538305">&lt;/p>
&lt;h1 id="废弃">废弃&lt;/h1>
&lt;p>如果把&lt;strong>JVM&lt;/strong>类比为一座&lt;strong>工厂&lt;/strong>，那么运行时产生的各种&lt;strong>对象&lt;/strong>就像这座工厂里的&lt;strong>打工人&lt;/strong>，&lt;strong>运行时数据区&lt;/strong>就像打工人的&lt;strong>工位&lt;/strong>。&lt;/p>
&lt;p>铁打的营盘流水的兵，工位有限，企业主会安排HR开展裁员工作——清理没价值的打工人，为新人腾出工位。&lt;/p>
&lt;p>&lt;strong>垃圾回收体系&lt;/strong>就是JVM中，扮演了这个最无情的角色。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%91-0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%BD%93%E7%B3%BB%E7%9A%84%E4%B8%BB%E8%84%89%E7%BB%9C/1.png" alt="image-20210107150610240">&lt;/p>
&lt;p>站在打工人(对象)的角度，垃圾回收体系是无情的存在。&lt;/p>
&lt;p>但站在企业主(JVM)的角度，垃圾回收体系是维系正常生产的重要部件。&lt;/p></description></item><item><title>【运行时数据区】-0-用仓库管理员的视角理解运行时数据区</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</link><pubDate>Thu, 05 Aug 2021 08:07:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</guid><description>&lt;h1 id="0x01面试题">0x01.面试题&lt;/h1>
&lt;p>&amp;ldquo;运行时数据区&amp;quot;是JVM面试题的热门考点。&lt;/p>
&lt;p>实战中，内存泄露的定位、性能调优，往往也取决于我们对&amp;quot;运行时数据区&amp;quot;理解深度。&lt;/p>
&lt;p>以下面试题来自百度搜索：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>From百度&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>三面：请阐述JVM内存模型，有哪些区？分别干什么的？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>From蚂蚁金服&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>请阐述Java8内存分代改进?&lt;/p>
&lt;p>JVM内存分哪几个区，每个区的作用是什么？&lt;/p>
&lt;p>一面： JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？&lt;/p>
&lt;p>二面： Eden和survivor的比例分配?&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>From小米&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>JVM为什么要有新生代和老年代?&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>From字节跳动&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>二面： Java的内存分区&lt;/p>
&lt;p>二面：讲讲JVM运行时数据区&lt;/p>
&lt;p>什么时候对象会进入老年代？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>From京东&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>JVM的内存结构，Eden和Survivor比例 。&lt;/p>
&lt;p>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>From拼多多&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>JVM内存分哪几个区，每个区的作用是什么？&lt;/p>
&lt;/blockquote>
&lt;h1 id="0x02如何更好的理解运行时数据区">0x02.如何更好的理解运行时数据区&lt;/h1>
&lt;p>笔者认为**&amp;ldquo;理解优于记忆&amp;rdquo;**，在笔者其它文章中，也反复表达了这个观点。&lt;/p>
&lt;p>那么，对于运行时数据区，怎样&lt;strong>理解的方法&lt;/strong>更好？怎样的&lt;strong>理解程度&lt;/strong>才算透彻？&lt;/p>
&lt;p>运行时数据区，本质就是JVM能够管理的内存。&lt;/p>
&lt;p>&lt;strong>管理内存，我们要考虑如下几件事：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从职责的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>内存分几个区域？每个内存分区装什么数据？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>从优化的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>怎样充分利用内存？(防御经典的内存碎片问题)&lt;/p>
&lt;p>将不同类型的数据(短生命周期的数据、体积大的数据等)存入内存的流程怎样更高效？&lt;/p>
&lt;p>废弃的数据何时回收、如何回收？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>从协作的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>不同的线程公用同一个内存分区，如何保证安全可靠？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>从归属的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果是虚拟机流派的语言，则要考虑这片内存属于虚拟机内存还是操作系统&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>用大白话理解&lt;/strong>，&lt;strong>管理内存&lt;/strong>和&lt;strong>管理仓库&lt;/strong>是一个意思：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从职责的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>仓库分几个货架？每个货架装什么货物？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>从优化的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>怎样充分利用仓库？(货架上零零散散的放着货物，又不好找，来了大的货物也放不下)&lt;/p>
&lt;p>将不同类型的货物(有的货物就是临时放一下、有的货物很大)放进货架的流程怎样更高效？&lt;/p>
&lt;p>废弃的货物何时回收、如何回收？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>从协作的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>两个不同的管理员都要往同一个货架上放东西，怎么协调？&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>从归属的角度看&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如果菜鸟驿站的仓库放不下，能不能租一下顺丰的仓库呢？&lt;/p>
&lt;/blockquote>
&lt;p>笔者学习运行时数据区时，脑海中就出现了一位仓库管理员，那些复杂抽象的理论也变得简单了。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/1.png" alt="image-20200906184141304">&lt;/p>
&lt;h1 id="0x03运行时数据区的全景">0x03.运行时数据区的全景&lt;/h1>
&lt;p>&lt;strong>首先，我们要知道运行时数据区包括哪5个区域？&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>程序计数器&lt;/p>
&lt;p>方法区&lt;/p>
&lt;p>堆&lt;/p>
&lt;p>虚拟机栈&lt;/p>
&lt;p>本地方法栈&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>然后，我们再看运行时数据区如何与JVM中的上下游模块交互？&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>STEP1.程序员编写的java文件被&amp;quot;编译器&amp;quot;转换为.class文件&lt;/p>
&lt;p>STEP2.类加载子系统将.class文件加载到&amp;quot;运行时数据区&amp;quot;的&amp;quot;方法区&amp;rdquo;&lt;/p>
&lt;p>STEP3.执行引擎执行&amp;quot;方法区&amp;quot;中的方法，不断改变着&amp;quot;运行时数据区&amp;quot;的&amp;quot;堆&amp;rdquo;、&amp;ldquo;虚拟机栈&amp;quot;中的数据&lt;/p>
&lt;/blockquote>
&lt;p>为避免陷入上述步骤中术语的细节，我们借助仓库货架，&lt;strong>通俗的类比&lt;/strong>一下[1]：&lt;/p>
&lt;blockquote>
&lt;p>STEP1.小美下单买了件衣服，淘宝店家将小美的订单转换成出库单——淘宝店家就像&amp;quot;编译器&amp;rdquo;&lt;/p>
&lt;p>STEP2.仓库管理员全蛋哥将出库单打印出来，还把商家的入库单也打印出来了。——打印出来的纸件就像&amp;quot;方法区&amp;rdquo;&lt;/p>
&lt;p>STEP3.全蛋哥按照入库单、出库单，在仓库货架上搬货出库和入库，完成一笔就在纸上打个勾。——货架就像&amp;quot;堆&amp;rdquo;，卷毛弟在入库单、出库单上打的勾的过程就像是在更新&amp;quot;虚拟机栈&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/2.png" alt="2">&lt;/p>
&lt;h1 id="0x04从优化角度看管理重点">0x04.从优化角度看管理重点&lt;/h1>
&lt;p>读到这里，如果您已经建立了&lt;strong>内存管理与仓库管理的类比关系&lt;/strong>，我们就可以&lt;strong>从优化的角度，思考一下管理环节的重点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>方法区的职责是存储&amp;quot;模板&amp;rdquo;&lt;/strong>，例如：程序员在代码中定义了哪些类、类和类的关系等。那么方法区是管理的重点吗？有的读者会认为&amp;quot;模板&amp;quot;太多就有可能导致方法区不够用，这种想法对吗？读者可以阅读笔者的另一篇文章《【类加载机制】从一道面试题开始》，尝试寻找答案。本文先不下结论，暂且认为&amp;rdquo;&lt;strong>方法区可能是管理重点&amp;rdquo;&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>堆的职责是存储&amp;quot;广义的对象&amp;rdquo;&lt;/strong>，例如：根据某个类创建对象，对象的实体就是放在堆中。堆够不够用，是程序员决定的，就好像仓库的货架够不够用是消费者下订单多少决定的。但JVM和仓库管理员应该尽量优化货架的摆放，保证尽量不要让货架放不下。因此，&amp;quot;&lt;strong>堆肯定是管理重点&lt;/strong>&amp;rdquo;&lt;/li>
&lt;li>&lt;strong>虚拟机栈的职责是&amp;quot;记录方法执行时产生的过程数据产生数据&amp;rdquo;&lt;/strong>，这句话有点抽象，我们可以想象一张出库单要求在1号货架拿出一箱酒、在2号货架拿出一件衣服。仓库管理员抱着一箱酒再去2号货架拿衣服肯定不方便，于是仓库管理员临时把一箱酒放在仓库角落，等拿到衣服以后再把酒抱起来一起出库。我们继续想象，如果有10个仓库管理员都这么操作，仓库角落就乱七八糟的临时放了一堆东西。。。于是，&amp;quot;&lt;strong>虚拟机栈也成为了管理重点&lt;/strong>&amp;rdquo;&lt;/li>
&lt;li>程序计数器、本地方法栈，概念、职责都比较好理解，笔者在后续文章中详述，这里就直接给出结论**&amp;ldquo;程序计数器、本地方法栈不是管理重点&amp;rdquo;**&lt;/li>
&lt;li>读者可以结合下图，再理解一下上述文字。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/3.png" alt="2">&lt;/p>
&lt;h1 id="0x05从协作角度看共享区域">0x05.从协作角度看共享区域&lt;/h1>
&lt;ul>
&lt;li>前文已经阐述了方法区的职责，管理员全蛋哥能看的&amp;quot;模板&amp;rdquo;，管理员卷毛弟肯定也能看。因此，&lt;strong>方法区肯定是共享的&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>堆是共享的&lt;/strong>。有一种场景，全蛋哥看了一下卷毛弟的出库单：咦，你也是拿货送给世纪彩城的客户啊，要不我这个单子的货你一起送了呗。&lt;/li>
&lt;li>&lt;strong>虚拟机栈是独享&lt;/strong>的。这个更好理解，要全蛋哥和卷毛弟只打一份出库单，手牵手去出货，除了摩擦出火花，工作效率应该高不起来。&lt;/li>
&lt;li>对于程序计数器、本地方法栈，本文只说结论&lt;strong>程序计数器、本地方法栈是独享&lt;/strong>的。&lt;/li>
&lt;li>读者可以结合下图，再理解一下上述文字。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/4.png" alt="4">&lt;/p>
&lt;h1 id="0x06从归属角度看内存">0x06.从归属角度看内存&lt;/h1>
&lt;ul>
&lt;li>这里要“剧透”方法区的一个细节，即，方法区中包含了一个&amp;quot;常量池&amp;quot;区域。这就导致了方法区可能经常不够用。于是在JVM的发展历程中，逐渐直接使用了操作系统的内存。这就好像自家的仓库不够用了，就租用了隔壁家更大的仓库一样。&lt;/li>
&lt;li>读者可以结合下图，再理解一下[1]。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E3%80%91-0-%E7%94%A8%E4%BB%93%E5%BA%93%E7%AE%A1%E7%90%86%E5%91%98%E7%9A%84%E8%A7%86%E8%A7%92%E7%90%86%E8%A7%A3%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/5.png" alt="5">&lt;/p>
&lt;blockquote>
&lt;p>[1]：不同虚拟机尝试的实现细节不同，上图中方法区以及方法区的归属特指HotSpot的JDK8+版本。&lt;/p>
&lt;/blockquote>
&lt;h1 id="0x07总结">0x07.总结&lt;/h1>
&lt;p>从上述的分析与论述中，我们很容易发现：&lt;/p>
&lt;ul>
&lt;li>方法区、堆、虚拟机栈是内存管理的重点&lt;/li>
&lt;li>方法区、堆是共享的，虚拟机栈是独享的&lt;/li>
&lt;li>方法区是直接使用了操作系统内存&lt;/li>
&lt;/ul>
&lt;p>另外，JVM中诸多技术点较为抽象，用通俗易懂的方式进行类比，非常有利于我们更快更好的学习、攻克JVM。笔者其它的文章也会尽量延续这种方式。&lt;/p></description></item><item><title>【类加载机制】-0-从一道面试题开始</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-0-%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B/</link><pubDate>Thu, 05 Aug 2021 08:06:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-0-%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BC%80%E5%A7%8B/</guid><description>&lt;h1 id="0x01一道面试题">0x01.一道面试题&lt;/h1>
&lt;p>&lt;strong>请阐述Java自带哪些加载器以及对应的职责？&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>(1)Bootstrap ClassLoader(启动类加载器)：负责加载&amp;lt;JAVA_HOME&amp;gt;\lib目录，或-Xbootclasspath指定目录下的jar。
特殊说明：JVM认为合理的jar文件名才会被加载，例如：rt.jar、tools.jar，文件名不符合的jar即使放在上述目录下也不会被加载。&lt;/p>
&lt;p>(2)Extension ClassLoader(扩展类加载器)：负责加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录，或java.ext.dirs指定目录下的jar。
特殊说明：Java9以后引入了模块化机制，此加载器被此机制取代。&lt;/p>
&lt;p>(3)Application ClassLoader(应用程序类加载器)：负责加载用户类路径(ClassPath)上的jar包。&lt;/p>
&lt;/blockquote>
&lt;p>此题考察JVM的类加载机制，关于类加载机制可以衍生出的考察方式也很多：
例如：请你选出哪些不是Java自带的类加载器；
例如：给出各类类加载器的描述、职责，选错误的；
例如：将上述类加载器的特殊说明作为干扰选项；&lt;/p>
&lt;h1 id="0x02不要背要理解">0x02.不要背，要理解&lt;/h1>
&lt;p>至此，我们似乎没必要大费周章地解读这样一道记忆题。背下来不就可以了吗？笔者认为不是：
发展24年的Java及JVM，历经若干版本的商业斗争[1]，衍生出若干语(语)言(法)特(陷)性(阱)。
&amp;ldquo;背下来就行&amp;quot;的前提有二，可惜对于Java这些语(语)言(法)特(陷)性(阱)都不成立：&lt;/p>
&lt;blockquote>
&lt;p>(1)知识输入是无二义性的、与时俱进的。
(2)知识输入是有限集。&lt;/p>
&lt;/blockquote>
&lt;p>所以，笔者坚定的认为只有Java程序员最有资格喊出&amp;rdquo;&lt;strong>我秃了，我也变强了&lt;/strong>&amp;quot;。
所以，笔者坚定的认为只有&amp;rdquo;&lt;strong>深刻理解JVM&lt;/strong>&amp;quot;(即，深刻理解语法特性到JVM层，甚至操作系统层)，是Java程序员的最有效的防秃良药。
&lt;img src="images/1.png" alt="1">&lt;/p>
&lt;blockquote>
&lt;p>[1]：A new future for Java：https://theboreddev.com/a-new-future-for-java/&lt;/p>
&lt;/blockquote>
&lt;h1 id="0x03从韩国星工厂看类加载机制的全貌">0x03.从韩国星工厂看类加载机制的全貌&lt;/h1>
&lt;blockquote>
&lt;p>From《深入理解Java虚拟机》-周志明&lt;/p>
&lt;p>Java虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终变成被虚拟机可以直接使用的Java类型，这个过程被称作Java虚拟机的类加载机制&amp;hellip;&amp;hellip;与那些在编译时需要进行连接的语言不同，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的&amp;hellip;&amp;hellip;用户可以通过Java预置的或自定义类加载器&amp;hellip;作为其程序代码的一部分。&lt;/p>
&lt;/blockquote>
&lt;p>从这段经典且严谨的描述，我们可以抽象8个问题，以此宏观地获得类加载机制的全貌：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">问题1：加载什么？
问题2：加载得到了什么？
问题3：从哪里加载？
问题4：加载到哪里去？
问题5：何时加载？
问题6：加载流程有几步？
问题7：加载流程如何实现？
问题8：类加载器的约束？
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="1加载什么">(1)加载什么？&lt;/h2>
&lt;p>我们在.java文件中编写了一堆代码，被转换成字节码(.class文件)，&lt;strong>JVM加载就是这个字节码&lt;/strong>。
这个&lt;strong>字节码描述的信息&lt;/strong>[2]包括(但不限于)：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">有哪些类、哪些接口；
每个类有哪些属性、行为；
类和类的关系；
...
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这些信息就是程序员定义的&amp;quot;模板&amp;rdquo;，在程序运行时，当需要基于类A创建实例对象a时，JVM就要先找到类A对应的&amp;quot;模板&amp;rdquo;。&lt;/p>
&lt;p>这些&amp;quot;模板&amp;rdquo;，就像韩国星工场包装女团时的&amp;quot;剧本&amp;rdquo;，每个女星都是基于某个&amp;quot;模板&amp;quot;创建的实例对象，女星的身高、体重、才艺就是&amp;quot;模板&amp;quot;中描述的&amp;quot;属性、行为&amp;rdquo;。
&lt;img src="images/2.png" alt="2">&lt;/p>
&lt;blockquote>
&lt;p>[2]本文聚焦类加载机制的全貌，在后续文章中展开&lt;/p>
&lt;/blockquote>
&lt;h2 id="2加载得到了什么">(2)加载得到了什么？&lt;/h2>
&lt;p>字节码加载到内存后得到的信息内容还是(1)中提到的字节码中包含的信息，但信息形式变了，抽象、简单地理解为&lt;strong>JVM能认识的数据结构&lt;/strong>[3]。&lt;/p>
&lt;p>这就像娱乐公司的策划团队在电脑上写好了女团出道的&amp;quot;剧本&amp;rdquo;，女团的经纪人要无差错地仔细阅读&amp;quot;剧本&amp;quot;的电子件，把&amp;quot;剧本&amp;quot;存储在大脑中，以备后续使用。
&lt;img src="images/3.png" alt="3">&lt;/p>
&lt;blockquote>
&lt;p>[3]本文聚焦类加载机制的全貌，在后续文章中展开&lt;/p>
&lt;/blockquote>
&lt;h2 id="3从哪里加载">(3)从哪里加载？&lt;/h2>
&lt;p>用一张表，说明字节码文件与经纪人的类比关系：&lt;/p>
&lt;p>&lt;img src="images/t1.png" alt="t1">&lt;/p>
&lt;p>这一点也是&lt;strong>JVM给Java程序员的自由&lt;/strong>，很多著名的产品就是在这个点上做了文章。&lt;/p>
&lt;h2 id="4加载到哪里去">(4)加载到哪里去？&lt;/h2>
&lt;p>这个问题最好回答：内存，具体指的是JVM的&lt;strong>运行时数据区&lt;/strong>，再具体一点是运行时数据区中的&lt;strong>方法区&lt;/strong>[4]&lt;/p>
&lt;p>&lt;img src="images/4.png" alt="4">&lt;/p>
&lt;blockquote>
&lt;p>[4]本文聚焦类加载机制的全貌，在后续文章中展开&lt;/p>
&lt;/blockquote>
&lt;h2 id="5何时加载">(5)何时加载？&lt;/h2>
&lt;p>类加载发生在运行时，这也是Java、C#这类语言推崇的动态性。&lt;/p>
&lt;p>动态性是一把双刃剑，运行时加载意味着需要&amp;quot;边执行，边连接&amp;rdquo;。
这就好像女团经纪人不是提前把&amp;quot;剧本&amp;quot;烂熟于胸，而是到了女团演出现场，才掏出&amp;quot;剧本&amp;rdquo;，现场理解、现场执行。
以现实生活的经验，这样的经纪人，看起来不太靠谱。&lt;/p>
&lt;p>当然，动态性一定是源于某些特定场景和需求，Java为了靠谱，也引出了虚拟机中另一个大的课题：JIT(即时编译)，围绕着&amp;quot;如何提升运行时的编译效率&amp;quot;会有很多有趣的故事。&lt;/p>
&lt;h2 id="6加载流程有几步">(6)加载流程有几步？&lt;/h2>
&lt;p>在(2)中我们提到女团的经纪人要无差错地仔细阅读&amp;quot;剧本&amp;quot;的电子件，关键词是&lt;strong>无差错&lt;/strong>
我们再用一张表，类比一下[5]&lt;/p>
&lt;p>&lt;img src="images/t2.png" alt="image-20200905163221231">&lt;/p>
&lt;p>表格中存在不严谨(通俗)的表达，但相信读者已经关注到了两个核心要点：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">(1)加载流程有几步
(2)每一步的作用是什么
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>[5]上述加载流程每一步存在一些JVM实现的细节，例如：上述步骤一定是顺序执行的吗？例如：直接引用需要反复解析吗？这些都有必要详细解读，本文暂不展开&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="images/5.png" alt="5">&lt;/p>
&lt;h2 id="7加载流程如何实现">(7)加载流程如何实现？&lt;/h2>
&lt;p>至此，终于可以和本文开头的面试题呼应上了，前文我们探讨了&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">加载什么=&amp;gt;加载得到了什么=&amp;gt;从哪里加载=&amp;gt;加载到哪里去=&amp;gt;何时加载=&amp;gt;加载流程有几步
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>那么这都是JVM的规范、规格，怎么实现？&lt;strong>类加载器&lt;/strong>就是类加载机制的具体实现。
不同类型的加载器相当于公司不同的角色，都去自己专属的文件夹去查找并加载类&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">Bootstrap加载器相当于经济公司老板
Extension加载器相当于经纪人
Application加载器相当于女团艺人
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="8类加载器的约束">(8)类加载器的约束？&lt;/h2>
&lt;p>既然有不同的类加载器，它们之间必然有配合关系，否则两个人干了同一个工作，对外口径还不同，咋办？
JVM定义了这种配合关系，还取了个高大上的名字&amp;quot;双亲委派模型&amp;rdquo;，笔者认为这种模型应该叫&amp;quot;保姆式管理模型&amp;rdquo;
还是一张表类比一下：&lt;/p>
&lt;p>&lt;img src="images/t3.png" alt="image-20200905163353382">&lt;/p>
&lt;p>&lt;img src="images/6.png" alt="6">&lt;/p>
&lt;p>双亲委派模型，本质上是说&amp;quot;领导先上，领导不行我再上&amp;rdquo;。
这种管理风格，自然也有弊端。历史上有&lt;strong>4次破坏双亲委派模型&lt;/strong>[6]的事件。
破坏双亲委派模型的本质，是&amp;quot;管理团队的风格多样化&amp;rdquo;，例如：&amp;ldquo;扁平化团队&amp;rdquo;、&amp;ldquo;先干了再说团队&amp;quot;等等。&lt;/p>
&lt;blockquote>
&lt;p>[6]每种&amp;quot;管理风格&amp;quot;也各有利弊，这也是JVM发展历程中可以仔细学习的技术点，笔者在后续文章中再来探讨&lt;/p>
&lt;/blockquote>
&lt;h1 id="0x03-小结">0x03 小结&lt;/h1>
&lt;p>我们从一道面试题开始，通过8个问题看到了类加载机制的全貌。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">加载什么-&amp;gt;加载得到了什么-&amp;gt;从哪里加载-&amp;gt;加载到哪里去-&amp;gt;何时加载-&amp;gt;加载流程有几步-&amp;gt;加载流程如何实现-&amp;gt;类加载器的约束
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>本文篇幅有限，还留下了一些重要、有趣的细节，未来笔者还会继续展开&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">字节码描述的信息
JVM能认识的数据结构
方法区的结构
加载流程每一步存在一些JVM实现的细节
破坏双亲委派模型
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，笔者还想谈谈&amp;quot;理解优于记忆&amp;quot;的个人观点：深入理解JVM的原理对于实战的意义就是&amp;quot;先验知识&amp;rdquo;，是&amp;quot;性能调优、内存泄露、OSGI&amp;quot;等疑难杂症、高级框架的&amp;quot;基础&amp;rdquo;，如果能看到这类面试题背后的Why、What、How，您就获得了探寻计算机秘境的不二法门。&lt;/p></description></item><item><title>【宏观】从Java概念图理解Java体系</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3java%E6%A6%82%E5%BF%B5%E5%9B%BE/</link><pubDate>Thu, 05 Aug 2021 08:05:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3java%E6%A6%82%E5%BF%B5%E5%9B%BE/</guid><description>&lt;p>Java历经多年发展，知识体系庞大且复杂，包含大量的概念、技术点、原理等。&lt;/p>
&lt;p>即使从事多年Java开发，依然不敢很肯定完全吃透了Java。&lt;/p>
&lt;p>仿佛在知识的海洋中游泳，游了很久也看不到边际。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603115307805.png" alt="image-20210603115307805">&lt;/p>
&lt;p>怎样避免这种困境，提高Java的学习效率呢？&lt;/p>
&lt;p>笔者认为最好的方法是掌握Java体系的全貌，进而在实战中有计划、有针对性的迭代式学习。&lt;/p>
&lt;h1 id="1从java概念图理解java体系">1.从Java概念图理解Java体系&lt;/h1>
&lt;p>在《Java Platform Standard Edition 8 Documentation》中，列举了一张图——&amp;ldquo;Java Conceptual Diagram&amp;rdquo;——即Java概念图。&lt;/p>
&lt;p>虽然这张概念图不能代表Java体系的全部，但是这张概念图为我们提供了两个重要信息：&lt;/p>
&lt;ul>
&lt;li>Java SE的产品构成。&lt;/li>
&lt;li>各个产品的关系。&lt;/li>
&lt;li>产品包含了哪些组件。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603120446121.png" alt="image-20210603120446121">&lt;/p>
&lt;h2 id="11javase的产品构成">1.1.JavaSE的产品构成&lt;/h2>
&lt;p>在文档的开篇：&lt;/p>
&lt;blockquote>
&lt;p>Oracle has two products that implement Java Platform Standard Edition (Java SE) 8: Java SE Development Kit (JDK) 8 and Java SE Runtime Environment (JRE) 8.&lt;/p>
&lt;/blockquote>
&lt;p>Oracle告诉我们：&lt;/p>
&lt;blockquote>
&lt;p>Java SE 8 = 产品1(JDK 8) + 产品2(JRE 8)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Java SE 8，全称Java Platform Standard Edition (Java SE) 8&lt;/p>
&lt;/li>
&lt;li>
&lt;p>产品1：JDK 8，全称 Java SE Development Kit (JDK) 8&lt;/p>
&lt;/li>
&lt;li>
&lt;p>产品2：JRE8，全称 Java SE Runtime Environment (JRE) 8&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="12jdk8与jre8的关系">1.2.JDK8与JRE8的关系&lt;/h2>
&lt;p>在文档的Section2：&lt;/p>
&lt;blockquote>
&lt;p>JDK 8 is a superset of JRE 8, and contains everything that is in JRE 8, plus tools such as the compilers and debuggers necessary for developing applets and applications. JRE 8 provides the libraries, the Java Virtual Machine (JVM), and other components to run applets and applications written in the Java programming language. Note that the JRE includes components not required by the Java SE specification, including both standard and non-standard Java components.&lt;/p>
&lt;/blockquote>
&lt;p>我们可以知道：&lt;/p>
&lt;blockquote>
&lt;p>JDK 8 是 JRE 8 的超集&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>JDK8：除了包含 JRE 8，JDK8额外还有开发小程序和应用程序所需的编译器和调试器等工具。&lt;/li>
&lt;li>JRE 8：提供了库、Java 虚拟机 (JVM) 和其他组件来运行用 Java 编程语言编写的小程序和应用程序。JRE 包括了Java SE 规范不需要的组件，包括标准和非标准 Java 组件。&lt;/li>
&lt;/ul>
&lt;h1 id="2java-language">2.Java Language&lt;/h1>
&lt;p>在Java的概念架构中，第一个组件是&amp;quot;Java Language&amp;rdquo;，这个组件包含了Java的语言语法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603144339225.png" alt="image-20210603144339225">&lt;/p>
&lt;p>那么，我们应该如何学习这个组件呢？&lt;/p>
&lt;h2 id="21了解java各版本的新特性列表">2.1.了解Java各版本的新特性列表&lt;/h2>
&lt;p>这是一件非常重要的事，通过新特性，可以把握Java语言以及编程语言的发展趋势。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603145513209.png" alt="image-20210603145513209">&lt;/p>
&lt;h2 id="22浅尝辄止java-language-specification">2.2.浅尝辄止《Java Language Specification》&lt;/h2>
&lt;p>《Java Language Specification》——Java语言规范。这份文档像一本工具书，刚开始更适合&amp;quot;浅尝辄止&amp;rdquo;。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603150036175.png" alt="image-20210603150036175">&lt;/p>
&lt;p>从这份规范的作者，我们就可以知道《Java Language Specification》的分量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603150736346.png" alt="image-20210603150736346">&lt;/p>
&lt;p>《Java Language Specification》讲述的内容，可以概括为如下8点：&lt;/p>
&lt;h3 id="1语言的设计思想">(1)语言的设计思想&lt;/h3>
&lt;p>规范的开篇讲解了Java编程语言的语言风格、词法结构、句法、语法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603151646129.png" alt="image-20210603151646129">&lt;/p>
&lt;p>每种编程语言都要遵循一种套路，编译原理就是这种套路的高度抽象，有兴趣更加深入地理解《Java Language Specification》上述章节中的一些概念，可以阅读&lt;code>龙书&lt;/code>和&lt;code>虎书&lt;/code>这两部经典著作：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603154258626.png" alt="image-20210603154258626">&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603154332760.png" alt="image-20210603154332760">&lt;/p>
&lt;h3 id="2变量">(2)变量&lt;/h3>
&lt;p>Java语言规范中，将数据类型、变量、类型擦除等放在一起讲的，这是站在&amp;quot;编译原理&amp;quot;的视角来阐述的。&lt;/p>
&lt;p>作为编程语言的学习者和使用者，可以先了解Java这种语言如何声明与初始化。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603152148650.png" alt="image-20210603152148650">&lt;/p>
&lt;h3 id="3数据类型">(3)数据类型&lt;/h3>
&lt;p>这部分讲述了Java提供的基础数据类型、包装类型，重点阐述了数据类型转换、拆箱装箱等。&lt;/p>
&lt;p>这部分是实战中最常用的语法知识。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603153325400.png" alt="image-20210603153325400">&lt;/p>
&lt;h3 id="4表达式">(4)表达式&lt;/h3>
&lt;p>这部分讲述了Java的表达式、运算优先级等语法知识，这也是一种编程语言的基础语法设施。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603153403473.png" alt="image-20210603153403473">&lt;/p>
&lt;h3 id="5控制语句">(5)控制语句&lt;/h3>
&lt;p>在14章中，讲述了块、语句，控制语言也是编程语言语法的重要基础设施之一。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603153426618.png" alt="image-20210603153426618">&lt;/p>
&lt;h3 id="6方法面向对象">(6)方法、面向对象&lt;/h3>
&lt;p>在Java语言规范的第8/9章中，阐述了类、接口相关的语法。&lt;/p>
&lt;p>这些语法知识属于面向对象的编程语言的重中之重。&lt;/p>
&lt;p>第13章，还阐述了类、接口的语法演进。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603153521546.png" alt="image-20210603153521546">&lt;/p>
&lt;h3 id="7异常处理">(7)异常处理&lt;/h3>
&lt;p>异常有哪些种类？如何处理异常？异常体系也是一种编程语言的基础设施。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603153533675.png" alt="image-20210603153533675">&lt;/p>
&lt;h3 id="8代码组织方式package">(8)代码组织方式(package)&lt;/h3>
&lt;p>在Java 8中，包是相对比较好理解和掌握的语言语法，也是编程语言的基础设施。&lt;/p>
&lt;blockquote>
&lt;p>在模块化的激烈斗争中，Java 11支持了模块化特性，模块化特性在Java 11中是重要的学习内容。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603153610292.png" alt="image-20210603153610292">&lt;/p>
&lt;h2 id="23反复探索java-language-specification">2.3.反复探索《Java Language Specification》&lt;/h2>
&lt;p>《Java语言规范》作为一门编程语言的规范，词句必然是简洁精炼、高屋建瓴、高度抽象的。&lt;/p>
&lt;p>比如在讲解类型推断的部分，《Java语言规范》采用了接近数学公式的抽象逻辑表达，严谨、逻辑性极强。&lt;/p>
&lt;p>反复阅读这种思维模式，非常有利于提升我们的抽象能力和逻辑能力。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603163351690.png" alt="image-20210603163351690">&lt;/p>
&lt;p>我们可以把《Java编程规范》当做一本工具书。&lt;/p>
&lt;p>当实战中踩到某个语法陷阱时，回过头再来翻阅《Java语言规范》是一种不错的学习方法。&lt;/p>
&lt;p>每当带着实战中的教训和经验，重读规范中的语句，就会理解其中的隐喻和背后的原因。&lt;/p>
&lt;p>这有点像佛教徒学习《金刚经》的修行过程，刚开始看山是山，而后经历看山不是山、看山又是山的过程。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603163049574.png" alt="image-20210603163049574">&lt;/p>
&lt;h1 id="3libraries">3.Libraries&lt;/h1>
&lt;p>Java概念架构中第二大组件就是语言本身自带的类库，《Java语言规范》将这些类库分为了3大类：&lt;/p>
&lt;ul>
&lt;li>Lang and Util Packages&lt;/li>
&lt;li>Other Base Libraries&lt;/li>
&lt;li>Integration Libraries&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明1：User Interface Toolkits属于使用Java进行客户端开发的定向场景，所以本文不展开描述&lt;/p>
&lt;p>说明2：Deployment属于没落和抛弃的特性，本文不展开描述&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603163604627.png" alt="image-20210603163604627">&lt;/p>
&lt;p>按照这样的划分方式，还是很难直奔主题地抓住Java提供的类库重点，我们可以进行另一种分类：&lt;/p>
&lt;ul>
&lt;li>核心类库：基于Java Language的语法特性，实现的类库。&lt;/li>
&lt;li>扩展类库：基于核心类库实现的类库，这种类库用来解决实战中的某种应用场景。&lt;/li>
&lt;/ul>
&lt;h2 id="31核心类库">3.1.核心类库&lt;/h2>
&lt;p>核心类库主要包括：集合、多线程、反射&lt;/p>
&lt;p>集合、多线程、反射，也促进了Java体系中，产生了各种有趣的类库、模块、中间件。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603170428978.png" alt="image-20210603170428978">&lt;/p>
&lt;p>其中，&lt;code>Collections&lt;/code>官方文档的逻辑脉络，比较好地可以指导我们高效学习Java类库。(以List为例)&lt;/p>
&lt;ul>
&lt;li>首先，官方文档讲述了集合体系的宏观结构，这个是掌握好集合的第一步。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603171247671.png" alt="image-20210603171247671">&lt;/p>
&lt;ul>
&lt;li>然后，文档中讲解了List操作的几大类场景，以这些场景作为线索，我们可以去查阅List中对应的API。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603172058619.png" alt="image-20210603172058619">&lt;/p>
&lt;ul>
&lt;li>最后，文档描述了一下List的API的算法实现。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>理解API的算法实现也是一件非常重要的事情：只有理解了API的实现采用了哪种经典算法，才能更好地选择合适的API解决合适的实战问题。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603172416586.png" alt="image-20210603172416586">&lt;/p>
&lt;h2 id="32扩展类库">3.2.扩展类库&lt;/h2>
&lt;p>扩展类库主要包括：IO编程、序列化、正则表达式、数据库、网络编程。&lt;/p>
&lt;p>这些类库的API很多，短时间的集中学习也不太可能熟练掌握。&lt;/p>
&lt;p>笔者的经验是先了解这些类库的原理、能做哪些事情，然后在实战中使用这些API。&lt;/p>
&lt;p>NIO就是一个很好的例子，我们可以理解一些原理性的知识：&lt;/p>
&lt;ul>
&lt;li>BIO、NIO、AIO是什么&lt;/li>
&lt;li>NIO中的Buffer、Channel、Selector是什么&lt;/li>
&lt;li>零拷贝&lt;/li>
&lt;/ul>
&lt;p>等到实战中需要用到NIO的时候，再查阅NIO的类库API。&lt;/p>
&lt;h1 id="4java-virtual-machine">4.Java Virtual Machine&lt;/h1>
&lt;p>Java虚拟机是整个Java体系的基石，也是Java概念架构中最难突破的第三大组件。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603173309154.png" alt="image-20210603173309154">&lt;/p>
&lt;p>JVM本身就是一个庞大的技术体系：&lt;/p>
&lt;ul>
&lt;li>字节码&lt;/li>
&lt;li>类加载子系统&lt;/li>
&lt;li>运行时数据区&lt;/li>
&lt;li>垃圾回收算法和垃圾回收器&lt;/li>
&lt;li>JIT&lt;/li>
&lt;/ul>
&lt;p>所以，JVM是一个长期、反复的学习过程，随着对JVM的理解加深，我们再次回顾&lt;code>Java Language&lt;/code>、&lt;code>Libraries&lt;/code>，会看到语法特性、类库的在虚拟机层面的底层实现，甚至到操作系统的底层实现。&lt;/p>
&lt;h1 id="5tools--tool-apis">5.Tools &amp;amp; Tool APIs&lt;/h1>
&lt;p>Java概念架构中第四大组件就是工具以及工具API。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E5%AE%8F%E8%A7%82%E3%80%91%E7%90%86%E8%A7%A3Java%E6%A6%82%E5%BF%B5%E5%9B%BE/image-20210603174538915.png" alt="image-20210603174538915">&lt;/p>
&lt;p>从工具形态看，Java的工具包括：&lt;/p>
&lt;ul>
&lt;li>命令行工具&lt;/li>
&lt;li>GUI工具&lt;/li>
&lt;/ul>
&lt;p>从应用场景看，Java的工具包括：&lt;/p>
&lt;ul>
&lt;li>编译&lt;/li>
&lt;li>监控&lt;/li>
&lt;li>辅助(例如：javadoc)&lt;/li>
&lt;/ul>
&lt;p>无论怎样分类，怎样才算掌握了这种工具呢？&lt;/p>
&lt;p>笔者曾经陷入过2种误区：&lt;/p>
&lt;ul>
&lt;li>误区1：刚开始，觉得工具本身不是很关键的技术点，等到用的时候再查Java的工具手册就好了。结果等到真的查文档的时候，才发现怎么有这么多参数、这么多概念要理解？真是&amp;quot;书到用时方恨少&amp;rdquo;。&lt;/li>
&lt;li>误区2：经历了误区1的伤，很容易陷入另一个极端——那我就把工具手册逐字逐句的仔细阅读，把命令行参数都敲一遍。结果发现，即使背下来了命令行的参数也没用，因为工具最难掌握的是工具输出的报告，这些报告中包含着定位内存泄露、线程死锁的线索。为什么这些工具输出的报告难以看懂呢？因为这些工具的监视对象、作用对象是JVM，输出的报告中有大量的JVM的概念、术语。&lt;/li>
&lt;/ul>
&lt;p>所以，真正掌握这些Tools，强依赖对&lt;code>Java Virtual Machine&lt;/code>的深入理解。&lt;/p>
&lt;p>&lt;code>Tools &amp;amp; Tool APIs&lt;/code>中另一个重点/亮点就是APIs：&lt;/p>
&lt;ul>
&lt;li>在JDK1.4中，JVM提供了JVMPI，这是用来监控JVM信息的接口。&lt;/li>
&lt;li>在JDK1.4中，JVM提供了JVMDI，这是用来调试JVM的接口。(例如：IDE就是依赖这种接口实现了编译、调试等功能)&lt;/li>
&lt;li>在JDK5中，JVM提供了JVMTI，最终收编了JVMPI和JVMDI，提供了更高级的JVM接口。&lt;/li>
&lt;li>在JDK9中，JVM提供了JVMICI，可以用来扩展编译能力的接口。&lt;/li>
&lt;/ul>
&lt;p>比如：一个已经在运行的Java进程中，如何动态运行一段用户提交的java源码呢？就可以通过JVMTI实现。&lt;/p>
&lt;h1 id="6总结">6.总结&lt;/h1>
&lt;p>本文主要内容：&lt;/p>
&lt;ul>
&lt;li>了解Java体系的全貌，是一种高效学习Java的方法。&lt;/li>
&lt;li>Java的概念架构。&lt;/li>
&lt;li>Java概念架构中的组件1：Java Language&lt;/li>
&lt;li>Java概念架构中的组件2：Libraries&lt;/li>
&lt;li>Java概念架构中的组件3：Java Virtual Machine&lt;/li>
&lt;li>Java概念架构中的组件4：Tools &amp;amp; Tool APIs&lt;/li>
&lt;/ul>
&lt;h1 id="7参考文献">7.参考文献&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://docs.oracle.com/javase/8/docs/">https://docs.oracle.com/javase/8/docs/&lt;/a>&lt;/p>
&lt;/blockquote></description></item></channel></rss>