<!doctype html><html lang=zh-cn itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>【编译引擎】-9-阅读前端编译源码-词法分析-1 - 妙木山</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="猴王无敌"><meta name=description content="1.编译器的宏观过程 下图摘自《Compilers, Principles, Techniques, &amp;amp;Tools》(后文简称龙书)，描述了编译器工作时的宏观过程，每个方块表示编译"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.74.2"><link rel=canonical href=https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css integrity="sha256-s6iBPAbm14W+uiK/gmThdPoss6OWsi+bok4sAMGKr38=" media=screen crossorigin=anonymous><meta property="og:title" content="【编译引擎】-9-阅读前端编译源码-词法分析-1"><meta property="og:description" content="1.编译器的宏观过程 下图摘自《Compilers, Principles, Techniques, &Tools》(后文简称龙书)，描述了编译器工作时的宏观过程，每个方块表示编译"><meta property="og:type" content="article"><meta property="og:url" content="https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/"><meta property="article:published_time" content="2021-11-05T15:05:31+08:00"><meta property="article:modified_time" content="2021-11-05T15:05:31+08:00"><meta itemprop=name content="【编译引擎】-9-阅读前端编译源码-词法分析-1"><meta itemprop=description content="1.编译器的宏观过程 下图摘自《Compilers, Principles, Techniques, &Tools》(后文简称龙书)，描述了编译器工作时的宏观过程，每个方块表示编译"><meta itemprop=datePublished content="2021-11-05T15:05:31+08:00"><meta itemprop=dateModified content="2021-11-05T15:05:31+08:00"><meta itemprop=wordCount content="4419"><meta itemprop=keywords content="Java拾遗-JVM,"><meta name=twitter:card content="summary"><meta name=twitter:title content="【编译引擎】-9-阅读前端编译源码-词法分析-1"><meta name=twitter:description content="1.编译器的宏观过程 下图摘自《Compilers, Principles, Techniques, &Tools》(后文简称龙书)，描述了编译器工作时的宏观过程，每个方块表示编译"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>妙木山</a></div><div class=mobile-navbar-icon><span></span><span></span><span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://jherculesqz.github.io/>首页</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://jherculesqz.github.io/categories/>技术专栏</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://jherculesqz.github.io/tags/>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://jherculesqz.github.io/post/>全部文章</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://jherculesqz.github.io/about/>关于</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>妙木山</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://jherculesqz.github.io/>首页</a></li><li class=menu-item><a class=menu-item-link href=https://jherculesqz.github.io/categories/>技术专栏</a></li><li class=menu-item><a class=menu-item-link href=https://jherculesqz.github.io/tags/>Tags</a></li><li class=menu-item><a class=menu-item-link href=https://jherculesqz.github.io/post/>全部文章</a></li><li class=menu-item><a class=menu-item-link href=https://jherculesqz.github.io/about/>关于</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>【编译引擎】-9-阅读前端编译源码-词法分析-1</h1><div class=post-meta><time datetime=2021-11-05 class=post-time>2021-11-05</time><div class=post-category><a href=https://jherculesqz.github.io/categories/java%E6%8B%BE%E9%81%97/>Java拾遗</a></div><span class=more-meta>约 4419 字</span>
<span class=more-meta>预计阅读 9 分钟</span>
<span id=busuanzi_container_page_pv>| 阅读 <span id=busuanzi_value_page_pv></span></span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1编译器的宏观过程>1.编译器的宏观过程</a></li><li><a href=#2javac在宏观过程中的位置>2.javac在宏观过程中的位置</a></li><li><a href=#3词法分析的概念>3.词法分析的概念</a></li><li><a href=#4javac中对词素的具体实现-name-and-table>4.javac中对词素的具体实现-Name and Table</a><ul><li><a href=#41comsuntoolsjavacutilnamejava>4.1.com/sun/tools/javac/util/Name.java</a><ul><li><a href=#从属性看>从属性看</a></li><li><a href=#从方法看>从方法看</a></li></ul></li><li><a href=#42comsuntoolsjavacutilsharednametablejavanameimpl>4.2.com/sun/tools/javac/util/SharedNameTable.java#NameImpl</a><ul><li><a href=#从属性看-1>从属性看</a></li><li><a href=#从行为看>从行为看</a></li></ul></li><li><a href=#43comsuntoolsjavacutilnamesjava>4.3.com/sun/tools/javac/util/Names.java</a><ul><li><a href=#从属性看-2>从属性看</a></li><li><a href=#从行为看-1>从行为看</a></li></ul></li><li><a href=#44comsuntoolsjavacutilnamejavatable>4.4.com/sun/tools/javac/util/Name.java#Table</a><ul><li><a href=#从属性看-3>从属性看</a></li><li><a href=#从行为看-2>从行为看</a></li></ul></li><li><a href=#45comsuntoolsjavacutilsharednametablejava>4.5.com/sun/tools/javac/util/SharedNameTable.java</a><ul><li><a href=#从属性看-4>从属性看</a></li><li><a href=#从行为看-3>从行为看</a></li></ul></li></ul></li><li><a href=#5javac中对词法单元的具体实现-tokenkind-and-token>5.javac中对词法单元的具体实现-TokenKind and Token</a><ul><li><a href=#51comsuntoolsjavacparsertokensjavatokenkind>5.1.com/sun/tools/javac/parser/Tokens.java#TokenKind</a><ul><li><a href=#从属性看-5>从属性看</a></li></ul></li><li><a href=#52comsuntoolsjavacparsertokensjavatoken>5.2.com/sun/tools/javac/parser/Tokens.java#Token</a><ul><li><a href=#从属性看-6>从属性看</a></li><li><a href=#从行为看-4>从行为看</a></li></ul></li><li><a href=#53comsuntoolsjavacparsertokensjavatokens>5.3.com/sun/tools/javac/parser/Tokens.java#Tokens</a><ul><li><a href=#从属性看-7>从属性看</a></li><li><a href=#从行为看-5>从行为看</a></li></ul></li></ul></li><li><a href=#6一些感慨理论产品化>6.一些感慨：理论、产品化</a><ul><li><a href=#7下一步>7.下一步</a></li></ul></li><li><a href=#z参考>z.参考</a></li></ul></nav></div></div><div class=post-content><h1 id=1编译器的宏观过程>1.编译器的宏观过程</h1><p>下图摘自《Compilers, Principles, Techniques, &Tools》(后文简称<strong>龙书</strong>)，描述了编译器工作时的宏观过程，每个方块表示编译器内部的一个"模块&rdquo;，每个箭头表示该模块的"输入"与"输出&rdquo;：</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105093625343.png alt=image-20211105093625343></p><p>下图摘自《现代编译原理-C语言描述》(后文简称<strong>虎书</strong>)，进一步细化了编译器的宏观流程：</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105093134007.png alt=image-20211105093134007></p><p>上述环节复杂且技术术语繁多，我们可以结合JVM的特点，以及即将剖析的javac源码，做了部分抽象与精简：</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105094818994.png alt=image-20211105094818994></p><p>从上图看，笔者做了2个抽象：</p><ul><li><strong>简化步骤</strong>：将涉及<code>优化</code>、<code>分析</code>的环节简化为<code>代码优化</code>。</li><li><strong>步骤分组</strong>：将6个步骤分为<code>前端编译</code>和<code>后端编译</code>。</li></ul><p>简化步骤比较好理解，重点看看对步骤的分组——在龙书中，对<code>前端编译(frontend)</code>和<code>后端编译(backend)</code>做了定义：</p><blockquote><p>分析部分的环节被称作<code>前端编译(frontend)</code>，综合部分的环节被称作<code>后端编译(backend)</code>。</p></blockquote><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105101708866.png alt=image-20211105101708866></p><p>怎么理解<code>分析部分</code>和<code>综合部分</code>呢？站在JVM的角度看：</p><ul><li><strong>分析部分</strong>：从java源代码生成字节码的过程就属于分析部分，即对<code>源码</code>进行分析，最终分解为多个组成元素的过程。</li><li><strong>综合部分</strong>：对JVM正在执行的字节码进行JIT就属于综合部分，即从C1、C2等层次进行优化，最终生成CPU可以执行的机器码。</li></ul><p>在很多现代编译器中，不仅和JVM一样将编译过程分为前后端，并且一个编译器还可能包含多个<strong>前端编译器(frontend)<strong>和多个</strong>后端编译器(backend)</strong>，用来应对不同的应用场景。</p><h1 id=2javac在宏观过程中的位置>2.javac在宏观过程中的位置</h1><p>回顾了编译器的宏观流程，javac本质上属于<strong>前端编译器</strong>。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105100413500.png alt=image-20211105100413500></p><p>从javac的源码中，可以看到如下几个核心的package，分别覆盖了词法分析、语法分析和语义分析。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105100722357.png alt=image-20211105100722357></p><h1 id=3词法分析的概念>3.词法分析的概念</h1><p>我们通过解读龙书中这段话，来理解一下<code>词法分析</code>中的几个关键概念：</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105105314706.png alt=image-20211105105314706></p><p><code>词法分析(Lexical Analysis)</code>：将源代码字符流拆解成一个个的子元素，每个子元素叫做<code>词素(lexeme)</code>，进一步将词素转换为<code>词法单元(Token)</code>。</p><ul><li><p>说明1：1个源代码文件会包含N个<code>词素</code>，每个词素会转换为1个<code>Token</code>。</p></li><li><p>说明2：词法单元最终会存储到<code>符号表(Symbol Table)</code>中。</p></li></ul><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105110450245.png alt=image-20211105110450245></p><p>举一个具体的例子(代码片段原子龙书)：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=n>position</span> <span class=o>=</span> <span class=n>initial</span> <span class=o>+</span> <span class=n>rate</span> <span class=o>*</span> <span class=n>60</span>
</code></pre></td></tr></table></div></div><p>在词法分析过程中：</p><ul><li><p>position被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;identifier, 1></strong>。</p><ul><li>其中，identifier后文简写为id，1是该token在<code>符号表</code>中的位置。</li></ul></li><li><p>=被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;assign(=)></strong>。</p><ul><li>其中，=是一个赋值运算符，因此它对应的<code>词法单元(Token)</code>没有<code>attribute-value</code>。</li></ul></li><li><p>initial被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;identifier, 2></strong>。</p></li><li><p>+被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;assign(+)></strong>。</p></li><li><p>rate被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;identifier, 3></strong>。</p></li><li><p>*被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;assign(*)></strong>。</p></li><li><p>60被提取为1个<code>词素(lexeme)</code>，该词素被映射为1个<code>词法单元(Token)</code>——<strong>&lt;number, 4></strong>。</p></li></ul><p>最终，词法分析输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=o>&lt;</span><span class=n>identifier</span><span class=o>,</span><span class=n>1</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>assign</span><span class=o>(=)&gt;</span> <span class=o>&lt;</span><span class=n>identifier</span><span class=o>,</span><span class=n>2</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>assign</span><span class=o>(+)&gt;</span> <span class=o>&lt;</span><span class=n>identifier</span><span class=o>,</span><span class=n>3</span><span class=o>&gt;</span> <span class=o>&lt;</span><span class=n>assign</span><span class=o>(*)&gt;</span> <span class=o>&lt;</span><span class=n>number</span><span class=o>,</span><span class=n>4</span><span class=o>&gt;</span>
</code></pre></td></tr></table></div></div><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105113030363.png alt=image-20211105113030363></p><h1 id=4javac中对词素的具体实现-name-and-table>4.javac中对词素的具体实现-Name and Table</h1><p>在javac的源码中，定义了Name和Table，基本可以与<code>词素(lexeme)</code>对应：</p><ul><li><code>com/sun/tools/javac/util/Name.java</code></li><li><code>com/sun/tools/javac/util/SharedNameTable.java#NameImpl</code></li><li><code>com/sun/tools/javac/util/Names.java</code></li><li><code>com/sun/tools/javac/util/Name.java#Table</code></li><li><code>com/sun/tools/javac/util/SharedNameTable.java</code></li></ul><h2 id=41comsuntoolsjavacutilnamejava>4.1.com/sun/tools/javac/util/Name.java</h2><h3 id=从属性看>从属性看</h3><p>Name对象的本质是将源代码中的单词、符号分词了，每个分词就是一个Name对象。</p><p>有2个关键点需要注意：</p><ul><li>源代码字符流在javac是中是以<code>byte[]</code>存储的，所以Name对象包含了1个byteArray属性，该属性存储了当前Name对象对应的源代码子字符流。</li><li>相同<code>内容</code>的分词是<strong>同一个Name对象</strong>。</li></ul><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105114107760.png alt=image-20211105114107760></p><h3 id=从方法看>从方法看</h3><p>Name对象提供了对Name对象本身、Name对象之间的各种操作。</p><p>有1个关键点需要注意：</p><ul><li>Table对象将源代码字符流转换成了byte数组，为了提升性能，实现了<code>输入缓冲</code>和<code>哨兵标记</code>(详见龙书，后文解读<code>JavaCompiler#readSource方法</code>也会展开)。因此，Name对象中提供了诸如<code>getByteArray()</code>、<code>getByteAt()</code>等方法，从该Name对象所属的Table对象中反查对应的源代码字符流。</li></ul><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105114821297.png alt=image-20211105114821297></p><h2 id=42comsuntoolsjavacutilsharednametablejavanameimpl>4.2.com/sun/tools/javac/util/SharedNameTable.java#NameImpl</h2><h3 id=从属性看-1>从属性看</h3><p><code>NameImpl</code>类是<code>SharedNameTable</code>类中的内部类。</p><blockquote><p>疑惑：笔者没有理解为什么要如此设计。</p></blockquote><p>其中，有1个关键点：</p><ul><li><code>NameImpl对象</code>中维护了<code>next</code>属性，这就要说到<code>Table对象</code>的实现——<code>Table对象</code>按照HashTable实现，HashTable的Key是每个<code>Name对象</code>的<code>hashCode</code>，Value是对应的<code>NameImpl对象</code>。当1个新的<code>NameImpl对象</code>准备加入到HashTable时，如果Key发生hash冲突时，就会将这个新的<code>NameImpl对象</code>加到这个Key对应的已经存在的<code>NameImpl对象</code>的next属性中，形成一个单链表。</li></ul><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105115710065.png alt=image-20211105115710065></p><h3 id=从行为看>从行为看</h3><p>从行为上看，只是具体实现了Name基类的<code>getByteXxx方法</code>。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105141543612.png alt=image-20211105141543612></p><h2 id=43comsuntoolsjavacutilnamesjava>4.3.com/sun/tools/javac/util/Names.java</h2><h3 id=从属性看-2>从属性看</h3><p><code>Names对象</code>维护了N个<code>Name对象</code>，这些<code>Name对象</code>就是Java中定义的关键字、保留字。</p><p><code>Names对象</code>还维护了<code>Table对象</code>。</p><p>这里也有2个关键点：</p><ul><li>这些关键字、保留字类型的<code>Name对象</code>在<code>JavaCompiler</code>初始化时就会被创建出来。</li><li>当正式开始词法分析的时，在解读源代码字符流时，会去获取已经缓存的这些关键字、保留字<code>Name对象</code>，而不需要动态创建。</li></ul><p><img src=/Java拾遗/【编译引擎】-9-阅读前端编译源码-词法分析-1/image-20211105141807347.png alt=image-20211105141807347 style=zoom:50%></p><h3 id=从行为看-1>从行为看</h3><p><code>Names对象</code>提供了<code>fromXxx方法</code>，这些方法的实现会去调用<code>Table对象</code>的接口，这些方法更新<code>Table对象</code>(如：更新Hash表，解决Hash冲突等)，并返回<code>Name对象</code>。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105142706561.png alt=image-20211105142706561></p><h2 id=44comsuntoolsjavacutilnamejavatable>4.4.com/sun/tools/javac/util/Name.java#Table</h2><h3 id=从属性看-3>从属性看</h3><p><code>Table对象</code>维护了<code>Names对象</code>，前文已经描述了<code>Names对象</code>中维护了多个关键字、保留字的<code>Name对象</code>。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105151027295.png alt=image-20211105151027295></p><h3 id=从行为看-2>从行为看</h3><p>提供了给<code>Names对象</code>调用的<code>fromXxx方法</code>，这些方法更新<code>Table对象</code>(如：更新Hash表，解决Hash冲突等)，并返回<code>Name对象</code>。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105151037438.png alt=image-20211105151037438></p><h2 id=45comsuntoolsjavacutilsharednametablejava>4.5.com/sun/tools/javac/util/SharedNameTable.java</h2><h3 id=从属性看-4>从属性看</h3><p><code>SharedNameTable</code>是<code>Table</code>的具体实现类。</p><p><code>SharedNameTable</code>对象维护了hashes属性，是Hash表的具体实现，其中<code>NameImpl[]</code>的数组索引是每个<code>NameImpl对象</code>的hashCode。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105151550397.png alt=image-20211105151550397></p><h3 id=从行为看-3>从行为看</h3><p>关键点还是Hash表的具体实现，具体以fromChars方法的代码注释：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Override</span>
<span class=kd>public</span> <span class=n>Name</span> <span class=nf>fromChars</span><span class=o>(</span><span class=kt>char</span><span class=o>[]</span> <span class=n>cs</span><span class=o>,</span> <span class=kt>int</span> <span class=n>start</span><span class=o>,</span> <span class=kt>int</span> <span class=n>len</span><span class=o>)</span> <span class=o>{</span>
	<span class=c1>//HCZ：获得bytes数组中下一个可用的位置
</span><span class=c1></span>	<span class=kt>int</span> <span class=n>nc</span> <span class=o>=</span> <span class=k>this</span><span class=o>.</span><span class=na>nc</span><span class=o>;</span>
	<span class=c1>//HCZ：对bytes数组进行扩容(如果有必要)
</span><span class=c1></span>	<span class=kt>byte</span><span class=o>[]</span> <span class=n>bytes</span> <span class=o>=</span> <span class=k>this</span><span class=o>.</span><span class=na>bytes</span> <span class=o>=</span> <span class=n>ArrayUtils</span><span class=o>.</span><span class=na>ensureCapacity</span><span class=o>(</span><span class=k>this</span><span class=o>.</span><span class=na>bytes</span><span class=o>,</span> <span class=n>nc</span> <span class=o>+</span> <span class=n>len</span> <span class=o>*</span> <span class=n>3</span><span class=o>);</span>
	<span class=c1>//HCZ：将char数组转换为byte数组，并且写入到bytes属性中，返回bytes属性中最后的index，得到byte数组的长度。
</span><span class=c1></span>	<span class=kt>int</span> <span class=n>nbytes</span> <span class=o>=</span> <span class=n>Convert</span><span class=o>.</span><span class=na>chars2utf</span><span class=o>(</span><span class=n>cs</span><span class=o>,</span> <span class=n>start</span><span class=o>,</span> <span class=n>bytes</span><span class=o>,</span> <span class=n>nc</span><span class=o>,</span> <span class=n>len</span><span class=o>)</span> <span class=o>-</span> <span class=n>nc</span><span class=o>;</span>
	<span class=c1>//HCZ：根据bytes数组中下一个可用位置(也就是新写入的char数组的startIndex)、根据新写入的char数组转换后的byte数组长度，计算得到hashCode。
</span><span class=c1></span>	<span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=n>hashValue</span><span class=o>(</span><span class=n>bytes</span><span class=o>,</span> <span class=n>nc</span><span class=o>,</span> <span class=n>nbytes</span><span class=o>)</span> <span class=o>&amp;</span> <span class=n>hashMask</span><span class=o>;</span>
	<span class=c1>//HCZ：从hashes数组中(就是NameImpl对象数组)，获得与新计算出来的hashCode相同的冲突NameImpl对象。
</span><span class=c1></span>	<span class=n>NameImpl</span> <span class=n>n</span> <span class=o>=</span> <span class=n>hashes</span><span class=o>[</span><span class=n>h</span><span class=o>];</span>
	<span class=c1>//HCZ：如果能找到冲突的NameImpl对象，说明hashCode冲突了，就将NameImpl对象的next指向新的NameImpl对象，形成单链表。
</span><span class=c1></span>	<span class=k>while</span> <span class=o>(</span><span class=n>n</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>&amp;&amp;</span>
			<span class=o>(</span><span class=n>n</span><span class=o>.</span><span class=na>getByteLength</span><span class=o>()</span> <span class=o>!=</span> <span class=n>nbytes</span> <span class=o>||</span>
			<span class=o>!</span><span class=n>equals</span><span class=o>(</span><span class=n>bytes</span><span class=o>,</span> <span class=n>n</span><span class=o>.</span><span class=na>index</span><span class=o>,</span> <span class=n>bytes</span><span class=o>,</span> <span class=n>nc</span><span class=o>,</span> <span class=n>nbytes</span><span class=o>)))</span> <span class=o>{</span>
		<span class=n>n</span> <span class=o>=</span> <span class=n>n</span><span class=o>.</span><span class=na>next</span><span class=o>;</span>
	<span class=o>}</span>
	<span class=c1>//HCZ：如果没有找到冲突的NameImpl对象，就创建新的NameImpl对象，并记录到hashes属性。
</span><span class=c1></span>	<span class=k>if</span> <span class=o>(</span><span class=n>n</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
		<span class=n>n</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NameImpl</span><span class=o>(</span><span class=k>this</span><span class=o>);</span>
		<span class=n>n</span><span class=o>.</span><span class=na>index</span> <span class=o>=</span> <span class=n>nc</span><span class=o>;</span>
		<span class=n>n</span><span class=o>.</span><span class=na>length</span> <span class=o>=</span> <span class=n>nbytes</span><span class=o>;</span>
		<span class=n>n</span><span class=o>.</span><span class=na>next</span> <span class=o>=</span> <span class=n>hashes</span><span class=o>[</span><span class=n>h</span><span class=o>];</span>
		<span class=n>hashes</span><span class=o>[</span><span class=n>h</span><span class=o>]</span> <span class=o>=</span> <span class=n>n</span><span class=o>;</span>
		<span class=k>this</span><span class=o>.</span><span class=na>nc</span> <span class=o>=</span> <span class=n>nc</span> <span class=o>+</span> <span class=n>nbytes</span><span class=o>;</span>
		<span class=k>if</span> <span class=o>(</span><span class=n>nbytes</span> <span class=o>==</span> <span class=n>0</span><span class=o>)</span> <span class=o>{</span>
			<span class=k>this</span><span class=o>.</span><span class=na>nc</span><span class=o>++;</span>
		<span class=o>}</span>
	<span class=o>}</span>
	<span class=k>return</span> <span class=n>n</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h1 id=5javac中对词法单元的具体实现-tokenkind-and-token>5.javac中对词法单元的具体实现-TokenKind and Token</h1><p>在javac的源码中，定义了TokenKind和Token，基本可以与<code>词法单元(Token)</code>对应：</p><ul><li><code>com/sun/tools/javac/parser/Tokens.java#TokenKind</code></li><li><code>com/sun/tools/javac/parser/Tokens.java#Token</code></li><li><code>com/sun/tools/javac/parser/Tokens.java#Tokens</code></li></ul><h2 id=51comsuntoolsjavacparsertokensjavatokenkind>5.1.com/sun/tools/javac/parser/Tokens.java#TokenKind</h2><h3 id=从属性看-5>从属性看</h3><p>TokenKind是一个枚举类，定义了Java中的关键字、保留字、运算符等。</p><p>每个枚举值对应<code>词法单元(Token)</code>的<code>token-name</code>。</p><p><img src=/Java拾遗/【编译引擎】-9-阅读前端编译源码-词法分析-1/image-20211105152645860.png alt=image-20211105152645860 style=zoom:50%></p><h2 id=52comsuntoolsjavacparsertokensjavatoken>5.2.com/sun/tools/javac/parser/Tokens.java#Token</h2><h3 id=从属性看-6>从属性看</h3><p>从<code>3.词法分析的概念</code>中可以知道，<code>词法单元(Token)</code>有多种类型，如：标识符Token、运算符Token、字面量Token等。</p><p>因此，javac实现了如下Token继承关系：</p><p>其中，Token的各个子类除了有kind属性外，还有各自特有的属性。</p><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105154224005.png alt=image-20211105154224005></p><h3 id=从行为看-4>从行为看</h3><p>Token对象提供了各种get方法，表达Token对象的<code>&lt;token-name，attribute-value></code>。</p><p><img src=/Java拾遗/【编译引擎】-9-阅读前端编译源码-词法分析-1/image-20211105155258304.png alt=image-20211105155258304 style=zoom:50%></p><h2 id=53comsuntoolsjavacparsertokensjavatokens>5.3.com/sun/tools/javac/parser/Tokens.java#Tokens</h2><h3 id=从属性看-7>从属性看</h3><p><code>Tokens对象</code>维护了2个关键的属性：</p><ul><li><code>key</code>：数组索引是Name对象在Hash表中的index，value是TokenKind对象。</li><li><code>tokenName</code>：数组索引是TokenKind对应枚举值的序号，value是Name对象。</li></ul><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105155218544.png alt=image-20211105155218544></p><h3 id=从行为看-5>从行为看</h3><p>从<code>Tokens对象</code>提供的方法看，有2个关键点：</p><ul><li><strong>调用链1</strong>：创建<code>JavaCompiler对象</code>时，会触发<code>Names</code>的构造函数，<ul><li>进而触发<code>SharedNameTable</code>的构造函数。</li><li>进而触发<code>NameImpl</code>的构造函数，继而触发了<code>Names</code>对象的初始化。</li></ul></li><li><strong>调用链2</strong>：创建<code>ParserFactory</code>对象时，会触发<code>Tokens</code>的构造函数，<ul><li>进而触发了<code>Tokens</code>的构造函数，继而在<code>Tokens</code>对象中建立了<code>Name</code>到<code>Token</code>、<code>Token</code>到<code>Name</code>的双向映射。</li></ul></li></ul><p><img src=/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-9-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90-1/image-20211105155228126.png alt=image-20211105155228126></p><h1 id=6一些感慨理论产品化>6.一些感慨：理论、产品化</h1><p>有一次讨论LLVM的时候，一位老前辈感慨过：老美的下一代在玩编译器，我们的下一代还在捣腾CRUD。</p><blockquote><p>感兴趣的读者，可以去搜索一下LLVM的作者在研究生阶段的论文以及他的职业经历。</p></blockquote><p>包括笔者引用的三本编译器领域圣经：<code>龙书、虎书、鲸书</code>以及其中我们现在还要反复咀嚼的编译理论，距今也有几十年多年的历史。</p><p>能够透彻理解JVM原理的程序猿并不多，真的阅读JVM源码的更少，这或许就是我们在技术上还需要弥补的巨大差距。</p><p>另外，通过阅读javac在词法分析部分的源码，我们就可以发现：</p><ul><li><strong>编译器理论</strong>是指导<strong>产品化的灵魂</strong>(如：词素、词法单元、有限状态机等)。</li><li><strong>产品化</strong>却<strong>在实践中</strong>会考虑更多因素(如：输入缓冲和哨兵标志、词素Hash表等)，<strong>高于编译器理论</strong>。</li></ul><h2 id=7下一步>7.下一步</h2><p>接下来，笔者会继续分析javac在词法分析环节，如何实现有限状态机。</p><h1 id=z参考>z.参考</h1><blockquote><p>龙书：《Compilers, Principles, Techniques, &Tools》Second Edition</p><p>虎书：《现代编译原理-C语言描述》</p></blockquote></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>猴王无敌</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2021-11-05</span></p><p class=copyright-item><span class=item-title>许可协议</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=/weixin.png>
<span>微信打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=/alipay.png>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=https://jherculesqz.github.io/tags/java%E6%8B%BE%E9%81%97-jvm/>Java拾遗-JVM</a></div><nav class=post-nav><a class=prev href=/post/java%E6%8B%BE%E9%81%97/%E7%BD%AE%E9%A1%B6java%E6%8B%BE%E9%81%97/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">【置顶】Java拾遗</span>
<span class="prev-text nav-mobile">上一篇</span></a>
<a class=next href=/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-8-%E9%98%85%E8%AF%BB%E5%89%8D%E7%AB%AF%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/><span class="next-text nav-default">【编译引擎】-8-阅读前端编译源码的准备工作</span>
<span class="prev-text nav-mobile">下一篇</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"/></svg></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:JHercules_qz@qq.com rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408 1361.641813S1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523L83.726336 1024H682.532949 753.579947 1348.948139L1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955C777.248 802.205449 742.347691 811.03081 718.063616 811.603883z"/></svg></a><a href=https://github.com/JHerculesqz rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=https://jherculesqz.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2021 -
2024
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>猴王无敌</span></span>
<span id=busuanzi_container>访客数/访问量：<span id=busuanzi_value_site_uv></span>/<span id=busuanzi_value_site_pv></span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script><script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script><script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script><script type=text/javascript src=/js/load-photoswipe.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script></body></html>