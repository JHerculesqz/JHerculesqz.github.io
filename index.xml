<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>妙木山</title><link>https://jherculesqz.github.io/</link><description>Recent content on 妙木山</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 05 Aug 2021 14:55:31 +0800</lastBuildDate><atom:link href="https://jherculesqz.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>关于</title><link>https://jherculesqz.github.io/about/</link><pubDate>Thu, 05 Aug 2021 13:01:37 +0800</pubDate><guid>https://jherculesqz.github.io/about/</guid><description>&lt;h1 id="关于博客">关于博客&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>独立&lt;/strong>：一直在写技术博客，从微信公众号、头条号、SegmentFault、掘金、简书一路折腾过来，还是希望有一个自己独立的空间。&lt;/li>
&lt;li>&lt;strong>坚持&lt;/strong>：随着年龄增长，逐渐欲说还休，还是文字更有韵味，希望自己能坚持写下去。&lt;/li>
&lt;li>&lt;strong>浪漫&lt;/strong>：按照&lt;a href="https://archiveprogram.github.com">Archive Program&lt;/a>计划的愿景，我的博客会在&amp;rdquo; GitHub北极代码库&amp;quot;中保存千年。想想1000年以后，我的后代们能读到我这个中二祖先的文字，还是一件挺浪漫的事儿。&lt;/li>
&lt;li>&lt;strong>感谢&lt;/strong>：感谢GitHub Pages、Hugo、Jane提供的技术支持。&lt;/li>
&lt;li>&lt;strong>妙木山&lt;/strong>：妙木山是修炼仙术的地方，作为火影的死忠粉，&amp;ldquo;妙木山&amp;quot;无比适合这个博客的定位——修炼、探索。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/about/MiaoMu.png" alt="MiaoMu">&lt;/p>
&lt;h1 id="关于我">关于我&lt;/h1>
&lt;ul>
&lt;li>&lt;strong>行业&lt;/strong>：软件行业16年，无法用语言表达对编程的喜爱——举个栗子吧：有段时间喜欢在酒吧里写代码，同去的小伙伴无聊地陌陌上约人，自我介绍就是&amp;quot;A+吧台，旁边有个写代码的沙雕&amp;rdquo;。&lt;/li>
&lt;li>&lt;strong>技术方向&lt;/strong>：近几年痴迷语言和编译器技术，还有点痴迷计算机图形学。
&lt;ul>
&lt;li>&lt;strong>编程语言&lt;/strong>：目前工作Java和JavaScript用的最多，但我最喜欢C#——PHP是最好的语言，行了吧！&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>哲学&lt;/strong>：不知何时，开始期待理解生命的意义。东一本西一本的书拿来乱翻，也没找到答案。不过，也不是全无收获——能模模糊糊地体会诗词的意境、能回味出毛选的奇妙、能敬畏金刚经的高深……继续求索吧……&lt;/li>
&lt;li>&lt;strong>兴趣&lt;/strong>：年轻的时候，喜欢轮滑、滑板、快乐肥仔水。现在，喜欢滑雪、乒乓球、茶(特指正山小种)。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/about/Me.png" alt="Me">&lt;/p></description></item><item><title>【编译引擎】-2-学习阅读Class文件结构(16进制版)-下</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8B/</link><pubDate>Thu, 05 Aug 2021 14:55:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8B/</guid><description>&lt;p>在《【编译引擎】学习阅读Class文件结构(16进制版)-上》、《【编译引擎】学习阅读Class文件结构(16进制版)-中》两篇文章中，笔者讲解了如何以16进制的方式，解读Demo2.java对应字节码的常量池、字段表、方法表。&lt;/p>
&lt;p>我们继续解读Demo2.class字节码的方法表的Code属性片段。&lt;/p>
&lt;h1 id="1复杂信息的树状表达属性树">1.复杂信息的树状表达：属性树&lt;/h1>
&lt;p>如果说前面两篇文章描述的信息相对简单，那么当我们需要用一种形式表达一个函数的实现就显得更加复杂了。&lt;/p>
&lt;p>我们逆向思考一下，假设我们就是JVM，JVM需要完成哪些&lt;strong>重要的任务&lt;/strong>：&lt;/p>
&lt;h2 id="11源代码转化为指令序列">1.1.源代码转化为指令序列&lt;/h2>
&lt;p>在编译阶段，JVM能够获得的信息形式是——&lt;strong>函数实现的源代码X&lt;/strong>&lt;/p>
&lt;p>而在运行阶段，JVM需要输出给CPU的信息形式是——&lt;strong>CPU能够理解并执行的CPU指令序列Z&lt;/strong>&lt;/p>
&lt;p>因此，JVM需要将&lt;strong>源代码X&lt;/strong>转换为&lt;strong>指令序列Z&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>Z = G(X)&lt;/p>
&lt;/blockquote>
&lt;p>为了实现&lt;strong>转换函数G&lt;/strong>，首先，在编译阶段，JVM将&lt;strong>源代码X&lt;/strong>转换为&lt;strong>JVM指令序列Y&lt;/strong>，即&lt;/p>
&lt;blockquote>
&lt;p>Y = F1(X)&lt;/p>
&lt;/blockquote>
&lt;p>然后，在运行阶段，JVM动态地将&lt;strong>JVM指令序列Y&lt;/strong>转换为&lt;strong>CPU指令序列Z&lt;/strong>，即&lt;/p>
&lt;blockquote>
&lt;p>Z = F2(Y)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/1.png" alt="image-20201213164014831">&lt;/p>
&lt;p>至此，我们可以得到一个结论：&lt;strong>JVM指令序列是表示函数实现源代码的重要信息之一&lt;/strong>。&lt;/p>
&lt;h2 id="12维护局部变量列表">1.2.维护局部变量列表&lt;/h2>
&lt;p>我们至少知道3个经验：&lt;/p>
&lt;blockquote>
&lt;p>如果函数内一条语句使用了前面已经定义过的局部变量，则该语句能获得此局部变量最新的值。&lt;/p>
&lt;p>如果函数内一条语句使用了一个局部变量，但局部变量没有定义，IDE就会出现语法错误。&lt;/p>
&lt;p>即使是一个空的函数实现，这个函数里面，IDE至少能联想出一个变量this。&lt;/p>
&lt;/blockquote>
&lt;p>通过这3个经验，我们知道JVM至少具备如下能力：&lt;/p>
&lt;blockquote>
&lt;p>函数内定义了哪些局部变量，这些局部变量最新的值是多少。&lt;/p>
&lt;p>这些局部变量的作用范围从哪里开始，到哪里结束。&lt;/p>
&lt;/blockquote>
&lt;p>JVM通过实现&lt;strong>局部变量表&lt;/strong>存储上述信息：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/2.png" alt="image-20201213165522458">&lt;/p>
&lt;p>因此，我们可以得到另一个结论：&lt;strong>局部变量表也是表示函数实现源代码的必要信息&lt;/strong>。&lt;/p>
&lt;h2 id="13源代码与jvm指令序列的映射关系">1.3.源代码与JVM指令序列的映射关系&lt;/h2>
&lt;p>从1.1可知，调试程序本质是调试运行时指令序列，我们必然需要知道调试的指令序列对应于源代码中的位置。&lt;/p>
&lt;p>JVM通过行号表存储了映射关系：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/3.png" alt="image-20201213210037072">&lt;/p>
&lt;p>同样的，我们得到另一个结论：&lt;strong>行号表也是表示函数实现源代码的必要信息&lt;/strong>。&lt;/p>
&lt;h2 id="14属性树">1.4.属性树&lt;/h2>
&lt;p>综合前述的分析，JVM需要定义一个&lt;strong>表达属性的树表结构&lt;/strong>才能表示一个函数的内部实现，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/4.png" alt="image-20201213225139342">&lt;/p>
&lt;p>&lt;strong>Code属性自身具有一些基础信息&lt;/strong>(例如：操作数栈最大深度)，Code属性还包含&lt;strong>子属性&lt;/strong>(例如：行号表子属性、局部变量表子属性)。&lt;/p>
&lt;p>这样，就形成了一个属性树。&lt;/p>
&lt;h2 id="15属性">1.5.属性&lt;/h2>
&lt;blockquote>
&lt;p>JVM：&lt;em>Attributes&lt;/em> are used in the &lt;code>ClassFile&lt;/code>, &lt;code>field_info&lt;/code>, &lt;code>method_info&lt;/code>, and &lt;code>Code_attribute&lt;/code> structures of the &lt;code>class&lt;/code> file format&lt;/p>
&lt;/blockquote>
&lt;p>JVM将Code抽象的称为&lt;strong>属性&lt;/strong>，将&lt;strong>行号表&lt;/strong>也抽象为&lt;strong>属性&lt;/strong>，将&lt;strong>局部变量表&lt;/strong>也抽象地称为&lt;strong>属性&lt;/strong>。在JVM中，还有其它更多的&lt;strong>属性&lt;/strong>。&lt;/p>
&lt;p>但无论哪种属性，JVM都采用了如下数据结构表示&lt;strong>属性的共性&lt;/strong>：&lt;/p>
&lt;p>2个字节是属性名在常量池中的索引。&lt;/p>
&lt;p>4个字节表示这个属性的字节码长度N。&lt;/p>
&lt;p>紧接着N个字节表示这个属性具体的字节码。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/5.png" alt="image-20201213230831717">&lt;/p>
&lt;p>深一步思考，又有一个问题：不同的属性应该有不同的数据结构，&lt;strong>JVM怎么区分表达属性的特有信息&lt;/strong>呢？&lt;/p>
&lt;p>JVM就是根据属性名来区分的不同类型的属性，&lt;strong>每种属性又有自己独有的数据结构&lt;/strong>，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/6.png" alt="image-20201213232241686">&lt;/p>
&lt;p>好，有了这些前置知识，我们接下来详细解读Code、LineNumberTable、LocalVariableTable属性。&lt;/p>
&lt;h1 id="2code属性">2.Code属性&lt;/h1>
&lt;h2 id="21code属性名">2.1.Code属性名&lt;/h2>
&lt;p>hello方法下挂的属性名索引=&lt;strong>00 0C&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/7.png" alt="image-20201213230043475">&lt;/p>
&lt;p>&lt;strong>00 0C=12&lt;/strong>，对应&lt;strong>第12个常量&lt;/strong>，即&lt;strong>Code属性&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/8.png" alt="image-20201214002838199">&lt;/p>
&lt;h2 id="22code属性字节码长度">2.2.Code属性字节码长度&lt;/h2>
&lt;p>hello方法下挂的Code属性长度=&lt;strong>00 00 00 47&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/9.png" alt="image-20201214002946890">&lt;/p>
&lt;p>说明Code属性占据的字节码长度为&lt;strong>00 00 00 47=71&lt;/strong>，如下图红框：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/10.png" alt="image-20201214003317799">&lt;/p>
&lt;h2 id="23code属性操作数栈最大长度">2.3.Code属性.操作数栈最大长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>Code&lt;/code> attribute is a variable-length attribute in the &lt;code>attributes&lt;/code> table of a &lt;code>method_info&lt;/code> structure . A &lt;code>Code&lt;/code> attribute contains the Java Virtual Machine instructions and auxiliary information for a method, including an instance initialization method or a class or interface initialization method&lt;/p>
&lt;/blockquote>
&lt;p>进一步，查阅JVM规范，Code属性的数据结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/11.png" alt="image-20201214090813324">&lt;/p>
&lt;p>从max_stack开始，2个字节表示操作数栈最大深度。&lt;/p>
&lt;p>&lt;strong>00 02 = 2&lt;/strong>，表示针对Demo2代码，&lt;strong>操作数栈的最大深度为2&lt;/strong>。&lt;/p>
&lt;p>另外，这里涉及到对虚拟机栈的理解，笔者将会在后续文章中展开。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/12.png" alt="image-20201214071931530">&lt;/p>
&lt;h2 id="24code属性局部变量表长度">2.4.Code属性.局部变量表长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>max_locals&lt;/code> item gives the number of local variables in the local variable array allocated upon invocation of this method&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/13.png" alt="image-20201214072317654">&lt;/p>
&lt;p>00 02 = 2，&lt;strong>局部变量表最大长度为2&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/14.png" alt="image-20201214072400159">&lt;/p>
&lt;h2 id="25code属性指令序列长度">2.5.Code属性.指令序列长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>code_length&lt;/code> item gives the number of bytes in the &lt;code>code&lt;/code> array for this method.&lt;/p>
&lt;/blockquote>
&lt;p>4个字节表示紧接着的有多少个字节存储JVM指令序列。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/15.png" alt="image-20201214072528544">&lt;/p>
&lt;p>&lt;strong>00 00 00 0B=11&lt;/strong>，表示Demo2的hello方法转化的JVM指令序列，需要11个字节存储。&lt;/p>
&lt;p>这就很神奇了，一段这样的代码，竟然被转换成了11个字节：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/16.png" alt="image-20201214073202146">&lt;/p>
&lt;h2 id="26code属性指令序列">2.6.Code属性.指令序列&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>code&lt;/code> array gives the actual bytes of Java Virtual Machine code that implement the method.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/17.png" alt="image-20201214073245663">&lt;/p>
&lt;p>下图是Demo2的hello方法转换后的JVM指令序列：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/18.png" alt="image-20201214073409407">&lt;/p>
&lt;p>根据JVM规范，笔者将16进制字节码人工翻译成JVM指令序列：&lt;/p>
&lt;p>&lt;strong>04 =&amp;gt; iconst_1&lt;/strong>，表示将1加载到虚拟机栈中。&lt;/p>
&lt;p>&lt;strong>3C =&amp;gt; istore_1&lt;/strong>，表示将上一步的数据存储到局部变量表的第1位。&lt;/p>
&lt;p>&lt;strong>B2 00 03 =&amp;gt; getstatic 3&lt;/strong>，表示调用第3个常量映射的&lt;strong>java.io.PrintStream&lt;/strong>类。&lt;/p>
&lt;p>&lt;strong>12 04 =&amp;gt; Idc 4&lt;/strong>，表示将第4个常量映射的**&amp;ldquo;hello world&amp;quot;字符串**加载到虚拟机栈中。&lt;/p>
&lt;p>&lt;strong>B6 00 05=&amp;gt;invokevirtual 5&lt;/strong>，表示调用第5个常量映射的&lt;strong>println&lt;/strong>方法。&lt;/p>
&lt;p>&lt;strong>B1=&amp;gt;return&lt;/strong>，表示此函数&lt;strong>执行完成后返回&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/19.png" alt="image-20201214095755437">&lt;/p>
&lt;p>我们对比一下Demo2的源代码：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/20.png" alt="image-20201214100012611">&lt;/p>
&lt;h1 id="3linenumbertable属性">3.LineNumberTable属性&lt;/h1>
&lt;h2 id="31linenumbertable属性名">3.1.LineNumberTable属性名&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节表示属性名。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/21.png" alt="image-20201214101143092">&lt;/p>
&lt;p>&lt;strong>00 0D=13&lt;/strong>，表示第13个常量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/22.png" alt="image-20201214103511715">&lt;/p>
&lt;p>根据常量池映射关系，&lt;strong>第13个常量&lt;/strong>表示&lt;strong>LineNumberTable&lt;/strong>字符串&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/23.png" alt="image-20201214103741137">&lt;/p>
&lt;h2 id="32linenumbertable属性字节码长度">3.2.LineNumberTable属性字节码长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_length&lt;/code> item indicates the length of the attribute, excluding the initial six bytes.&lt;/p>
&lt;/blockquote>
&lt;p>4个字节表示属性占用的字节码长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/24.png" alt="image-20201214101226009">&lt;/p>
&lt;p>&lt;strong>00 00 00 0E&lt;/strong>=14，表示行号表占据字节码14个字节长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/25.png" alt="image-20201214103837705">&lt;/p>
&lt;p>因此，行号表的字节码如下图红框所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/26.png" alt="image-20201214104013281">&lt;/p>
&lt;h2 id="33linenumbertable属性的行数据">3.3.LineNumberTable属性的行数据&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each entry in the &lt;code>line_number_table&lt;/code> array indicates that the line number in the original source file changes at a given point in the &lt;code>code&lt;/code> array. Each &lt;code>line_number_table&lt;/code> entry must contain the following two items:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>start_pc&lt;/p>
&lt;p>The value of the &lt;code>start_pc&lt;/code> item must indicate the index into the &lt;code>code&lt;/code> array at which the code for a new line in the original source file begins.The value of &lt;code>start_pc&lt;/code> must be less than the value of the &lt;code>code_length&lt;/code> item of the &lt;code>Code&lt;/code> attribute of which this &lt;code>LineNumberTable&lt;/code> is an attribute.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>line_number&lt;/p>
&lt;p>The value of the &lt;code>line_number&lt;/code> item must give the corresponding line number in the original source file.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>行号表分为两列，一列是&lt;strong>在JVM指令序列的索引(start_pc)&lt;/strong>，一列是&lt;strong>源代码的行号(line_number)&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/27.png" alt="image-20201214101431970">&lt;/p>
&lt;p>我们将前文解读的JVM指令序列、Demo2的hello方法的源代码，与行号表的字节码对比，可以看到：&lt;/p>
&lt;p>行号表第1行数据：表示JVM指令序列第0行与源代码第7行对应。&lt;/p>
&lt;p>行号表第2行数据：表示JVM指令序列第2行与源代码第8行对应。&lt;/p>
&lt;p>行号表第3行数据：表示JVM指令序列第10行与源代码第9行对应。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/28.png" alt="image-20201214102952547">&lt;/p>
&lt;h1 id="4localvariabletable属性">4.LocalVariableTable属性&lt;/h1>
&lt;h2 id="41localvariabletable属性名">4.1.LocalVariableTable属性名&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节表示属性名。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/29.png" alt="image-20201214105409665">&lt;/p>
&lt;p>&lt;strong>00 0E=14&lt;/strong>，表示第14个常量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/30.png" alt="image-20201214105753233">&lt;/p>
&lt;p>根据常量池映射关系，&lt;strong>第14个常量&lt;/strong>表示&lt;strong>LocalVariableTable&lt;/strong>字符串。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/31.png" alt="image-20201214110018137">&lt;/p>
&lt;h2 id="42localvariabletable属性字节码长度">4.2.LocalVariableTable属性字节码长度&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attribute_length&lt;/code> item indicates the length of the attribute, excluding the initial six bytes.&lt;/p>
&lt;/blockquote>
&lt;p>4个字节表示属性占用的字节码长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/32.png" alt="image-20201214105443811">&lt;/p>
&lt;p>&lt;strong>00 00 00 16&lt;/strong>=22，表示局部变量表占据字节码22个字节长度。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/33.png" alt="image-20201214110048114">&lt;/p>
&lt;p>因此，行号表的字节码如下图红框所示：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/34.png" alt="image-20201214111222724">&lt;/p>
&lt;h2 id="43localvariabletable属性的行数据">4.3.LocalVariableTable属性的行数据&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each entry in the &lt;code>local_variable_table&lt;/code> array indicates a range of &lt;code>code&lt;/code> array offsets within which a local variable has a value. It also indicates the index into the local variable array of the current frame at which that local variable can be found. Each entry must contain the following five items:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>start_pc, length&lt;/p>
&lt;p>The given local variable must have a value at indices into the &lt;code>code&lt;/code> array in the interval [&lt;code>start_pc&lt;/code>, &lt;code>start_pc + length&lt;/code>), that is, between &lt;code>start_pc&lt;/code> inclusive and &lt;code>start_pc + length&lt;/code> exclusive.The value of &lt;code>start_pc&lt;/code> must be a valid index into the &lt;code>code&lt;/code> array of this &lt;code>Code&lt;/code> attribute and must be the index of the opcode of an instruction.The value of &lt;code>start_pc + length&lt;/code> must either be a valid index into the &lt;code>code&lt;/code> array of this &lt;code>Code&lt;/code> attribute and be the index of the opcode of an instruction, or it must be the first index beyond the end of that &lt;code>code&lt;/code> array.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>name_index&lt;/p>
&lt;p>The value of the &lt;code>name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table. The &lt;code>constant_pool&lt;/code> entry at that index must contain a &lt;code>CONSTANT_Utf8_info&lt;/code> structure (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7">§4.4.7&lt;/a>) representing a valid unqualified name denoting a local variable (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.2.2">§4.2.2&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>descriptor_index&lt;/p>
&lt;p>The value of the &lt;code>descriptor_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table. The &lt;code>constant_pool&lt;/code> entry at that index must contain a &lt;code>CONSTANT_Utf8_info&lt;/code> structure (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4.7">§4.4.7&lt;/a>) representing a field descriptor which encodes the type of a local variable in the source program (&lt;a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2">§4.3.2&lt;/a>).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>index&lt;/p>
&lt;p>The given local variable must be at &lt;code>index&lt;/code> in the local variable array of the current frame.If the local variable at &lt;code>index&lt;/code> is of type &lt;code>double&lt;/code> or &lt;code>long&lt;/code>, it occupies both &lt;code>index&lt;/code> and &lt;code>index + 1&lt;/code>.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>行号表分为X列：&lt;/p>
&lt;p>列1是&lt;strong>局部变量在JVM指令序列的索引(start_pc)&lt;/strong>&lt;/p>
&lt;p>列2是&lt;strong>局部变量在JVM指令序列偏移量(length)&lt;/strong>&lt;/p>
&lt;p>列3是&lt;strong>局部变量名在常量池中的索引&lt;/strong>&lt;/p>
&lt;p>列4是&lt;strong>局部变量类型&lt;/strong>&lt;/p>
&lt;p>列5是&lt;strong>局部变量槽位&lt;/strong>——这里涉及到槽位重用问题，笔者将在讲解虚拟机栈的后续章节展开。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/35.png" alt="image-20201214105609730">&lt;/p>
&lt;p>我们将前文解读的JVM指令序列、Demo2的hello方法的源代码，与行号表的字节码对比，可以看到：&lt;/p>
&lt;p>局部变量表第1行数据：表示局部变量this，类型为Demo2，作用域hello整个函数。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/36.png" alt="image-20201214112254032">&lt;/p>
&lt;p>局部变量表第2行数据：表示局部变量i，类型为int，作用域hello函数的**&amp;ldquo;int i =1&amp;quot;语句后**，**“return”语句前**。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/37.png" alt="image-20201214112737327">&lt;/p>
&lt;h1 id="5总结jvm如何描述一个方法的内部实现">5.总结：JVM如何描述一个方法的内部实现?&lt;/h1>
&lt;p>根据Demo2演练代码，JVM描述了如下信息：&lt;/p>
&lt;h2 id="51三大重要信息的转换与存储">5.1.三大重要信息的转换与存储&lt;/h2>
&lt;ul>
&lt;li>在&lt;strong>虚拟机栈&lt;/strong>中，为hello方法开辟了一个&lt;strong>栈帧&lt;/strong>&lt;/li>
&lt;li>将源代码转换为&lt;strong>JVM指令序列&lt;/strong>，存储在&lt;strong>栈帧的Code属性&lt;/strong>中&lt;/li>
&lt;li>将局部变量存储在&lt;strong>栈帧的局部变量表&lt;/strong>中&lt;/li>
&lt;li>将源代码和JVM指令序列&lt;strong>位置映射关系&lt;/strong>，&lt;strong>存储在栈帧的行号表&lt;/strong>中&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/38.png" alt="image-20201214120538585">&lt;/p>
&lt;h2 id="52随着jvm指令序列执行动态刷新内存栈帧">5.2.随着JVM指令序列执行，动态刷新内存(栈帧)&lt;/h2>
&lt;ul>
&lt;li>当逻辑代码&lt;strong>int i =1&lt;/strong>执行时，栈帧中JVM指令序列执行到3C处，局部变量i被赋值为1；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/39.png" alt="image-20201214121148759">&lt;/p>
&lt;ul>
&lt;li>当逻辑代码&lt;strong>System.out.println(&amp;ldquo;hello world&amp;rdquo;)&lt;strong>语句执行时，栈帧中JVM指令序列执行到&lt;/strong>05&lt;/strong>处，打印了常量池中&amp;quot;hello world&amp;quot;字符串；&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/40.png" alt="image-20201214121349494">&lt;/p>
&lt;p>上述过程，引出了JVM运行时数据区中的栈区以及内存结构。读者可以参考笔者这篇文章《【运行时数据区】用仓库管理员的视角理解运行时数据区》&lt;/p>
&lt;h1 id="6再看阅读字节码">6.再看阅读字节码&lt;/h1>
&lt;p>笔者在文章开头写了那个&amp;quot;牛逼程序猿看着一堆16进制致敬女神&amp;quot;的段子，但是头条不让开车就删掉了O(∩_∩)O~&lt;/p>
&lt;p>虽然我们不追求段子中的效果，但阅读字节码，的确是程序猿技术深度的重要体现。&lt;/p>
&lt;p>如果您耐心的将笔者的4篇文章阅读完，&lt;/p>
&lt;ul>
&lt;li>《【编译引擎】学习阅读Class文件结构的意义》&lt;/li>
&lt;li>《【编译引擎】学习阅读Class文件结构(16进制版)-上》&lt;/li>
&lt;li>《【编译引擎】学习阅读Class文件结构(16进制版)-中》&lt;/li>
&lt;li>《【编译引擎】学习阅读Class文件结构(16进制版)-下》&lt;/li>
&lt;/ul>
&lt;p>我们可以再来看看能够阅读字节码的Java程序猿，将具备哪些&amp;quot;一般码农&amp;quot;缺乏的能力：&lt;/p>
&lt;h2 id="61能够从更深的深度理解java的语言语法特性">6.1.能够从更深的深度，理解Java的语言语法特性&lt;/h2>
&lt;p>当您看到《Effective Java》、《阿里编程规范》等编程规范、高效编程实践的时候，&lt;/p>
&lt;p>不了解Java字节码的码农，是这样的思维：&lt;/p>
&lt;blockquote>
&lt;p>因为规范禁止我们这样做，所以我在实战中的代码一定不会这样写。&lt;/p>
&lt;/blockquote>
&lt;p>而了解Java字节码的程序猿，是这样的思维：&lt;/p>
&lt;blockquote>
&lt;p>为什么规范要禁止我们这样做，我要看看JVM指令序列，看看JVM是如何处理的。&lt;/p>
&lt;/blockquote>
&lt;p>例如：规范中禁止&lt;strong>count=count++这种语句&lt;/strong>，&lt;/p>
&lt;p>不了解Java字节码的码农，只能死记硬背；&lt;/p>
&lt;p>而了解Java字节码的程序猿，就可以查看JVM指令序列。&lt;/p>
&lt;h2 id="62能够提供性能优化的高维打击手段">6.2.能够提供性能优化的高维打击手段&lt;/h2>
&lt;p>在Spring源码中，有很多细节代码，下图摘自知乎的一个帖子：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8B/41.png" alt="image-20201214123137927">&lt;/p>
&lt;p>如果不了解字节码，您肯定想不到第2行的代码，居然会对性能优化产生一定的帮助。&lt;/p>
&lt;p>谢谢各位读者！&lt;/p></description></item><item><title>【编译引擎】-2-学习阅读Class文件结构(16进制版)-中</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%AD/</link><pubDate>Thu, 05 Aug 2021 14:50:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%AD/</guid><description>&lt;p>在《【编译引擎】学习阅读Class文件结构(16进制版)-上》中，笔者讲解了如何以16进制的方式，解读Demo2.java对应字节码的常量池。&lt;/p>
&lt;p>我们继续解读Demo2.class字节码的属性表、方法表等重要的片段。&lt;/p>
&lt;h1 id="1对类的描述访问标识">1.对类的描述：访问标识&lt;/h1>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>access_flags&lt;/code> item is a mask of flags used to denote access permissions to and properties of this class or interface.&lt;/p>
&lt;/blockquote>
&lt;p>在字节码文件中，紧接着常量池之后，2个字节表示了当前类或者接口访问标识。&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/1.png" alt="image-20201210103634981">&lt;/p>
&lt;p>我们看一下第35个常量之后紧接着的2个字节：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/2.png" alt="image-20201210104039071">&lt;/p>
&lt;p>这个值=&lt;strong>00 21&lt;/strong>，对照JVM规范可知，&lt;strong>0x0021 = 0x0001 | 0x0020&lt;/strong>，表示当前类是public类型的，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/3.png" alt="image-20201210104405014">&lt;/p>
&lt;p>这两个字节，表示的就是演练代码中红框处内容：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/4.png" alt="image-20201210105237723">&lt;/p>
&lt;h1 id="2继承结构类索引父类索引接口列表">2.继承结构：类索引/父类索引/接口列表&lt;/h1>
&lt;blockquote>
&lt;p>JVM规范：&lt;/p>
&lt;p>The value of the &lt;code>this_class&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;p>For a class, the value of the &lt;code>super_class&lt;/code> item either must be zero or must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;p>The value of the &lt;code>interfaces_count&lt;/code> item gives the number of direct superinterfaces of this class or interface type.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节表示当前&lt;strong>类索引&lt;/strong>&lt;/p>
&lt;p>2个字节表示&lt;strong>父类索引&lt;/strong>&lt;/p>
&lt;p>2个字节表示&lt;strong>接口计数器&lt;/strong>、N个字节(N=接口计数器的值)表示&lt;strong>接口索引列表&lt;/strong>(每个接口索引占2个字节)。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/5.png" alt="image-20201210105451548">&lt;/p>
&lt;p>我们看一下下图红框处的6个字节：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/6.png" alt="image-20201210110411942">&lt;/p>
&lt;p>&lt;strong>00 06&lt;/strong>表示常量池中第6个常量(CONSTANT_Class类型)，进而指向了第28个常量(CONSTANT_Utf8类型)，表示的就是Demo2类。&lt;/p>
&lt;p>&lt;strong>00 07&lt;/strong>表示常量池中第6个常量(CONSTANT_Class类型)，进而指向了第28个常量(CONSTANT_Utf8类型)，表示的就是Demo2的父类——Object类。&lt;/p>
&lt;p>&lt;strong>00 00&lt;/strong>表示接口计数器为0，表示Demo2类没有实现任何接口。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/7.png" alt="image-20201210142241019">&lt;/p>
&lt;p>这些字节码表达了红框处代码的信息：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/8.png" alt="image-20201210143458209">&lt;/p>
&lt;h1 id="3类的成员们字段表">3.类的成员们：字段表&lt;/h1>
&lt;h2 id="31字段计数器">3.1.字段计数器&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>fields_count&lt;/code> item gives the number of &lt;code>field_info&lt;/code> structures in the &lt;code>fields&lt;/code> table&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/9.png" alt="image-20201210143849778">&lt;/p>
&lt;p>红框处的2个字节&lt;strong>00 01&lt;/strong>，表示Demo2类中有1个字段&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/10.png" alt="image-20201210144133507">&lt;/p>
&lt;h2 id="32jvm如何表示一个字段">3.2.JVM如何表示一个字段&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each field is described by a &lt;code>field_info&lt;/code> structure.&lt;/p>
&lt;p>No two fields in one &lt;code>class&lt;/code> file may have the same name and descriptor&lt;/p>
&lt;/blockquote>
&lt;p>JVM为了表示类中的一个字段(例如：一个实例变量)，用如下数据结构表示：&lt;/p>
&lt;p>访问标志：2个字节，就是这个字段的访问权限，例如：private、public等。&lt;/p>
&lt;p>字段名索引：2个字节，就是这个字段的在常量池中的索引。&lt;/p>
&lt;p>字段描述符：2个字节，就是这个字段的类型。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/11.png" alt="image-20201210145124123">&lt;/p>
&lt;h2 id="33字段访问标志">3.3.字段访问标志&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>access_flags&lt;/code> item is a mask of flags used to denote access permission to and properties of this field.&lt;/p>
&lt;/blockquote>
&lt;p>JVM认为字段访问标志包括：public、private、protected，也包括static、final、volatile、transient，还包括enum修饰符&lt;/p>
&lt;p>具体如下表：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/12.png" alt="image-20201210144454329">&lt;/p>
&lt;p>在Demo2类的字节码中，显示值为&lt;strong>00 02&lt;/strong>，说明Demo2有1个字段，字段为private。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/13.png" alt="image-20201210144522844">&lt;/p>
&lt;p>对应Demo2的代码如下图红框：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/14.png" alt="image-20201210145650738">&lt;/p>
&lt;h2 id="33字段名索引">3.3.字段名索引&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>如同其它&amp;quot;索引&amp;quot;类型的信息片段，JVM也是用在常量池的索引表示字段名。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/15.png" alt="image-20201210150016307">&lt;/p>
&lt;p>在Demo2的字节码中，字段名索引值=&lt;strong>00 08&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/16.png" alt="image-20201210150106811">&lt;/p>
&lt;p>&lt;strong>00 08&lt;/strong>表示了常量池&lt;strong>第8个常量&lt;/strong>，第8个常量为CONSTANT_Utf8类型，就是&lt;strong>字面量&amp;quot;field1&amp;rdquo;&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/17.png" alt="image-20201210150325539">&lt;/p>
&lt;p>Demo2源码中，也说明，&lt;strong>Demo2类中实例变量名就是field1&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/18.png" alt="image-20201210150529362">&lt;/p>
&lt;h2 id="34字段描述符">3.4.字段描述符&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>descriptor_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>2个字节的字段描述符，就是表示字段的数据类型，例如：int、byte、char、double或者对象引用等。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/19.png" alt="image-20201210150830424">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 09&lt;/strong>就是字段field1的描述符：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/20.png" alt="image-20201210151009853">&lt;/p>
&lt;p>&lt;strong>00 09&lt;/strong>表示field1的类型可以去查常量池的&lt;strong>第9个常量&lt;/strong>，第9个常量是CONSTANT_Utf8类型，&lt;strong>值为I，I表示的就是int&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/21.png" alt="image-20201210151218499">&lt;/p>
&lt;p>看到Demo2的源码中，&lt;strong>field1的数据类型就是int&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/22.png" alt="image-20201210151241013">&lt;/p>
&lt;h1 id="4类的行为集合方法表">4.类的行为集合：方法表&lt;/h1>
&lt;h2 id="41方法计数器">4.1.方法计数器&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>methods_count&lt;/code> item gives the number of &lt;code>method_info&lt;/code> structures in the &lt;code>methods&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>JVM用2个字节，表示类中具有多少个方法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/23.png" alt="image-20201210152620970">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 02&lt;/strong>说明有2个方法。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/24.png" alt="image-20201210152702983">&lt;/p>
&lt;p>可是Demo2的源码中，不是只有一个方法hello吗？&lt;/p>
&lt;p>那是因为Demo2还有一个构造函数，JVM将构造函数命名为&lt;init>方法。&lt;/p>
&lt;p>JVM还会在某些场景下生成&lt;clinit>方法，笔者将在后续文章中阐述。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/25.png" alt="image-20201210152848314">&lt;/p>
&lt;h2 id="42jvm如何表示一个方法">4.2.JVM如何表示一个方法&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Each method, including each instance initialization method and the class or interface initialization method, is described by a &lt;code>method_info&lt;/code> structure.&lt;/p>
&lt;/blockquote>
&lt;p>要用一种数据结构表达方法，最基本的有3个要素：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>方法的访问权限&lt;/strong>&lt;/li>
&lt;li>&lt;strong>方法名&lt;/strong>&lt;/li>
&lt;li>&lt;strong>方法返回值类型&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>进一步，方法体、方法内的局部变量等等怎么表达呢？&lt;/p>
&lt;p>JVM采用了属性表来表示它们，这一部分，也是笔者认为&amp;quot;广义的编译器&amp;quot;非常聪明、非常巧妙的信息表示方法。&lt;/p>
&lt;p>下图摘自JVM规范，方法内部的信息采用属性表表示，属性表中每一个属性又可以嵌套一个子属性表。&lt;/p>
&lt;p>这样就形成了一个多级的属性树。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/26.png" alt="image-20201210155258368">&lt;/p>
&lt;p>这里表述的很抽象，我们接下来以Demo2中的hello方法为例，具象化地理解JVM表达方法的method_info以及下属的属性树。&lt;/p>
&lt;p>下图红框，就是hello方法，在字节码中的信息片段。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/27.png" alt="image-20201210152525140">&lt;/p>
&lt;h2 id="43hello方法的访问标识符">4.3.hello方法的访问标识符&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>access_flags&lt;/code> item is a mask of flags used to denote access permission to and properties of this method.&lt;/p>
&lt;/blockquote>
&lt;p>方法访问标识符包括：public/private/protected，也包括static/final，还包括synchronized/native，以及abstract等等。&lt;/p>
&lt;p>可以看到方法的访问标识符就是Java代码中，在方法名前面，对方法的各种访问限定，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/28.png" alt="image-20201210163636030">&lt;/p>
&lt;p>Demo2的字节码中，访问标识符=&lt;strong>00 01&lt;/strong>，根据上表，说明hello方法是public类型的：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/29.png" alt="image-20201210163418660">&lt;/p>
&lt;p>对照Demo2的源代码，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/30.png" alt="image-20201210163938998">&lt;/p>
&lt;h2 id="44hello方法名">4.4.hello方法名&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>name_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>这2个字节也是索引类型，指向了常量池中的常量。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/31.png" alt="image-20201210164225563">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 11&lt;/strong>指向了&lt;strong>第17个常量&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/32.png" alt="image-20201210164206078">&lt;/p>
&lt;p>根据常量池中的第17个常量，进而可以&lt;strong>得到方法名为&amp;quot;hello&amp;rdquo;&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/33.png" alt="image-20201210164338588">&lt;/p>
&lt;p>对照Demo2的源码，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/34.png" alt="image-20201210164353158">&lt;/p>
&lt;h2 id="45hello方法的描述符">4.5.hello方法的描述符&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>descriptor_index&lt;/code> item must be a valid index into the &lt;code>constant_pool&lt;/code> table.&lt;/p>
&lt;/blockquote>
&lt;p>方法描述符，可以理解为方法的输入参数类型列表和返回值类型&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/35.png" alt="image-20201210164948299">&lt;/p>
&lt;p>Demo2字节码的方法描述为&lt;strong>00 08&lt;/strong>，指向了常量池中&lt;strong>第11个常量&lt;/strong>，第11个常量的值=**&amp;quot;()V&amp;rdquo;**。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/36.png" alt="image-20201210164907934">&lt;/p>
&lt;p>&lt;strong>()&lt;strong>表示没有输入参数，&lt;strong>V&lt;/strong>表示&lt;/strong>void&lt;/strong>类型的返回值：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/37.png" alt="image-20201210165507268">&lt;/p>
&lt;p>对应Demo2的源代码：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/38.png" alt="image-20201210165604070">&lt;/p>
&lt;h2 id="46hello方法的属性计数器">4.6.hello方法的属性计数器&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The value of the &lt;code>attributes_count&lt;/code> item indicates the number of additional attributes of this method.&lt;/p>
&lt;/blockquote>
&lt;p>方法下，下挂了属性树，这2个字节就表示了属性个数。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/39.png" alt="image-20201210171021692">&lt;/p>
&lt;p>Demo2的字节码中，&lt;strong>00 01&lt;/strong>表示hello方法下挂了&lt;strong>1个属性&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/40.png" alt="image-20201210170911839">&lt;/p>
&lt;p>在此，我们先剧透一下hello方法下挂的属性树结构：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/41.png" alt="image-20201210170336772">&lt;/p>
&lt;p>从上图，我们可以得到2个信息：&lt;/p>
&lt;ul>
&lt;li>JVM对于类中的方法，都会下挂一个&lt;strong>Code属性&lt;/strong>，Code属性&lt;strong>像一个容器&lt;/strong>，下面&lt;strong>可以挂更多的子属性&lt;/strong>&lt;/li>
&lt;li>&lt;strong>LineNumberTable&lt;/strong>属性、&lt;strong>LocalVariableTable&lt;/strong>属性，都是一种&lt;strong>表结构类型的属性&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h1 id="5总结jvm如何描述一个类">5.总结：JVM如何描述一个类?&lt;/h1>
&lt;p>根据Demo2演练代码，JVM描述了如下信息：&lt;/p>
&lt;h2 id="51类的信息">5.1.类的信息&lt;/h2>
&lt;p>JVM字节码中构建了这样一颗与类有关的信息树&lt;/p>
&lt;blockquote>
&lt;p>有一个叫Demo2的类，是public类型的，继承于Object类&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/42.png" alt="image-20201210174253160">&lt;/p>
&lt;h2 id="52类中字段相关的信息">5.2.类中字段相关的信息&lt;/h2>
&lt;p>JVM构建了字节相关的信息树，遍历可知：&lt;/p>
&lt;blockquote>
&lt;p>Demo2类中有一个字段field1，是private的，是int类型的&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/43.png" alt="image-20201210174530083">&lt;/p>
&lt;h2 id="53类中方法相关的信息">5.3.类中方法相关的信息&lt;/h2>
&lt;p>JVM构建了方法相关的信息树，遍历可知：&lt;/p>
&lt;blockquote>
&lt;p>Demo2类中有一个方法叫做hello，是public的，没有输入也没有返回&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/44.png" alt="image-20201210174755908">&lt;/p>
&lt;h1 id="6下一步">6.下一步&lt;/h1>
&lt;p>笔者下篇会继续阅读本演练代码对应的Class文件剩余部分，包括&lt;/p>
&lt;blockquote>
&lt;p>方法内部相关的信息&lt;/p>
&lt;/blockquote>
&lt;p>如果您能耐心地看到这句话，恭喜您，距离&amp;rdquo;&lt;strong>看着16进制享受而诡魅的微笑&lt;/strong>&amp;ldquo;又近了一步，加油！&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%AD/45.png" alt="image-20201210174921805">&lt;/p></description></item><item><title>【编译引擎】-2-学习阅读Class文件结构(16进制版)-上</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8A/</link><pubDate>Thu, 05 Aug 2021 14:42:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%8416%E8%BF%9B%E5%88%B6%E7%89%88-%E4%B8%8A/</guid><description>&lt;p>大学时有个段子：什么是最牛逼的程序猿？&lt;/p>
&lt;p>最牛程序猿深情地注视着屏幕上一堆16进制，露出满足而诡魅的微笑。&lt;/p>
&lt;p>同学问他在看啥，他小声说：蒼井そら。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/1.png" alt="image-20201203084643095">&lt;/p>
&lt;p>好，下面，我们也来学习阅读一下16进制版的Class文件。&lt;/p>
&lt;h1 id="1源头class规范">1.源头：Class规范&lt;/h1>
&lt;p>每一个Java版本发布时，会公布两份规范文档(以Java8为例)：&lt;/p>
&lt;blockquote>
&lt;p>Java语言规范：《The Java Language Specification, Java SE 8 Edition》&lt;/p>
&lt;p>Java虚拟机规范：《The Java Virtual Machine Specification, Java SE 8 Edition》&lt;/p>
&lt;/blockquote>
&lt;p>Java虚拟机规范中有很大篇幅就是描述Class文件格式的规格，它也是帮助我们学习、理解Class文件最好的参考资料。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/2.png" alt="image-20201203090336783">&lt;/p>
&lt;h1 id="2验证演练代码">2.验证：演练代码&lt;/h1>
&lt;p>为了更好地覆盖JVM规范中描述的Class文件格式主脉络，笔者设计了如下示例代码：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/3.png" alt="image-20201203085719069">&lt;/p>
&lt;p>这段代码体现了5种Java的语法特征：&lt;/p>
&lt;blockquote>
&lt;p>类：Demo2&lt;/p>
&lt;p>成员变量：私有成员变量filed1，int类型，初始值为1&lt;/p>
&lt;p>方法：公有方法hello，无参数无返回值&lt;/p>
&lt;p>局部变量：局部变量i，int类型，初始值为1&lt;/p>
&lt;p>语句：打印语句println，打印内容为hello world&lt;/p>
&lt;/blockquote>
&lt;p>使用javac编译上述代码，我们会得到Demo2.class文件，用16进制编辑器打开如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/4.png" alt="image-20201203101943544">&lt;/p>
&lt;p>为了更清晰的查看，我们将上述数据复制到Excel表格中，着色&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/5.png" alt="image-20201203112942827">&lt;/p>
&lt;h1 id="3合法性检查依据魔数版本号">3.合法性检查依据：魔数、版本号&lt;/h1>
&lt;p>首先，通过阅读规范，我们获得如下知识：&lt;/p>
&lt;blockquote>
&lt;p>魔数：4个字节&lt;/p>
&lt;p>副版本号：2个字节&lt;/p>
&lt;p>主版本号：2个字节&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/6.png" alt="image-20201203102514844">&lt;/p>
&lt;p>然后，在IDE中将&lt;strong>魔数&lt;/strong>标记出来：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/7.png" alt="image-20201203113140375">&lt;/p>
&lt;p>然后，在IDE中将&lt;strong>版本号&lt;/strong>标记出来：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/8.png" alt="image-20201203113240887">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>分析&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>魔数值和版本号是JVM加载Class文件时的合法性检查依据：&lt;/p>
&lt;blockquote>
&lt;p>如果16进制文件内容的开始不是&lt;strong>CA FE BA BE&lt;/strong>，则JVM就认为这个文件不是合法的Class文件；&lt;/p>
&lt;p>如果16进制文件内容的版本号与JVM版本号不匹配，则JVM就拒绝加载。&lt;strong>00 00 00 34&lt;/strong>，表示Java8对应的JVM可以加载。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;strong>技术直男的浪漫&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>这里值得提到一个趣闻：魔数值&lt;strong>CA FE BA BE&lt;/strong>，应该这样断句：&lt;strong>CAFE BABE&lt;/strong>。&lt;/p>
&lt;p>Gosling，这位资深技术直男，就是这样温情地形容，他发明的这个编程语言——&lt;strong>咖啡宝贝&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/9.png" alt="image-20201203105231554">&lt;/p>
&lt;h1 id="4信息仓库常量池">4.信息仓库：常量池&lt;/h1>
&lt;h2 id="41常量池计数器">4.1.常量池计数器&lt;/h2>
&lt;p>在笔者前一篇文章《【编译引擎】学习阅读Class文件结构的意义》中提到：&lt;/p>
&lt;blockquote>
&lt;p>常量池：本质是一张表格。&lt;/p>
&lt;p>常量：是站在JVM角度看，公用的一些常量值，为了压缩Class文件的大小而存在。&lt;/p>
&lt;/blockquote>
&lt;p>因此，JVM规范才规定Class文件中，有2个字节的&lt;strong>常量池计数器&lt;/strong>(表示常量表格的长度)，紧接着的&lt;strong>N个字节&lt;/strong>存储&lt;strong>M个常量&lt;/strong>的具体内容&lt;/p>
&lt;blockquote>
&lt;p>M个常量：M=常量池计数器的值 - 1&lt;/p>
&lt;p>N个字节：N是变长的，因为每个常量类型不同，有的常量需要4个字节存储，有的常量需要很多字节存储。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/10.png" alt="image-20201203110434464">&lt;/p>
&lt;ul>
&lt;li>首先，找到&lt;strong>常量池计数器&lt;/strong>=&lt;strong>00 24&lt;/strong>，转换为10进制是36，说明&lt;strong>常量池中存储了35个常量&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>一个规范中的细节：The &lt;code>constant_pool&lt;/code> table is indexed from 1 to &lt;code>constant_pool_count&lt;/code> - 1.&lt;/p>
&lt;p>这段话的意思是，常量池计数器值-1就是常量个数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/11.png" alt="image-20201203114851834">&lt;/p>
&lt;h2 id="42n种常量类型">4.2.N种常量类型&lt;/h2>
&lt;p>接下来，我们解读具体的常量，前文讲过，常量有不同的类型，那么Class文件如何表达常量类型呢？&lt;/p>
&lt;p>规范中，采用了如下结构表示不同类型的常量：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/12.png" alt="image-20201203115414837">&lt;/p>
&lt;p>那么，JVM支持多少种类型的常量呢？&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/13.png" alt="image-20201203115520340">&lt;/p>
&lt;p>本文的演练代码中，涉及到了种类型的常量：&lt;/p>
&lt;blockquote>
&lt;p>CONSTANT_Utf8：1&lt;/p>
&lt;p>CONSTANT_String：8&lt;/p>
&lt;p>CONSTANT_Class：7&lt;/p>
&lt;p>CONSTANT_Fieldref：9&lt;/p>
&lt;p>CONSTANT_NameAndType：12&lt;/p>
&lt;p>CONSTANT_Methodref：10&lt;/p>
&lt;/blockquote>
&lt;h2 id="43constant_utf8类型的常量">4.3.CONSTANT_Utf8类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_Utf8_info&lt;/code> structure is used to represent constant string values&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，就是表达字符串字面量。&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/14.png" alt="image-20201203120726026">&lt;/p>
&lt;p>我们以第25个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/15.png" alt="image-20201203120926294">&lt;/p>
&lt;p>这个常量值=&lt;strong>01 00 0B 68 65 6C 6C 6F 20 77 6F 72 6C 64&lt;/strong>，如下图所示的含义&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/16.png" alt="image-20201203121756603">&lt;/p>
&lt;p>第25个常量，表示的就是演练代码中的打印的字符串内容：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/17.png" alt="image-20201203122016513">&lt;/p>
&lt;h2 id="44constant_string类型的常量">4.4.CONSTANT_String类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_String_info&lt;/code> structure is used to represent constant objects of the type &lt;code>String&lt;/code>:&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，是字符串对象类型的，它的值指向4.3中描述的字符串字面量。&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/18.png" alt="image-20201203122939616">&lt;/p>
&lt;p>我们以第5个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/19.png" alt="image-20201203122644594">&lt;/p>
&lt;p>这个常量的值= &lt;strong>08 00 19&lt;/strong>，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/20.png" alt="image-20201203123306833">&lt;/p>
&lt;p>结合第5个常量和第25个常量，再看演练代码，我们窥见&lt;strong>JVM处理字符串的原理&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/21.png" alt="image-20201203123552479">&lt;/p>
&lt;h2 id="45constant_class类型的常量">4.5.CONSTANT_Class类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_Class_info&lt;/code> structure is used to represent a class or an interface&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示类或者接口&lt;/p>
&lt;p>它的结构如下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/22.png" alt="image-20201203124237102">&lt;/p>
&lt;p>我们以第6个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/23.png" alt="image-20201203124334512">&lt;/p>
&lt;p>这个常量的值= &lt;strong>07 00 1C&lt;/strong>，结合第28个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/24.png" alt="image-20201203124818815">&lt;/p>
&lt;p>再看演练代码，CONSTANT_Class类型的常量表达了演练代码中定义的Demo2类：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/25.png" alt="image-20201203124958357">&lt;/p>
&lt;h2 id="46constant_fieldref类型的常量">4.6.CONSTANT_Fieldref类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Fields, methods, and interface methods are represented by similar structures:&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示字段(例如：一个类中的成员变量)。JVM规范还告诉我们，实例方法、接口方法都是同样的Class格式。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/26.png" alt="image-20201203125455813">&lt;/p>
&lt;p>我们以第2个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/27.png" alt="image-20201203125918470">&lt;/p>
&lt;p>这个常量的值= &lt;strong>09 00 06 00 16&lt;/strong>，结合第6个常量和第22个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/28.png" alt="image-20201203130857438">&lt;/p>
&lt;p>但是第22个常量=&lt;strong>0C 00 08 00 09&lt;/strong>表示了什么呢？我们看下一章节的解读&lt;/p>
&lt;h2 id="47constant_nameandtype类型的常量">4.7.CONSTANT_NameAndType类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：The &lt;code>CONSTANT_NameAndType_info&lt;/code> structure is used to represent a field or method, without indicating which class or interface type it belongs to&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示一个字段的类型信息&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/29.png" alt="image-20201203131307059">&lt;/p>
&lt;p>我们以第22个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/30.png" alt="image-20201203131134360">&lt;/p>
&lt;p>这个常量的值= &lt;strong>0C 00 08 00 09&lt;/strong>，结合第8个常量和第9个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/31.png" alt="image-20201203131856257">&lt;/p>
&lt;p>至此，我们就看到了演练代码中在JVM中如何表达&lt;code>int field1&lt;/code>信息了：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/32.png" alt="image-20201203132039284">&lt;/p>
&lt;h2 id="48constant_methodref类型的常量">4.8.CONSTANT_Methodref类型的常量&lt;/h2>
&lt;blockquote>
&lt;p>JVM规范：Fields, methods, and interface methods are represented by similar structures:&lt;/p>
&lt;/blockquote>
&lt;p>这种类型的常量，表示方法。JVM规范还告诉我们，它的结构和字段类型常量都是同样的Class格式。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/33.png" alt="image-20201203132452923">&lt;/p>
&lt;p>我们以第5个常量为例，尝试理解一下：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/34.png" alt="image-20201203132633860">&lt;/p>
&lt;p>这个常量的值= &lt;strong>0A 00 1A 00 1B&lt;/strong>，结合第26、27个常量，如下图所示的含义：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/35.png" alt="image-20201203134131024">&lt;/p>
&lt;h1 id="5总结常量池构建的静态全局观">5.总结：常量池构建的静态全局观&lt;/h1>
&lt;p>根据演练代码产生的Class文件，JVM构建了35个常量：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/36.png" alt="image-20201203134423990">&lt;/p>
&lt;p>我们以图形化的方式进一步看看，Class文件的常量池到底为JVM构建了怎样的&lt;strong>信息树&lt;/strong>？&lt;/p>
&lt;h2 id="51源代码中有哪些方法引用">5.1.源代码中有哪些方法引用&lt;/h2>
&lt;p>常量池构建了方法引用的信息树，我们可以看到&lt;strong>两颗方法引用树&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/37.png" alt="image-20201203143257328">&lt;/p>
&lt;p>以其中一棵树为例，遍历这棵树，我们可以得到如图的信息：&lt;/p>
&lt;blockquote>
&lt;p>源代码中有一个方法，此方法属于Object类，方法名为&lt;init>，方法无输入参数，无返回&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/38.png" alt="image-20201203143352283">&lt;/p>
&lt;h2 id="52源代码中有哪些字段引用">5.2.源代码中有哪些字段引用&lt;/h2>
&lt;p>常量池构建了字段引用的信息树，我们可以看到&lt;strong>两颗字段引用树&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/39.png" alt="image-20201203143527781">&lt;/p>
&lt;p>以其中一棵树为例，遍历这棵树，我们可以得到如图的信息：&lt;/p>
&lt;blockquote>
&lt;p>源代码中有一个字段，此字段属于Demo2类，字段名为field1，字段数据类型为int&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/40.png" alt="image-20201203143719972">&lt;/p>
&lt;h2 id="53源代码中有哪些字符串对象">5.3.源代码中有哪些字符串对象&lt;/h2>
&lt;p>常量池构建了字符串类型对象的信息树，我们可以看到&lt;strong>一颗字符串对象树&lt;/strong>，如下图：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/41.png" alt="image-20201203143839084">&lt;/p>
&lt;p>以这棵树为例，遍历这棵树，我们可以得到如图的信息：&lt;/p>
&lt;blockquote>
&lt;p>源代码中有一个字符串对象，此字符串对象的值是hello world&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/42.png" alt="image-20201203143944970">&lt;/p>
&lt;h2 id="54源代码中其它的字符串字面量">5.4.源代码中其它的字符串字面量&lt;/h2>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/43.png" alt="image-20201203144014111">&lt;/p>
&lt;h2 id="55静态的全局观">5.5.静态的全局观&lt;/h2>
&lt;p>至此，我们已经看到了常量池为JVM诠释了Java源代码中的信息树。&lt;/p>
&lt;p>&lt;strong>常量池中的这些信息树，为JVM构建出了一个静态的全局观&lt;/strong>。&lt;/p>
&lt;p>通过这些信息树，我们已经能&lt;strong>反演出Java源代码中的静态结构&lt;/strong>：&lt;/p>
&lt;blockquote>
&lt;p>有几个类？&lt;/p>
&lt;p>类中有几个成员变量？&lt;/p>
&lt;p>类中有几个方法？&lt;/p>
&lt;p>每个成员变量的名称、数据类型&lt;/p>
&lt;p>每个方法的名称、输入参数列表、返回值类型&lt;/p>
&lt;/blockquote>
&lt;p>但常量池中还有一些信息孤点，我们无法反演出一些&lt;strong>动态结构&lt;/strong>：&lt;/p>
&lt;blockquote>
&lt;p>成员变量的状态变化过程&lt;/p>
&lt;p>方法体内的运行过程&lt;/p>
&lt;p>方法内局部变量的变化过程&lt;/p>
&lt;/blockquote>
&lt;h1 id="6下一步">6.下一步&lt;/h1>
&lt;p>笔者下篇会继续阅读本演练代码对应的Class文件剩余部分，包括&lt;/p>
&lt;blockquote>
&lt;p>访问标识&lt;/p>
&lt;p>类索引&lt;/p>
&lt;p>字段表&lt;/p>
&lt;p>方法表&lt;/p>
&lt;p>属性表&lt;/p>
&lt;/blockquote>
&lt;p>进一步理解Class字节码如何为JVM&lt;strong>构建动态全局观&lt;/strong>。&lt;/p>
&lt;p>**高能预警：**如果您能耐心地看到这句话，恭喜您，距离&amp;rdquo;&lt;strong>看着16进制享受而诡魅的微笑&lt;/strong>&amp;ldquo;又近了一步，加油！&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-2-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84(16%E8%BF%9B%E5%88%B6%E7%89%88)-%E4%B8%8A/44.png" alt="image-20201203144947702">&lt;/p></description></item><item><title>【编译引擎】 1 学习阅读Class文件结构的意义</title><link>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/</link><pubDate>Thu, 05 Aug 2021 14:37:31 +0800</pubDate><guid>https://jherculesqz.github.io/post/java%E6%8B%BE%E9%81%97/%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBclass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/</guid><description>&lt;h1 id="1起于累土为什么要阅读字节码">1.起于累土：为什么要阅读字节码&lt;/h1>
&lt;p>笔者最近的一项工作是设计一套课程，用于辅导新员工如何做好性能优化。&lt;/p>
&lt;p>这项工作很快遇到了问题：&lt;/p>
&lt;blockquote>
&lt;p>讲内存泄露/溢出的定位工具，就要求听众先对JVM的运行时数据区有基本理解。&lt;/p>
&lt;p>讲运行时数据区，又要求听众先大致理解类加载子系统如何一步步地将字节码加载到内存中。&lt;/p>
&lt;p>讲类加载子系统，又要求听众先理解字节码表示了哪些&amp;quot;静态信息&amp;rdquo;。&lt;/p>
&lt;p>&amp;hellip;.&lt;/p>
&lt;/blockquote>
&lt;p>性能优化是一个复杂的系统化话题，性能优化的手段分为3个级别：&lt;/p>
&lt;p>&lt;strong>倔强青铜级：时空转移&lt;/strong>&lt;/p>
&lt;p>当计算效率不足时，用空间换时间。例如：将需要频繁使用的数据，提前缓存在内存中。&lt;/p>
&lt;p>当内存空间不足时，用时间换空间。例如：将不需要的缓存数据去掉，动态计算。&lt;/p>
&lt;p>在这个层次上解决问题，&lt;strong>优点是朴实&lt;/strong>，&lt;strong>缺点是此消彼长、绵绵无期&lt;/strong>：&lt;/p>
&lt;p>因为&lt;strong>时间换空间&lt;/strong>与&lt;strong>空间换时间&lt;/strong>本质是互逆的手段。&lt;/p>
&lt;p>一个软件产品可能在迭代1暴露出了计算效率不足，采用了空间换时间。&lt;/p>
&lt;p>到了迭代2又因为迭代1的性能优化导致空间不足，又要将大量的缓存替换为实时计算。&lt;/p>
&lt;p>……&lt;/p>
&lt;p>笔者的一位程序猿朋友，在多次时间换空间、空间换时间的性能优化工作之后，发出了一句颇有哲理的感慨：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>时间是不可能被消灭的，只能被转移&lt;/strong>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/1-2-1.png" alt="image-20201128154031535">&lt;/p>
&lt;p>&lt;strong>永恒钻石级：业务裁剪&lt;/strong>&lt;/p>
&lt;p>能用这个级别手法的，一般是老程序猿。&lt;/p>
&lt;p>凭借多年的业务领域经验，深刻理解了业务流程中哪些步骤是冗余的。&lt;/p>
&lt;p>无论是时间瓶颈或者空间瓶颈，删掉冗余代码，一招搞定。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/1-2-2.png" alt="image-20201128155657776">&lt;/p>
&lt;p>在这个层次上解决问题，&lt;strong>优点还是朴实，缺点是比较依赖业务专家，无法批量复制与推广&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>最强王者级：底层优化&lt;/strong>&lt;/p>
&lt;p>使用这种手法，就要求程序猿对于JVM、操作系统、网络有比较深刻的认识，大部分程序猿都止步此。&lt;/p>
&lt;p>通过对静态逻辑(字节码)的理解和动态逻辑(运行时)的理解，精确找到空间瓶颈和时间瓶颈，进而采用更加具有通用性的手段开展优化工作。&lt;/p>
&lt;p>如果说&lt;strong>性能优化是九层之塔&lt;/strong>，那么&lt;strong>阅读字节码&lt;/strong>就是累土中的重要基石之一。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/1-2-3.png" alt="image-20201128160013429">&lt;/p>
&lt;h1 id="2编程界的通天塔字节码的宏观意义">2.编程界的通天塔：字节码的宏观意义&lt;/h1>
&lt;p>知乎上有一个趣帖&lt;code>全世界为什么不能统一语言？&lt;/code>(&lt;a href="https://www.zhihu.com/question/22133387">https://www.zhihu.com/question/22133387&lt;/a>)&lt;/p>
&lt;p>有一个有趣的回答：&amp;ldquo;你想造通天塔就直说&amp;rdquo;。&lt;/p>
&lt;p>通天塔，也叫巴别塔，传说人类想建造一个通往天堂的天梯而触怒了神灵，于是神灵将人类的语言隔绝，导致人类种族语言不通。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-1.png" alt="image-20201128163114423">&lt;/p>
&lt;p>编程界也存在多种编程语言，任何VM类型的语言(含编译、执行)都存在如下流程：&lt;/p>
&lt;blockquote>
&lt;p>前端编译器：将源代码转换为字节码&lt;/p>
&lt;p>字节码加载模块：将字节码加载到运行时数据区(就是内存)&lt;/p>
&lt;p>解释执行器：根据内存中的VM栈，执行字节码&lt;/p>
&lt;p>后端编译器：将频繁执行的字节码直接生成为机器码缓存下来，提升执行效率&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-2.png" alt="image-20201126100836623">&lt;/p>
&lt;p>我们会发现，字节码加载、运行时数据区似乎大同小异，于是进一步简化上述流程：&lt;/p>
&lt;blockquote>
&lt;p>字节码加载取决于运行时数据区&lt;/p>
&lt;p>运行时数据区的理论主要是分代理论、回收理论等&lt;/p>
&lt;/blockquote>
&lt;p>从简化的流程中，我们可以看到，一种编程语言的&lt;strong>源代码语法无论多么&amp;quot;花哨&amp;rdquo;&lt;/strong>(满足不同领域的程序猿不同的编程风格)，&lt;strong>最终都要回归到朴实的字节码&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-3.png" alt="image-20201126105406046">&lt;/p>
&lt;p>在Java这种语言中，JVM提供了&lt;strong>javac和javap&lt;/strong>两种工具实现前端编译和前端反编译的互逆操作：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-4.png" alt="image-20201126105515858">&lt;/p>
&lt;p>试想一下，&lt;strong>如果字节码是一种规范&lt;/strong>，&amp;ldquo;类加载子系统、运行时数据区、解释执行器、后端编译器&amp;quot;就有可能做成&lt;strong>VM内置的标准件&lt;/strong>，那么开发一种新的编程语言只需要关注2点：&lt;/p>
&lt;blockquote>
&lt;p>1.如何设计一种新的语法，满足新编程领域的特征、风格？&lt;/p>
&lt;p>2.如何将新的语法源代码，转换为标准的字节码？&lt;/p>
&lt;/blockquote>
&lt;p>设计一种新的编程语言，上述2点并不是很困难，而真正的技术门槛、技术成本是那些VM内置的标准件。&lt;/p>
&lt;p>这将是一种可怕的效率提升革命，于是Java之父Gosling强调：&lt;/p>
&lt;blockquote>
&lt;p>JVM能支持各种符合字节码规范的新兴编程语言，Java只是JVM上能运行的编程语言之一。&lt;/p>
&lt;p>Java并不牛逼，JVM才是最牛逼的。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-5.png" alt="image-20201126110532663">&lt;/p>
&lt;p>&lt;strong>字节码就是统一的机器语言：&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>从程序猿的视角看，无论使用怎样不同的编程语言，都能被前端编译器转换为标准的JVM字节码；&lt;/p>
&lt;p>从CPU的视角看，无论是怎样不同的CPU架构，后端编译器都能将标准的JVM字节码转换为不同的机器码；&lt;/p>
&lt;/blockquote>
&lt;p>目前，JVM支持了很多编程语言，其中包含了注入Kotlin这种热度很高的新型语言：&lt;/p>
&lt;blockquote>
&lt;p>数据来源：https://www.slant.co/topics/397/~best-languages-that-run-on-the-jvm&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/2-6.png" alt="1.png">&lt;/p>
&lt;h1 id="3引用地图字节码的微观逻辑">3.引用地图：字节码的微观逻辑&lt;/h1>
&lt;p>JVM字节码的规范很复杂，在深入细节之前，最好先理解字节码的微观逻辑。&lt;/p>
&lt;p>首先写一段简单的代码Demo4.java：&lt;/p>
&lt;blockquote>
&lt;p>这个类只有一个无参构造函数&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-1.png" alt="image-20201128171824843">&lt;/p>
&lt;p>再通过前端编译器，从Demo4.java生成Demo4.class:&lt;/p>
&lt;blockquote>
&lt;p>用16进制编辑器打开&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-2.png" alt="image-20201128172301948">&lt;/p>
&lt;p>Class文件分为2个部分：常量池和方法区&lt;/p>
&lt;blockquote>
&lt;p>红色框：常量池区域&lt;/p>
&lt;p>橙色框：方法区区域&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-3.png" alt="image-20201128174147100">&lt;/p>
&lt;p>这里的常量、方法，不是Java语法中的常量、方法，而是&lt;strong>站在VM的角度看到的常量和方法&lt;/strong>。&lt;/p>
&lt;p>例如：&amp;ldquo;Demo4&amp;quot;这个字符串，在Java源代码中出现了2次：&lt;/p>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-4.png" alt="image-20201128175010006">&lt;/p>
&lt;p>JVM将&amp;quot;Demo4&amp;quot;这个字符串放在了常量池中：&lt;/p>
&lt;blockquote>
&lt;p>蓝色框：Demo4字面量&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-5.png" alt="image-20201128175430731">&lt;/p>
&lt;p>在Java源代码中第一处表达类名时，JVM只需要用1个字节，&lt;strong>最终指向&lt;/strong>常量池中&amp;quot;Demo4&amp;quot;的位置：&lt;/p>
&lt;blockquote>
&lt;p>最终指向：此处简化了从ClassInfo常量逐级指向Utf8_info常量的过程&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://jherculesqz.github.io/Java%E6%8B%BE%E9%81%97/%E3%80%90%E7%BC%96%E8%AF%91%E5%BC%95%E6%93%8E%E3%80%91-1-%E5%AD%A6%E4%B9%A0%E9%98%85%E8%AF%BBClass%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%9A%84%E6%84%8F%E4%B9%89/3-6.png" alt="image-20201128175906442">&lt;/p>
&lt;p>从上述例子可以看到，JVM字节码的微观逻辑就是&lt;strong>引用&lt;/strong>，引用的目的就是复用，复用的目的就是用&lt;strong>最小的字节数表达信息&lt;/strong>。&lt;/p>
&lt;h1 id="4总结">4.总结&lt;/h1>
&lt;p>本文主要内容：&lt;/p>
&lt;ul>
&lt;li>论述阅读字节码对于深入理解编程语言特性的意义&lt;/li>
&lt;li>JVM字节码规范对于设计新的编程语言的价值&lt;/li>
&lt;li>JVM字节码如何通过引用地图，实现最小字节数表示最大的信息量。&lt;/li>
&lt;/ul>
&lt;p>下一步，笔者将通过一段代码实例，深入Class文件结构的细节。&lt;/p>
&lt;h1 id="5参考文献">5.参考文献&lt;/h1>
&lt;blockquote>
&lt;p>&lt;a href="https://www2.slideshare.net/RednaxelaFX/jvm-a-platform-for-multiple-languages">https://www2.slideshare.net/RednaxelaFX/jvm-a-platform-for-multiple-languages&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.slant.co/topics/397/~best-languages-that-run-on-the-jvm">https://www.slant.co/topics/397/~best-languages-that-run-on-the-jvm&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/20003582">https://www.zhihu.com/question/20003582&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.imooc.com/article/296373">https://www.imooc.com/article/296373&lt;/a>&lt;/p>
&lt;/blockquote></description></item></channel></rss>